!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	lrand.c	28;"	d	file:
A1	sin.c	60;"	d	file:
A1	sin.c	72;"	d	file:
A1	tan.c	55;"	d	file:
A1	tan.c	66;"	d	file:
A2	sin.c	61;"	d	file:
A2	sin.c	73;"	d	file:
A2	tan.c	56;"	d	file:
A2	tan.c	67;"	d	file:
ABB_LEN	loc_time.h	14;"	d
ACCESS	test17.c	51;"	d	file:
ACCESS	test18.c	51;"	d	file:
ACCESSED	protect.h	90;"	d
ACC_NR	buf.c	26;"	d	file:
ACF_EMPTY	arp.c	78;"	d	file:
ACF_NETREQ	arp.c	79;"	d	file:
ACF_NOTRCH	arp.c	80;"	d	file:
ACS_BLOCK	cursesio.c	/^unsigned int ACS_BLOCK;$/;"	v
ACS_BOARD	cursesio.c	/^unsigned int ACS_BOARD;$/;"	v
ACS_BTEE	cursesio.c	/^unsigned int ACS_BTEE;$/;"	v
ACS_BULLET	cursesio.c	/^unsigned int ACS_BULLET;$/;"	v
ACS_CKBOARD	cursesio.c	/^unsigned int ACS_CKBOARD;$/;"	v
ACS_DARROW	cursesio.c	/^unsigned int ACS_DARROW;$/;"	v
ACS_DEGREE	cursesio.c	/^unsigned int ACS_DEGREE;$/;"	v
ACS_DIAMOND	cursesio.c	/^unsigned int ACS_DIAMOND;$/;"	v
ACS_HLINE	cursesio.c	/^unsigned int ACS_HLINE;$/;"	v
ACS_LANTERN	cursesio.c	/^unsigned int ACS_LANTERN;$/;"	v
ACS_LARROW	cursesio.c	/^unsigned int ACS_LARROW;$/;"	v
ACS_LLCORNER	cursesio.c	/^unsigned int ACS_LLCORNER;$/;"	v
ACS_LRCORNER	cursesio.c	/^unsigned int ACS_LRCORNER;$/;"	v
ACS_LTEE	cursesio.c	/^unsigned int ACS_LTEE;$/;"	v
ACS_PLMINUS	cursesio.c	/^unsigned int ACS_PLMINUS;$/;"	v
ACS_PLUS	cursesio.c	/^unsigned int ACS_PLUS;$/;"	v
ACS_RARROW	cursesio.c	/^unsigned int ACS_RARROW;$/;"	v
ACS_RTEE	cursesio.c	/^unsigned int ACS_RTEE;$/;"	v
ACS_S1	cursesio.c	/^unsigned int ACS_S1;$/;"	v
ACS_S9	cursesio.c	/^unsigned int ACS_S9;$/;"	v
ACS_TTEE	cursesio.c	/^unsigned int ACS_TTEE;$/;"	v
ACS_UARROW	cursesio.c	/^unsigned int ACS_UARROW;$/;"	v
ACS_ULCORNER	cursesio.c	/^unsigned int ACS_ULCORNER;$/;"	v
ACS_URCORNER	cursesio.c	/^unsigned int ACS_URCORNER;$/;"	v
ACS_VLINE	cursesio.c	/^unsigned int ACS_VLINE;$/;"	v
ADDIT	test25.c	83;"	d	file:
AHA1540	aha_scsi.c	113;"	d	file:
AHA1540A	aha_scsi.c	114;"	d	file:
AHA1540C	aha_scsi.c	117;"	d	file:
AHA1540CF	aha_scsi.c	118;"	d	file:
AHA1640	aha_scsi.c	115;"	d	file:
AHA1740	aha_scsi.c	116;"	d	file:
AHACOM_BUSOFF	aha_scsi.c	127;"	d	file:
AHACOM_BUSON	aha_scsi.c	126;"	d	file:
AHACOM_EXTBIOS	aha_scsi.c	132;"	d	file:
AHACOM_GETCONFIG	aha_scsi.c	130;"	d	file:
AHACOM_GETSETUP	aha_scsi.c	131;"	d	file:
AHACOM_HAINQUIRY	aha_scsi.c	124;"	d	file:
AHACOM_INITBOX	aha_scsi.c	122;"	d	file:
AHACOM_INSTALLED	aha_scsi.c	129;"	d	file:
AHACOM_MBOX_ENABLE	aha_scsi.c	133;"	d	file:
AHACOM_SETIMEOUT	aha_scsi.c	125;"	d	file:
AHACOM_SPEED	aha_scsi.c	128;"	d	file:
AHACOM_STARTSCSI	aha_scsi.c	123;"	d	file:
AHA_ANYINT	aha_scsi.c	103;"	d	file:
AHA_BASEREG	aha_scsi.c	76;"	d	file:
AHA_CDF	aha_scsi.c	97;"	d	file:
AHA_CNTLREG	aha_scsi.c	77;"	d	file:
AHA_DATAREG	aha_scsi.c	79;"	d	file:
AHA_DEBUG	aha_scsi.c	70;"	d	file:
AHA_DF	aha_scsi.c	98;"	d	file:
AHA_DIAGF	aha_scsi.c	94;"	d	file:
AHA_HACC	aha_scsi.c	108;"	d	file:
AHA_HRST	aha_scsi.c	83;"	d	file:
AHA_IDLE	aha_scsi.c	96;"	d	file:
AHA_INIT	aha_scsi.c	95;"	d	file:
AHA_INTRREG	aha_scsi.c	80;"	d	file:
AHA_INVDCMD	aha_scsi.c	100;"	d	file:
AHA_IRST	aha_scsi.c	85;"	d	file:
AHA_MBIF	aha_scsi.c	110;"	d	file:
AHA_MBOE	aha_scsi.c	109;"	d	file:
AHA_MBOXABORT	aha_scsi.c	138;"	d	file:
AHA_MBOXERR	aha_scsi.c	141;"	d	file:
AHA_MBOXFREE	aha_scsi.c	136;"	d	file:
AHA_MBOXOK	aha_scsi.c	140;"	d	file:
AHA_MBOXSTART	aha_scsi.c	137;"	d	file:
AHA_SCRD	aha_scsi.c	107;"	d	file:
AHA_SCRST	aha_scsi.c	86;"	d	file:
AHA_SRST	aha_scsi.c	84;"	d	file:
AHA_STATREG	aha_scsi.c	78;"	d	file:
AHA_STST	aha_scsi.c	93;"	d	file:
AHA_TIMEOUT	aha_scsi.c	309;"	d	file:
ALARM_ON	mproc.h	49;"	d
ALIGN	calloc.c	4;"	d	file:
ALL_BITS	test34.c	28;"	d	file:
ALL_RWXB	test34.c	26;"	d	file:
ALL_SETB	test34.c	27;"	d	file:
ANY	regexp.c	78;"	d	file:
ANYBUT	regexp.c	80;"	d	file:
ANYOF	regexp.c	79;"	d	file:
APF_ARP_RD_IP	arp.c	106;"	d	file:
APF_ARP_RD_SP	arp.c	107;"	d	file:
APF_ARP_WR_IP	arp.c	108;"	d	file:
APF_ARP_WR_SP	arp.c	109;"	d	file:
APF_CLIENTREQ	arp.c	112;"	d	file:
APF_CLIENTWRITE	arp.c	114;"	d	file:
APF_EMPTY	arp.c	103;"	d	file:
APF_INADDR_SET	arp.c	110;"	d	file:
APF_MORE2WRITE	arp.c	111;"	d	file:
APF_RARPREQ	arp.c	113;"	d	file:
APF_RARP_RD_IP	arp.c	104;"	d	file:
APF_RARP_RD_SP	arp.c	105;"	d	file:
APS_ARPMAIN	arp.c	124;"	d	file:
APS_ARPPROTO	arp.c	123;"	d	file:
APS_ARPSTART	arp.c	122;"	d	file:
APS_EMPTY	arp.c	116;"	d	file:
APS_ERROR	arp.c	125;"	d	file:
APS_GETADDR	arp.c	118;"	d	file:
APS_RARPPROTO	arp.c	119;"	d	file:
APS_RARPWAIT	arp.c	121;"	d	file:
APS_RARPWRITE	arp.c	120;"	d	file:
APS_STATMASK	arp.c	117;"	d	file:
APS_SUSPEND	arp.c	126;"	d	file:
ARGS	inet.h	81;"	d
ARGS	inet.h	83;"	d
ARP_CACHE1_NR	arp.c	19;"	d	file:
ARP_CACHE2_NR	arp.c	20;"	d	file:
ARP_CACHE3_NR	arp.c	21;"	d	file:
ARP_CACHE_NR	arp.c	22;"	d	file:
ARP_ETHERNET	arp.h	8;"	d
ARP_EXP_TIME	arp.c	31;"	d	file:
ARP_H	arp.h	6;"	d
ARP_INUSE_OFFSET	arp.c	33;"	d	file:
ARP_NOTRCH_EXP_TIME	arp.c	32;"	d	file:
ARP_PORT_NR	arp.c	18;"	d	file:
ARP_REPLY	arp.h	11;"	d
ARP_REQUEST	arp.h	10;"	d
ARP_TIMEOUT	arp.c	30;"	d	file:
ARP_TYPE1	arp.c	23;"	d	file:
ARP_TYPE2	arp.c	24;"	d	file:
ARP_TYPE3	arp.c	25;"	d	file:
ARSIZE	test17.c	26;"	d	file:
ARSIZE	test18.c	27;"	d	file:
ASSERT	malloc.c	12;"	d	file:
ASSERT	malloc.c	14;"	d	file:
ASSERT_H	assert.h	5;"	d
ASSERT_STROBE	printer.c	45;"	d	file:
ATA_IDENTIFY	at_wini.c	65;"	d	file:
ATR_MSK	curspriv.h	21;"	d
ATR_NRM	curspriv.h	22;"	d
ATT_ABT	esdi_wini.c	63;"	d	file:
ATT_CMD	esdi_wini.c	61;"	d	file:
ATT_EOI	esdi_wini.c	62;"	d	file:
ATT_REG	esdi_wini.c	43;"	d	file:
ATT_RST	esdi_wini.c	64;"	d	file:
AT_IRQ0	at_wini.c	74;"	d	file:
AT_IRQ1	at_wini.c	75;"	d	file:
AT_WINI_IRQ	const.h	66;"	d
AUDIO_DISK	mcd.c	128;"	d	file:
AUDIO_PAUSED	mcd.c	127;"	d	file:
AUDIO_PLAYING	mcd.c	126;"	d	file:
AUTO_CTRL	xt_wini.c	92;"	d	file:
AUTO_CYLS	xt_wini.c	87;"	d	file:
AUTO_ECC	xt_wini.c	91;"	d	file:
AUTO_ENABLE	xt_wini.c	84;"	d	file:
AUTO_HEADS	xt_wini.c	88;"	d	file:
AUTO_PARAM	xt_wini.c	83;"	d	file:
AUTO_RWC	xt_wini.c	89;"	d	file:
AUTO_WPC	xt_wini.c	90;"	d	file:
AVL	protect.h	126;"	d
AVL_286_TSS	protect.h	93;"	d
A_SEP	boothead.s	/^	A_SEP	    =	  0x20	! Separate I&D flag$/;"	d
Align	malloc.c	29;"	d	file:
B64	FP_types.h	/^}	B64;$/;"	t	typeref:struct:__anon17
B64	adder.h	/^typedef	struct	B64 {$/;"	s
B64	adder.h	/^}	B64;$/;"	t	typeref:struct:B64
BACK	regexp.c	84;"	d	file:
BAD_CYL	floppy.c	69;"	d	file:
BAD_SECTOR	floppy.c	65;"	d	file:
BASE_HIGH_SHIFT	protect.h	112;"	d
BASE_MIDDLE_SHIFT	protect.h	75;"	d
BASE_SECTOR	floppy.c	127;"	d	file:
BCTL_REG	esdi_wini.c	41;"	d	file:
BEEP_FREQ	console.c	50;"	d	file:
BEG_PROC_ADDR	proc.h	81;"	d
BEG_SERV_ADDR	proc.h	84;"	d
BEG_USER_ADDR	proc.h	85;"	d
BIG	protect.h	125;"	d
BIOS_ASK	bios_wini.c	42;"	d	file:
BIOS_IRQ0_VEC	const.h	50;"	d
BIOS_IRQ8_VEC	const.h	51;"	d
BIOS_READ	bios_wini.c	44;"	d	file:
BIOS_RESET	bios_wini.c	43;"	d	file:
BIOS_VECTOR	const.h	69;"	d
BIOS_WRITE	bios_wini.c	45;"	d	file:
BITCHUNK_BITS	super.c	21;"	d	file:
BITMAPSHIFT	fslib.c	18;"	d	file:
BITS_PER_BLOCK	super.c	22;"	d	file:
BLANK_COLOR	console.c	33;"	d	file:
BLANK_MEM	console.c	36;"	d	file:
BLOCKS_MINIMUM	read.c	421;"	d	file:
BLOCK_SIZE	test13.c	15;"	d	file:
BOL	regexp.c	76;"	d	file:
BOOT	installboot.c	/^enum howto { FS, BOOT };$/;"	e	enum:howto	file:
BOOTBLOCK	installboot.c	26;"	d	file:
BOOTOFF	bootblock.s	/^	BOOTOFF	   =	0x0030	! Offset into secondary boot above header$/;"	d
BOOTOFF	boothead.s	/^	BOOTOFF	    =	0x7C00	! 0x0000:BOOTOFF load a bootstrap here$/;"	d
BOOTPOS	boot.h	28;"	d
BOOTSEG	bootblock.s	/^	BOOTSEG    =	0x1000	! Secondary boot code segment.$/;"	d
BOOT_MAX	installboot.c	30;"	d	file:
BOTH	_sendrec.s	/^BOTH = 3$/;"	d
BOUNDS_VECTOR	protect.h	51;"	d
BRANCH	regexp.c	82;"	d	file:
BREAKPOINT_VECTOR	const.h	38;"	d
BRKSIZE	malloc.c	24;"	d	file:
BRKSIZE	malloc.c	26;"	d	file:
BST_REG	esdi_wini.c	42;"	d	file:
BSY_IDLE	floppy.c	131;"	d	file:
BSY_IO	floppy.c	132;"	d	file:
BSY_WAKEN	floppy.c	133;"	d	file:
BT545	aha_scsi.c	119;"	d	file:
BTP	ext_comp.c	435;"	d	file:
BUF512_NR	buf.c	23;"	d	file:
BUFFER	bootblock.s	/^	BUFFER	   =	0x0600	! First free memory$/;"	d
BUFFER	boothead.s	/^	BUFFER	    =	0x0600	! First free memory$/;"	d
BUFFER	extboot.s	/^	BUFFER	   =	0x0600	! First free memory$/;"	d
BUFFER	masterboot.s	/^	BUFFER	   =	0x0600	! First free memory$/;"	d
BUF_EXTRA	driver.c	36;"	d	file:
BUF_EXTRA	driver.c	38;"	d	file:
BUF_H	buf.h	6;"	d
BUF_S	buf.h	9;"	d
BUF_SIZE	mtab.c	44;"	d	file:
BUF_SIZE	putk.c	8;"	d	file:
BUF_SIZE	test20.c	30;"	d	file:
BUF_SIZE	test25.c	99;"	d	file:
BUF_SIZE	test29.c	23;"	d	file:
BUF_SIZE	test30.c	74;"	d	file:
BUF_SIZE	test31.c	67;"	d	file:
BUF_SIZE	test32.c	62;"	d	file:
BUSY	esdi_wini.c	52;"	d	file:
BUSY_286_TSS	protect.h	95;"	d
BUSY_STATUS	printer.c	58;"	d	file:
BYTES_PER_SECTOR	mcd.c	36;"	d	file:
BYTES_REVERSED	get_put.h	16;"	d
BYTE_GRAN_MAX	protect.h	113;"	d
B_NODEV	boot.c	977;"	d	file:
B_NOSIG	boot.c	978;"	d	file:
B_TIME	console.c	51;"	d	file:
CACHE_SIZE	boot.c	120;"	d	file:
CALIBRATED	floppy.c	126;"	d	file:
CALL_286_GATE	protect.h	96;"	d
CARRYBIT	FP_shift.h	12;"	d
CASCADE_IRQ	const.h	59;"	d
CASE	editline.c	/^} CASE;$/;"	t	typeref:enum:_CASE	file:
CC1	Makefile	/^CC1	= $(CC) -c$/;"	m
CCB_INCHECK	aha_scsi.c	275;"	d	file:
CCB_INIT	aha_scsi.c	269;"	d	file:
CCB_NOCHECK	aha_scsi.c	276;"	d	file:
CCB_OUTCHECK	aha_scsi.c	274;"	d	file:
CCB_SCATTER	aha_scsi.c	271;"	d	file:
CCB_SENSEOFF	aha_scsi.c	281;"	d	file:
CCB_SENSEREQ	aha_scsi.c	280;"	d	file:
CCB_TARGET	aha_scsi.c	270;"	d	file:
CD_LEFT	sb16.h	156;"	d
CD_RIGHT	sb16.h	155;"	d
CFAIL	regexp.c	138;"	d	file:
CHAR	editline.h	/^typedef unsigned char	CHAR;$/;"	t
CHARBITS	regsub.c	31;"	d	file:
CHAR_SHIFT	mblen.c	10;"	d	file:
CHAR_UNSIGNED	byte_order.h	1;"	d
CHDIR	test17.c	52;"	d	file:
CHDIR	test18.c	52;"	d	file:
CHKM_ARGS	klib386.s	/^CHKM_ARGS	=	4 + 4 + 4	! 4 + 4$/;"	d
CHMOD	test17.c	53;"	d	file:
CHMOD	test18.c	53;"	d	file:
CHR_MSK	curspriv.h	20;"	d
CLICK_OFF	bootimage.c	57;"	d	file:
CLIENT_NR	buf.c	27;"	d	file:
CLOCK_ACK_BIT	clock.c	66;"	d	file:
CLOCK_H	clock.h	6;"	d
CLOCK_IRQ	const.h	57;"	d
CLOSE	regexp.c	94;"	d	file:
CLOSE	test17.c	49;"	d	file:
CLOSE	test18.c	49;"	d	file:
CMD_DIAG	at_wini.c	63;"	d	file:
CMD_FORMAT	at_wini.c	61;"	d	file:
CMD_FUL	esdi_wini.c	54;"	d	file:
CMD_IDLE	at_wini.c	56;"	d	file:
CMD_PRG	esdi_wini.c	51;"	d	file:
CMD_READ	at_wini.c	58;"	d	file:
CMD_READVERIFY	at_wini.c	60;"	d	file:
CMD_RECALIBRATE	at_wini.c	57;"	d	file:
CMD_REG	esdi_wini.c	39;"	d	file:
CMD_SEEK	at_wini.c	62;"	d	file:
CMD_SPECIFY	at_wini.c	64;"	d	file:
CMD_WRITE	at_wini.c	59;"	d	file:
CM_ARGS	klib386.s	/^CM_ARGS	=	4 + 4 + 4 + 4 + 4	! 4 + 4 + 4 + 4 + 4$/;"	d
CM_DENSITY	klib386.s	/^CM_DENSITY	=	16$/;"	d
CM_LOG_DENSITY	klib386.s	/^CM_LOG_DENSITY	=	4$/;"	d
COLOR_BASE	console.c	29;"	d	file:
COLOR_MODE	boot.h	34;"	d
COLOR_SIZE	console.c	31;"	d	file:
COLS	cursesio.c	/^int LINES, COLS;$/;"	v
CONFORMING	protect.h	85;"	d
CONSOLE	keyboard.c	38;"	d	file:
CONST	editline.h	31;"	d
CONST	editline.h	33;"	d
CONST	rcmd.c	64;"	d	file:
CONST	rcmd.c	66;"	d	file:
CONST	res_comp.c	53;"	d	file:
CONST	res_comp.c	55;"	d	file:
CONST	res_query.c	60;"	d	file:
CONST	res_query.c	62;"	d	file:
CONS_MINOR	tty.c	66;"	d	file:
CONS_RAM_WORDS	console.c	37;"	d	file:
COPROC_ERR_VECTOR	protect.h	105;"	d
COPROC_NOT_VECTOR	protect.h	53;"	d
COPROC_SEG_VECTOR	protect.h	55;"	d
COPYFROMTO	editline.h	46;"	d
CORE_MODE	signal.c	33;"	d	file:
COUNTER_FREQ	clock.c	59;"	d	file:
COUNTHI	klib88.s	/^COUNTHI	=	14$/;"	d
COUNTLO	klib88.s	/^COUNTLO	=	12$/;"	d
CREAT	test17.c	45;"	d	file:
CREAT	test18.c	45;"	d	file:
CRLF	os9.h	6;"	d
CRLF	unix.h	6;"	d
CROSS	cursesio.c	114;"	d	file:
CR_DMA	dp8390.h	67;"	d
CR_DM_ABORT	dp8390.h	72;"	d
CR_DM_NOP	dp8390.h	68;"	d
CR_DM_RR	dp8390.h	69;"	d
CR_DM_RW	dp8390.h	70;"	d
CR_DM_SP	dp8390.h	71;"	d
CR_PS	dp8390.h	73;"	d
CR_PS_P0	dp8390.h	74;"	d
CR_PS_P1	dp8390.h	75;"	d
CR_PS_T0	dp8390.h	76;"	d
CR_SP_T1	dp8390.h	77;"	d
CR_STA	dp8390.h	65;"	d
CR_STP	dp8390.h	64;"	d
CR_TXP	dp8390.h	66;"	d
CS_INDEX	protect.h	14;"	d
CS_LDT_INDEX	protect.h	40;"	d
CS_SELECTOR	boothead.s	/^	CS_SELECTOR =	   6*8	! Kernel code$/;"	d
CS_SELECTOR	protect.h	30;"	d
CSdispatch	editline.c	/^    CSdone, CSeof, CSmove, CSdispatch, CSstay, CSsignal$/;"	e	enum:_STATUS	file:
CSdone	editline.c	/^    CSdone, CSeof, CSmove, CSdispatch, CSstay, CSsignal$/;"	e	enum:_STATUS	file:
CSeof	editline.c	/^    CSdone, CSeof, CSmove, CSdispatch, CSstay, CSsignal$/;"	e	enum:_STATUS	file:
CSmove	editline.c	/^    CSdone, CSeof, CSmove, CSdispatch, CSstay, CSsignal$/;"	e	enum:_STATUS	file:
CSsignal	editline.c	/^    CSdone, CSeof, CSmove, CSdispatch, CSstay, CSsignal$/;"	e	enum:_STATUS	file:
CSstay	editline.c	/^    CSdone, CSeof, CSmove, CSdispatch, CSstay, CSsignal$/;"	e	enum:_STATUS	file:
CTL	editline.c	16;"	d	file:
CTL_BUSY	floppy.c	51;"	d	file:
CTL_EIGHTHEADS	at_wini.c	69;"	d	file:
CTL_INTDISABLE	at_wini.c	71;"	d	file:
CTL_NOECC	at_wini.c	68;"	d	file:
CTL_NORETRY	at_wini.c	67;"	d	file:
CTL_RESET	at_wini.c	70;"	d	file:
CURSOR	console.c	47;"	d	file:
C_6845	console.c	42;"	d	file:
ChangeColor	ÏÂÔØËµÃ÷.htm	/^function ChangeColor()$/;"	f
Chdir	test22.c	16;"	d	file:
Chdir	test23.c	18;"	d	file:
Chdir	test24.c	31;"	d	file:
Chdir	test25.c	23;"	d	file:
Chdir	test26.c	32;"	d	file:
Chdir	test27.c	20;"	d	file:
Chdir	test28.c	29;"	d	file:
Chdir	test29.c	26;"	d	file:
Chdir	test30.c	26;"	d	file:
Chdir	test31.c	19;"	d	file:
Chdir	test32.c	19;"	d	file:
Chdir	test33.c	19;"	d	file:
Chdir	test34.c	31;"	d	file:
Chdir	test35.c	22;"	d	file:
Chdir	test36.c	19;"	d	file:
Chdir	test38.c	31;"	d	file:
Chdir	test39.c	27;"	d	file:
Chdir	test40.c	19;"	d	file:
Chmod	test33.c	21;"	d	file:
Chmod	test35.c	29;"	d	file:
Chown	test35.c	28;"	d	file:
CopyMess	proc.c	39;"	d	file:
CopyMess	proc.c	44;"	d	file:
Creat	test25.c	25;"	d	file:
Creat	test32.c	21;"	d	file:
Creat	test34.c	35;"	d	file:
Creat	test35.c	26;"	d	file:
DATA	console.c	45;"	d	file:
DATA_BITS_SHIFT	rs232.c	87;"	d	file:
DATA_CHANGED	break.c	23;"	d	file:
DATE_STR	asctime.c	10;"	d	file:
DBL_BIAS	FP_bias.h	15;"	d
DBL_CARRYOUT	FP_shift.h	48;"	d
DBL_EXACT	FP_shift.h	42;"	d
DBL_EXPSHIFT	FP_shift.h	31;"	d
DBL_LPACK	FP_shift.h	36;"	d
DBL_LUNPACK	FP_shift.h	45;"	d
DBL_M1LEFT	FP_shift.h	33;"	d
DBL_MASK	FP_shift.h	49;"	d
DBL_MAX	FP_bias.h	25;"	d
DBL_MIN	FP_bias.h	26;"	d
DBL_ROUNDUP	FP_shift.h	47;"	d
DBL_RPACK	FP_shift.h	35;"	d
DBL_RUNPACK	FP_shift.h	44;"	d
DBL_ZERO	FP_shift.h	40;"	d
DCR_12BYTES	dp8390.h	113;"	d
DCR_2BYTES	dp8390.h	110;"	d
DCR_4BYTES	dp8390.h	111;"	d
DCR_8BYTES	dp8390.h	112;"	d
DCR_AR	dp8390.h	108;"	d
DCR_BIGENDIAN	dp8390.h	105;"	d
DCR_BMS	dp8390.h	107;"	d
DCR_BOS	dp8390.h	103;"	d
DCR_BYTEWIDE	dp8390.h	101;"	d
DCR_FTS	dp8390.h	109;"	d
DCR_LAS	dp8390.h	106;"	d
DCR_LTLENDIAN	dp8390.h	104;"	d
DCR_WORDWIDE	dp8390.h	102;"	d
DCR_WTS	dp8390.h	100;"	d
DEAF	at_wini.c	110;"	d	file:
DEBUG	malloc.c	4;"	d	file:
DEBUG_VECTOR	const.h	36;"	d
DEFAULT	protect.h	124;"	d
DEFAULT_BITS	sb16.h	24;"	d
DEFAULT_SIGN	sb16.h	25;"	d
DEFAULT_SPEED	sb16.h	23;"	d
DEFAULT_STEREO	sb16.h	26;"	d
DEFFUN	boot.c	/^enum whatfun { NOFUN, SELECT, DEFFUN, USERFUN } menufun(environment *e)$/;"	e	enum:whatfun	file:
DEFFUN	edparams.c	/^enum whatfun { NOFUN, SELECT, DEFFUN, USERFUN } menufun(environment *e)$/;"	e	enum:whatfun	file:
DEF_BAUD	rs232.c	88;"	d	file:
DEF_BROAD	dp8390.h	271;"	d
DEF_EMPTY	dp8390.h	264;"	d
DEF_ENABLED	dp8390.h	272;"	d
DEF_MULTI	dp8390.h	270;"	d
DEF_PACK_RECV	dp8390.h	266;"	d
DEF_PACK_SEND	dp8390.h	265;"	d
DEF_PROMISC	dp8390.h	269;"	d
DEF_READING	dp8390.h	268;"	d
DEF_SEND_AVAIL	dp8390.h	267;"	d
DEF_STOPPED	dp8390.h	273;"	d
DEGREE	cursesio.c	108;"	d	file:
DEI_DEFAULT	dp8390.h	262;"	d
DEL	editline.c	15;"	d	file:
DEL_SCAN	keyboard.c	37;"	d	file:
DEM_DISABLED	dp8390.h	275;"	d
DEM_ENABLED	dp8390.h	277;"	d
DEM_SINK	dp8390.h	276;"	d
DESC_386_BIT	protect.h	119;"	d
DESC_ACCESS	protect.h	68;"	d
DESC_BASE	protect.h	66;"	d
DESC_BASE_HIGH	protect.h	109;"	d
DESC_BASE_MIDDLE	protect.h	67;"	d
DESC_GRANULARITY	protect.h	108;"	d
DESC_SIZE	protect.h	69;"	d
DESTHI	klib88.s	/^DESTHI	=	10$/;"	d
DESTLO	klib88.s	/^DESTLO	=	8$/;"	d
DEV_FD0	boot.c	883;"	d	file:
DEV_HD0	boot.c	884;"	d	file:
DEV_PER_DRIVE	drvlib.h	20;"	d
DEV_RAM	boot.c	882;"	d	file:
DEV_SD0	boot.c	885;"	d	file:
DEV_TYPE_BITS	floppy.c	113;"	d	file:
DEV_TYPE_SHIFT	floppy.c	114;"	d	file:
DE_PORT_NR	dp8390.c	65;"	d	file:
DIAMOND	cursesio.c	107;"	d	file:
DIRECTION	floppy.c	52;"	d	file:
DIRENT0	test24.c	29;"	d	file:
DIRENT0	test28.c	26;"	d	file:
DIRENTRY	os9.h	/^typedef struct direct	DIRENTRY;$/;"	t	typeref:struct:direct
DIRENTRY	unix.h	/^typedef struct direct	DIRENTRY;$/;"	t	typeref:struct:direct
DIRENTRY	unix.h	/^typedef struct dirent	DIRENTRY;$/;"	t	typeref:struct:dirent
DIR_NULL	test20.c	27;"	d	file:
DISK_CHANGED	mcd.c	125;"	d	file:
DISK_ERROR	mcd.c	129;"	d	file:
DISPOSE	editline.h	41;"	d
DIST_UNREACHABLE	ipr.c	15;"	d	file:
DIVIDE_VECTOR	const.h	35;"	d
DIVISOR	floppy.c	121;"	d	file:
DMA16_ADDR	sb16.h	52;"	d
DMA16_AUTO_PLAY	sb16.h	76;"	d
DMA16_AUTO_REC	sb16.h	77;"	d
DMA16_CLEAR	sb16.h	56;"	d
DMA16_COUNT	sb16.h	53;"	d
DMA16_MASK	sb16.h	54;"	d
DMA16_MODE	sb16.h	55;"	d
DMA16_PAGE	sb16.h	63;"	d
DMA16_PAGE	sb16.h	66;"	d
DMA16_PAGE	sb16.h	69;"	d
DMA8_ADDR	sb16.h	29;"	d
DMA8_AUTO_PLAY	sb16.h	78;"	d
DMA8_AUTO_REC	sb16.h	79;"	d
DMA8_CLEAR	sb16.h	33;"	d
DMA8_COUNT	sb16.h	30;"	d
DMA8_MASK	sb16.h	31;"	d
DMA8_MODE	sb16.h	32;"	d
DMA8_PAGE	sb16.h	40;"	d
DMA8_PAGE	sb16.h	43;"	d
DMA8_PAGE	sb16.h	46;"	d
DMA_ADDR	floppy.c	31;"	d	file:
DMA_ADDR	xt_wini.c	37;"	d	file:
DMA_BUF_SIZE	driver.h	56;"	d
DMA_CHECK	aha_scsi.c	298;"	d	file:
DMA_COUNT	floppy.c	33;"	d	file:
DMA_COUNT	xt_wini.c	39;"	d	file:
DMA_ENA	esdi_wini.c	49;"	d	file:
DMA_EXEC	esdi_wini.c	70;"	d	file:
DMA_EXTCMD	esdi_wini.c	69;"	d	file:
DMA_FLIPFLOP	floppy.c	34;"	d	file:
DMA_FLIPFLOP	xt_wini.c	40;"	d	file:
DMA_INIT	floppy.c	36;"	d	file:
DMA_INIT	xt_wini.c	42;"	d	file:
DMA_INT	xt_wini.c	52;"	d	file:
DMA_MODE	floppy.c	35;"	d	file:
DMA_MODE	xt_wini.c	41;"	d	file:
DMA_READ	floppy.c	87;"	d	file:
DMA_READ	xt_wini.c	57;"	d	file:
DMA_RESET_VAL	floppy.c	37;"	d	file:
DMA_SIZE	sb16.h	17;"	d
DMA_SIZE	sb16.h	19;"	d
DMA_TOP	floppy.c	32;"	d	file:
DMA_TOP	xt_wini.c	38;"	d	file:
DMA_WRITE	floppy.c	88;"	d	file:
DMA_WRITE	xt_wini.c	58;"	d	file:
DOMIDLINE	cursesio.c	118;"	d	file:
DOR	floppy.c	27;"	d	file:
DOS	boot.h	172;"	d
DOUBLE	FP_types.h	/^}	DOUBLE;$/;"	t	typeref:struct:__anon18
DOUBLE_FAULT_VECTOR	protect.h	54;"	d
DOWNARROW	cursesio.c	101;"	d	file:
DOWNLEFT	cursesio.c	113;"	d	file:
DOWNLINE	cursesio.c	119;"	d	file:
DOWNRIGHT	cursesio.c	110;"	d	file:
DPL	protect.h	79;"	d
DPL_SHIFT	protect.h	80;"	d
DP_BNRY	dp8390.h	13;"	d
DP_BNRY	dp8390.h	31;"	d
DP_CLDA0	dp8390.h	11;"	d
DP_CLDA1	dp8390.h	12;"	d
DP_CNTR0	dp8390.h	23;"	d
DP_CNTR1	dp8390.h	24;"	d
DP_CNTR2	dp8390.h	25;"	d
DP_CR	dp8390.h	10;"	d
DP_CR	dp8390.h	28;"	d
DP_CR	dp8390.h	46;"	d
DP_CRDA0	dp8390.h	18;"	d
DP_CRDA1	dp8390.h	19;"	d
DP_CURR	dp8390.h	53;"	d
DP_DCR	dp8390.h	42;"	d
DP_DUM1	dp8390.h	20;"	d
DP_DUM2	dp8390.h	21;"	d
DP_ETH0_INDEX	protect.h	20;"	d
DP_ETH0_SELECTOR	protect.h	36;"	d
DP_ETH1_INDEX	protect.h	21;"	d
DP_ETH1_SELECTOR	protect.h	37;"	d
DP_FIFO	dp8390.h	16;"	d
DP_IMR	dp8390.h	43;"	d
DP_ISR	dp8390.h	17;"	d
DP_ISR	dp8390.h	35;"	d
DP_MAR0	dp8390.h	54;"	d
DP_MAR1	dp8390.h	55;"	d
DP_MAR2	dp8390.h	56;"	d
DP_MAR3	dp8390.h	57;"	d
DP_MAR4	dp8390.h	58;"	d
DP_MAR5	dp8390.h	59;"	d
DP_MAR6	dp8390.h	60;"	d
DP_MAR7	dp8390.h	61;"	d
DP_NCR	dp8390.h	15;"	d
DP_PAGESIZE	dp8390.h	161;"	d
DP_PAR0	dp8390.h	47;"	d
DP_PAR1	dp8390.h	48;"	d
DP_PAR2	dp8390.h	49;"	d
DP_PAR3	dp8390.h	50;"	d
DP_PAR4	dp8390.h	51;"	d
DP_PAR5	dp8390.h	52;"	d
DP_PSTART	dp8390.h	29;"	d
DP_PSTOP	dp8390.h	30;"	d
DP_RBCR0	dp8390.h	38;"	d
DP_RBCR1	dp8390.h	39;"	d
DP_RCR	dp8390.h	40;"	d
DP_RSAR0	dp8390.h	36;"	d
DP_RSAR1	dp8390.h	37;"	d
DP_RSR	dp8390.h	22;"	d
DP_TBCR0	dp8390.h	33;"	d
DP_TBCR1	dp8390.h	34;"	d
DP_TCR	dp8390.h	41;"	d
DP_TPSR	dp8390.h	32;"	d
DP_TSR	dp8390.h	14;"	d
DSKBASE	boot.h	12;"	d
DSKBASE	bootblock.s	/^	DSKBASE    =	  0x1E	! Floppy disk parameter vector$/;"	d
DSKBASE	boothead.s	/^	DSKBASE     =	   120	! 120 = 4 * 0x1E = ptr to disk parameters$/;"	d
DSKPARSIZE	boot.h	13;"	d
DSKPARSIZE	bootblock.s	/^	DSKPARSIZE =	    11	! 11 bytes of floppy parameters$/;"	d
DSKPARSIZE	boothead.s	/^	DSKPARSIZE  =	    11	! 11 bytes of floppy parameters$/;"	d
DSP_CMD_16BITAUTO_IN	sb16.h	109;"	d
DSP_CMD_16BITAUTO_OUT	sb16.h	110;"	d
DSP_CMD_8BITAUTO_IN	sb16.h	107;"	d
DSP_CMD_8BITAUTO_OUT	sb16.h	108;"	d
DSP_CMD_DMA16CONT	sb16.h	105;"	d
DSP_CMD_DMA16HALT	sb16.h	104;"	d
DSP_CMD_DMA8CONT	sb16.h	103;"	d
DSP_CMD_DMA8HALT	sb16.h	102;"	d
DSP_CMD_IRQREQ16	sb16.h	112;"	d
DSP_CMD_IRQREQ8	sb16.h	111;"	d
DSP_CMD_SPKOFF	sb16.h	101;"	d
DSP_CMD_SPKON	sb16.h	100;"	d
DSP_COMMAND	sb16.h	86;"	d
DSP_DATA16_AVL	sb16.h	89;"	d
DSP_DATA_AVL	sb16.h	88;"	d
DSP_GET_VERSION	sb16.h	106;"	d
DSP_INPUT_RATE	sb16.h	98;"	d
DSP_MAX_FRAGMENT_SIZE	sb16.h	165;"	d
DSP_MAX_SPEED	sb16.h	163;"	d
DSP_MIN_FRAGMENT_SIZE	sb16.h	166;"	d
DSP_MIN_SPEED	sb16.h	164;"	d
DSP_MODE_MONO_S	sb16.h	117;"	d
DSP_MODE_MONO_US	sb16.h	116;"	d
DSP_MODE_STEREO_S	sb16.h	119;"	d
DSP_MODE_STEREO_US	sb16.h	118;"	d
DSP_OUTPUT_RATE	sb16.h	99;"	d
DSP_READ	sb16.h	84;"	d
DSP_RESET	sb16.h	83;"	d
DSP_STATUS	sb16.h	87;"	d
DSP_WRITE	sb16.h	85;"	d
DS_286_INDEX	protect.h	17;"	d
DS_286_OFFSET	klib88.s	/^#define DS_286_OFFSET	DS_286_INDEX*DESC_SIZE$/;"	d
DS_286_SELECTOR	protect.h	33;"	d
DS_EOF	aha_scsi.c	364;"	d	file:
DS_ERR	aha_scsi.c	363;"	d	file:
DS_INDEX	protect.h	11;"	d
DS_LDT_INDEX	protect.h	41;"	d
DS_OK	aha_scsi.c	362;"	d	file:
DS_SELECTOR	boothead.s	/^	DS_SELECTOR =	   3*8	! Kernel data selector$/;"	d
DS_SELECTOR	protect.h	26;"	d
DT	table.c	101;"	d	file:
DTL	floppy.c	94;"	d	file:
DUMPED	signal.c	34;"	d	file:
DUMP_SIZE	signal.c	35;"	d	file:
DUP	test17.c	59;"	d	file:
DUP	test18.c	59;"	d	file:
DiskInfo	mcd.c	/^PRIVATE struct cd_disk_info DiskInfo;   \/* Contains toc header *\/  $/;"	v	typeref:struct:cd_disk_info
DmaBuffer	sb16_dsp.c	/^PRIVATE char DmaBuffer[(long)2 * DMA_SIZE];$/;"	v
DmaBusy	sb16_dsp.c	/^PRIVATE int DmaBusy = 0;$/;"	v
DmaDone	sb16_dsp.c	/^PRIVATE int DmaDone = 1;$/;"	v
DmaMode	sb16_dsp.c	/^PRIVATE int DmaMode = 0;$/;"	v
DmaPhys	sb16_dsp.c	/^PRIVATE phys_bytes DmaPhys;$/;"	v
DmaPtr	sb16_dsp.c	/^PRIVATE char *DmaPtr;$/;"	v
DspAvail	sb16_dsp.c	/^PRIVATE int DspAvail = 0;$/;"	v
DspBits	sb16_dsp.c	/^PRIVATE unsigned int DspBits = DEFAULT_BITS;$/;"	v
DspBusy	sb16_dsp.c	/^PRIVATE int DspBusy = 0;$/;"	v
DspFragmentSize	sb16_dsp.c	/^PRIVATE unsigned int DspFragmentSize = DSP_MAX_FRAGMENT_SIZE;$/;"	v
DspSign	sb16_dsp.c	/^PRIVATE unsigned int DspSign = DEFAULT_SIGN;$/;"	v
DspSpeed	sb16_dsp.c	/^PRIVATE unsigned int DspSpeed = DEFAULT_SPEED; $/;"	v
DspStereo	sb16_dsp.c	/^PRIVATE unsigned int DspStereo = DEFAULT_STEREO;$/;"	v
DspTasknr	sb16_dsp.c	/^PRIVATE int DspTasknr = ANY;$/;"	v
DspVersion	sb16_dsp.c	/^PRIVATE int DspVersion[2]; $/;"	v
EARRAY	em_abs.h	12;"	d
EBADGTO	em_abs.h	35;"	d
EBADLAE	em_abs.h	32;"	d
EBADLIN	em_abs.h	34;"	d
EBADMON	em_abs.h	33;"	d
EBADPC	em_abs.h	31;"	d
EBADPTR	em_abs.h	30;"	d
ECASE	csa2.s	/^ECASE = 20$/;"	d
ECASE	csa4.s	/^ECASE = 20$/;"	d
ECASE	csb2.s	/^ECASE = 20$/;"	d
ECASE	csb4.s	/^ECASE = 20$/;"	d
ECASE	em_abs.h	28;"	d
ECASE	em_head.s	/^ECASE		= 20$/;"	d
ECONV	FP_trap.h	21;"	d
ECONV	em_abs.h	22;"	d
EFDIVZ	FP_trap.h	18;"	d
EFDIVZ	em_abs.h	19;"	d
EFF_BUSY	eth.c	41;"	d	file:
EFF_EMPTY	eth.c	39;"	d	file:
EFF_FLAGS	eth.c	38;"	d	file:
EFF_INUSE	eth.c	40;"	d	file:
EFF_OPTSET	eth.c	44;"	d	file:
EFF_READ_IP	eth.c	42;"	d	file:
EFF_WRITE_IP	eth.c	43;"	d	file:
EFOVFL	FP_trap.h	15;"	d
EFOVFL	em_abs.h	16;"	d
EFUND	FP_trap.h	20;"	d
EFUND	em_abs.h	21;"	d
EFUNFL	FP_trap.h	16;"	d
EFUNFL	em_abs.h	17;"	d
EGA	console.c	43;"	d	file:
EGA_SIZE	console.c	32;"	d	file:
EHEAP	em_abs.h	25;"	d
EHEAP	em_head.s	/^EHEAP		= 17$/;"	d
EHEAP	strhp.s	/^EHEAP = 17$/;"	d
EIDIVZ	FP_trap.h	17;"	d
EIDIVZ	em_abs.h	18;"	d
EIDIVZ	em_head.s	/^EIDIVZ		= 6$/;"	d
EILLINS	cii.s	/^EILLINS = 18$/;"	d
EILLINS	cuu.s	/^EILLINS = 18$/;"	d
EILLINS	em_abs.h	26;"	d
EILLINS	em_head.s	/^EILLINS		= 18$/;"	d
EILLINS	unknown.s	/^EILLINS = 18$/;"	d
EIOVFL	FP_trap.h	14;"	d
EIOVFL	em_abs.h	15;"	d
EIUND	FP_trap.h	19;"	d
EIUND	em_abs.h	20;"	d
EMEMFLT	em_abs.h	29;"	d
EMPTYSQUARE	cursesio.c	105;"	d	file:
ENABLE	const.h	85;"	d
ENABLE_ARP	config.h	4;"	d
ENABLE_INT	floppy.c	57;"	d	file:
ENABLE_IP	config.h	5;"	d
ENABLE_TCP	config.h	6;"	d
ENABLE_UDP	config.h	7;"	d
END	regexp.c	75;"	d	file:
END_FILE	test17.c	32;"	d	file:
END_PROC_ADDR	proc.h	82;"	d
END_TASK_ADDR	proc.h	83;"	d
END_TTY	tty.c	77;"	d	file:
ENTRY_INC	putenv.c	10;"	d	file:
EODDZ	em_abs.h	27;"	d
EODDZ	em_head.s	/^EODDZ		= 19$/;"	d
EOL	regexp.c	77;"	d	file:
EPF_EMPTY	eth_int.h	19;"	d
EPF_ENABLED	eth_int.h	20;"	d
EPF_MORE2WRITE	eth_int.h	23;"	d
EPF_READ_IP	eth_int.h	24;"	d
EPF_READ_SP	eth_int.h	25;"	d
EPF_WRITE_IP	eth_int.h	21;"	d
EPF_WRITE_SP	eth_int.h	22;"	d
EPL_790_B	wdeth.h	37;"	d
EPL_790_GCR	wdeth.h	38;"	d
EPL_790_HWR	wdeth.h	33;"	d
EPL_790_ICR	wdeth.h	35;"	d
EPL_CHKSUM	wdeth.h	27;"	d
EPL_DP8390	wdeth.h	28;"	d
EPL_EA0	wdeth.h	20;"	d
EPL_EA1	wdeth.h	21;"	d
EPL_EA2	wdeth.h	22;"	d
EPL_EA3	wdeth.h	23;"	d
EPL_EA4	wdeth.h	24;"	d
EPL_EA5	wdeth.h	25;"	d
EPL_GP2	wdeth.h	36;"	d
EPL_ICR	wdeth.h	31;"	d
EPL_IRR	wdeth.h	32;"	d
EPL_LAAR	wdeth.h	34;"	d
EPL_MSR	wdeth.h	30;"	d
EPL_REG0	wdeth.h	12;"	d
EPL_REG1	wdeth.h	13;"	d
EPL_REG2	wdeth.h	14;"	d
EPL_REG3	wdeth.h	15;"	d
EPL_REG4	wdeth.h	16;"	d
EPL_REG5	wdeth.h	17;"	d
EPL_REG6	wdeth.h	18;"	d
EPL_REG7	wdeth.h	19;"	d
EPL_TLB	wdeth.h	26;"	d
EPOCH_YR	loc_time.h	7;"	d
EPS_BROAD	eth_int.h	29;"	d
EPS_EMPTY	eth_int.h	27;"	d
EPS_LOC	eth_int.h	28;"	d
EPS_MULTI	eth_int.h	30;"	d
EPS_PROMISC	eth_int.h	31;"	d
EP_OFF	const.h	135;"	d
EP_ON	const.h	136;"	d
EP_SET	const.h	137;"	d
EP_UNSET	const.h	134;"	d
ERANGE	em_abs.h	13;"	d
ERANGE	em_head.s	/^ERANGE		= 1$/;"	d
ERANGE	rck.s	/^ERANGE = 1$/;"	d
ERR	at_wini.c	90;"	d	file:
ERR	bios_wini.c	32;"	d	file:
ERR	esdi_wini.c	75;"	d	file:
ERR	getopt.c	10;"	d	file:
ERR	test15.c	63;"	d	file:
ERR	test15.c	66;"	d	file:
ERR	xt_wini.c	71;"	d	file:
ERRCT_DISABLE	init.c	46;"	d	file:
ERROR_AC	at_wini.c	50;"	d	file:
ERROR_BB	at_wini.c	47;"	d	file:
ERROR_DM	at_wini.c	52;"	d	file:
ERROR_ECC	at_wini.c	48;"	d	file:
ERROR_ID	at_wini.c	49;"	d	file:
ERROR_TK	at_wini.c	51;"	d	file:
ERR_BAD_SECTOR	at_wini.c	91;"	d	file:
ERR_BAD_SECTOR	esdi_wini.c	76;"	d	file:
ERR_BAD_SECTOR	xt_wini.c	72;"	d	file:
ERR_CODE	test20.c	31;"	d	file:
ERR_DRIVE	floppy.c	105;"	d	file:
ERR_READ_ID	floppy.c	103;"	d	file:
ERR_RECALIBRATE	floppy.c	104;"	d	file:
ERR_SEEK	floppy.c	100;"	d	file:
ERR_STATUS	floppy.c	102;"	d	file:
ERR_TIMEOUT	floppy.c	107;"	d	file:
ERR_TRANSFER	floppy.c	101;"	d	file:
ERR_WR_PROTECT	floppy.c	106;"	d	file:
ESC	boot.h	15;"	d
ESC	edparams.c	28;"	d	file:
ESC	tty.h	7;"	d
ESCAPED	tty.h	75;"	d
ESC_SCAN	keyboard.c	34;"	d	file:
ESET	em_abs.h	14;"	d
ESET	em_head.s	/^ESET		= 2$/;"	d
ESET	set.s	/^ESET = 2$/;"	d
ESTACK	em_abs.h	24;"	d
ES_286_INDEX	protect.h	18;"	d
ES_286_OFFSET	klib88.s	/^#define ES_286_OFFSET	ES_286_INDEX*DESC_SIZE$/;"	d
ES_286_SELECTOR	protect.h	34;"	d
ES_INDEX	protect.h	12;"	d
ES_SELECTOR	boothead.s	/^	ES_SELECTOR =	   4*8	! Flat 4 Gb$/;"	d
ES_SELECTOR	protect.h	27;"	d
ETH0	eth.h	11;"	d
ETHERSTRLEN	ether.h	125;"	d
ETHERSTRLEN	ethere2a.c	13;"	d	file:
ETHER_ALLTYPES	ether.h	148;"	d
ETHER_ALLTYPES	ether.h	150;"	d
ETHER_DST	ether.h	135;"	d
ETHER_IRQ	const.h	60;"	d
ETHER_MAX	ether.h	140;"	d
ETHER_MAXTYPE	ether.h	143;"	d
ETHER_MCAST	ether.h	145;"	d
ETHER_MIN	ether.h	139;"	d
ETHER_MINTYPE	ether.h	142;"	d
ETHER_PKT	ether.h	138;"	d
ETHER_SRC	ether.h	136;"	d
ETHER_TYPE	ether.h	137;"	d
ETH_DEV	sr.h	10;"	d
ETH_DEV0	sr.h	13;"	d
ETH_FD_NR	eth.c	20;"	d	file:
ETH_H	eth.h	6;"	d
ETH_INT_H	eth_int.h	6;"	d
ETH_PORT_NR	eth_int.h	8;"	d
ETH_PRI_EXP_FDBUFS	buf.h	15;"	d
ETH_PRI_FDBUFS	buf.h	16;"	d
ETH_PRI_PORTBUFS	buf.h	14;"	d
EXACTLY	regexp.c	85;"	d	file:
EXCLUDE	test25.c	82;"	d	file:
EXCLUDE	test33.c	412;"	d	file:
EXECUTABLE	protect.h	84;"	d
EXPAND_DOWN	protect.h	86;"	d
EXPIRE_TIME	eth.c	21;"	d	file:
EXP_STORE	FP_shift.h	14;"	d
EXTEND	FP_types.h	/^} EXTEND;$/;"	t	typeref:struct:__anon19
EXTEND	ext_fmt.h	/^struct EXTEND {$/;"	s
EXTERN	boot.c	32;"	d	file:
EXTERN	boot.c	33;"	d	file:
EXTERN	boot.h	39;"	d
EXTERN	glo.h	5;"	d
EXTERN	glo.h	6;"	d
EXTERN	inet.h	56;"	d
EXT_BIAS	FP_bias.h	16;"	d
EXT_MAX	FP_bias.h	27;"	d
EXT_MIN	FP_bias.h	28;"	d
EXT_PART	extboot.s	/^	EXT_PART   =	     5$/;"	d
E_790_GCR_IR0	wdeth.h	82;"	d
E_790_GCR_IR1	wdeth.h	83;"	d
E_790_GCR_IR2	wdeth.h	84;"	d
E_790_HWR_SWH	wdeth.h	76;"	d
E_790_ICR_EIL	wdeth.h	79;"	d
E_DEV	boot.h	109;"	d
E_DEV	edparams.c	92;"	d	file:
E_FUNCTION	boot.h	115;"	d
E_FUNCTION	edparams.c	97;"	d	file:
E_ICR_16BIT	wdeth.h	46;"	d
E_ICR_IR2	wdeth.h	47;"	d
E_ICR_MEMBIT	wdeth.h	48;"	d
E_IRR_IEN	wdeth.h	53;"	d
E_IRR_IR0	wdeth.h	51;"	d
E_IRR_IR1	wdeth.h	52;"	d
E_LAAR_A19	wdeth.h	56;"	d
E_LAAR_A20	wdeth.h	57;"	d
E_LAAR_A21	wdeth.h	58;"	d
E_LAAR_A22	wdeth.h	59;"	d
E_LAAR_A23	wdeth.h	60;"	d
E_LAAR_LAN16E	wdeth.h	62;"	d
E_LAAR_MEM16E	wdeth.h	63;"	d
E_LAAR_SOFTINT	wdeth.h	61;"	d
E_MSR_MEMADDR	wdeth.h	41;"	d
E_MSR_MENABLE	wdeth.h	42;"	d
E_MSR_RESET	wdeth.h	43;"	d
E_RESERVED	boot.h	110;"	d
E_RESERVED	edparams.c	93;"	d	file:
E_SPECIAL	boot.h	108;"	d
E_SPECIAL	edparams.c	91;"	d	file:
E_STICKY	boot.h	111;"	d
E_STICKY	edparams.c	94;"	d	file:
E_TLB_E	wdeth.h	67;"	d
E_TLB_EB	wdeth.h	66;"	d
E_TLB_RAM	wdeth.h	73;"	d
E_TLB_REV	wdeth.h	71;"	d
E_TLB_SMC8216C	wdeth.h	69;"	d
E_TLB_SMCE	wdeth.h	68;"	d
E_TLB_SOFT	wdeth.h	72;"	d
E_VAR	boot.h	114;"	d
E_VAR	edparams.c	96;"	d	file:
End	editline.c	/^STATIC int		End;$/;"	v
FAIL	test17.c	35;"	d	file:
FAIL	test18.c	35;"	d	file:
FALSE	adder.c	19;"	d	file:
FDC_DATA	floppy.c	29;"	d	file:
FDC_FORMAT	floppy.c	84;"	d	file:
FDC_RATE	floppy.c	30;"	d	file:
FDC_READ	floppy.c	78;"	d	file:
FDC_READ_ID	floppy.c	83;"	d	file:
FDC_RECALIBRATE	floppy.c	81;"	d	file:
FDC_SEEK	floppy.c	77;"	d	file:
FDC_SENSE	floppy.c	80;"	d	file:
FDC_SPECIFY	floppy.c	82;"	d	file:
FDC_STATUS	floppy.c	28;"	d	file:
FDC_WRITE	floppy.c	79;"	d	file:
FD_CLR	res_send.c	104;"	d	file:
FD_ISSET	res_send.c	105;"	d	file:
FD_MASK	read.c	24;"	d	file:
FD_NR	sr.c	42;"	d	file:
FD_SET	res_send.c	103;"	d	file:
FD_SETSIZE	res_send.c	102;"	d	file:
FD_ZERO	res_send.c	106;"	d	file:
FF	test17.c	22;"	d	file:
FF	test18.c	23;"	d	file:
FILN	em_abs.h	10;"	d
FILN_AD	em_abs.h	7;"	d
FILP_CLOSED	file.h	13;"	d
FIRSTDAYOF	loc_time.h	12;"	d
FIRSTSUNDAY	loc_time.h	11;"	d
FIRST_LDT_INDEX	protect.h	22;"	d
FIRST_TTY	tty.c	76;"	d	file:
FLAGS_OFF	bootimage.c	58;"	d	file:
FLAT_DS_SELECTOR	protect.h	28;"	d
FLOPPY_IRQ	const.h	64;"	d
FL_ALT	loc_incl.h	31;"	d
FL_LJUST	loc_incl.h	28;"	d
FL_LONG	loc_incl.h	34;"	d
FL_LONGDOUBLE	loc_incl.h	35;"	d
FL_MSB_AT_LOW_ADDRESS	byte_order.h	4;"	d
FL_MSL_AT_LOW_ADDRESS	byte_order.h	6;"	d
FL_MSW_AT_LOW_ADDRESS	byte_order.h	5;"	d
FL_NOASSIGN	loc_incl.h	39;"	d
FL_NOMORE	loc_incl.h	40;"	d
FL_PRECSPEC	loc_incl.h	37;"	d
FL_SHORT	loc_incl.h	33;"	d
FL_SIGN	loc_incl.h	29;"	d
FL_SIGNEDCONV	loc_incl.h	38;"	d
FL_SPACE	loc_incl.h	30;"	d
FL_WIDTHSPEC	loc_incl.h	36;"	d
FL_ZEROFILL	loc_incl.h	32;"	d
FM_LEFT	sb16.h	160;"	d
FM_RIGHT	sb16.h	159;"	d
FORMAT_DEV_BIT	floppy.c	115;"	d	file:
FORWARD	inet.h	58;"	d
FORWARD	os9.h	7;"	d
FORWARD	unix.h	7;"	d
FREEPOS	boot.h	22;"	d
FS	bootimage.c	43;"	d	file:
FS	installboot.c	/^enum howto { FS, BOOT };$/;"	e	enum:howto	file:
FSTAT	test17.c	58;"	d	file:
FSTAT	test18.c	58;"	d	file:
FSTRUCOPY	const.h	116;"	d
FULLSQUARE	cursesio.c	103;"	d	file:
FindMatches	complete.c	/^FindMatches(dir, file, avp)$/;"	f
Fstat	test37.c	18;"	d	file:
Function	editline.c	/^    STATUS	(*Function)();$/;"	m	struct:_KEYMAP	file:
GA_FONT_SIZE	console.c	59;"	d	file:
GA_GRAPHICS_DATA	console.c	57;"	d	file:
GA_GRAPHICS_INDEX	console.c	56;"	d	file:
GA_SEQUENCER_DATA	console.c	55;"	d	file:
GA_SEQUENCER_INDEX	console.c	54;"	d	file:
GA_VIDEO_ADDRESS	console.c	58;"	d	file:
GDT_INDEX	protect.h	9;"	d
GDT_SELECTOR	protect.h	24;"	d
GDT_SIZE	protect.h	4;"	d
GRANULAR	protect.h	123;"	d
GRANULARITY_SHIFT	protect.h	114;"	d
GREYSQUARE	cursesio.c	104;"	d	file:
GROUP	getgrent.c	/^static char GROUP[]= "\/etc\/group";	\/* The group file. *\/$/;"	v	file:
GROUP	test17.c	24;"	d	file:
GROUP	test18.c	25;"	d	file:
GROUP_ID	test17.c	21;"	d	file:
GROUP_ID	test18.c	22;"	d	file:
H	editline.c	/^STATIC HISTORY		H;$/;"	v
HANGING	mproc.h	47;"	d
HASWIDTH	regexp.c	145;"	d	file:
HCHIGH_MASK	klib88.s	/^#define HCHIGH_MASK	0x0F	\/* h\/w click mask for low byte of hi word *\/$/;"	d
HCLICK_SHIFT	const.h	24;"	d
HCLICK_SIZE	const.h	25;"	d
HCLOW_MASK	klib88.s	/^#define HCLOW_MASK	0xF0	\/* h\/w click mask for low byte of low word *\/$/;"	d
HC_SIZE	floppy.c	91;"	d	file:
HD_CODE	bios_wini.c	46;"	d	file:
HEADERPOS	boot.h	17;"	d
HISTORY	editline.c	/^} HISTORY;$/;"	t	typeref:struct:_HISTORY	file:
HIST_SIZE	editline.c	23;"	d	file:
HOME_SCAN	keyboard.c	36;"	d	file:
HOSTNAME_FILE	gethostname.c	10;"	d	file:
HOUR	misc.c	100;"	d	file:
HST_TIMEOUT	aha_scsi.c	287;"	d	file:
ICMP_DEF_TTL	icmp.h	9;"	d
ICMP_H	icmp.h	6;"	d
ICMP_LIB_H	icmp_lib.h	8;"	d
ICMP_MAX_DATAGRAM	icmp.h	8;"	d
ICMP_PORT_NR	icmp.c	43;"	d	file:
ICMP_PRI_QUEUE	buf.h	18;"	d
ICPF_EMPTY	icmp.c	31;"	d	file:
ICPF_READ_IP	icmp.c	33;"	d	file:
ICPF_READ_SP	icmp.c	34;"	d	file:
ICPF_SUSPEND	icmp.c	32;"	d	file:
ICPF_WRITE_IP	icmp.c	35;"	d	file:
ICPF_WRITE_SP	icmp.c	36;"	d	file:
ICPS_BEGIN	icmp.c	38;"	d	file:
ICPS_ERROR	icmp.c	41;"	d	file:
ICPS_IPOPT	icmp.c	39;"	d	file:
ICPS_MAIN	icmp.c	40;"	d	file:
ICW1_AT	i8259.c	9;"	d	file:
ICW1_PC	i8259.c	10;"	d	file:
ICW1_PS	i8259.c	11;"	d	file:
ICW4_AT	i8259.c	12;"	d	file:
ICW4_PC	i8259.c	13;"	d	file:
IDLE	asynchio.c	25;"	d	file:
IDT_INDEX	protect.h	10;"	d
IDT_SELECTOR	protect.h	25;"	d
IDT_SIZE	protect.h	5;"	d
IEF_ARP_COMPL	ip_int.h	67;"	d
IEF_ARP_IP	ip_int.h	65;"	d
IEF_ARP_MASK	ip_int.h	64;"	d
IEF_ARP_SP	ip_int.h	66;"	d
IEF_EMPTY	ip_int.h	58;"	d
IEF_READ_IP	ip_int.h	62;"	d
IEF_READ_SP	ip_int.h	63;"	d
IEF_SUSPEND	ip_int.h	61;"	d
IEF_WRITE_IP	ip_int.h	59;"	d
IEF_WRITE_SP	ip_int.h	60;"	d
IES_EMPTY	ip_int.h	52;"	d
IES_ERROR	ip_int.h	56;"	d
IES_GETIPADDR	ip_int.h	54;"	d
IES_MAIN	ip_int.h	55;"	d
IES_SETPROTO	ip_int.h	53;"	d
IE_LINE_STATUS_CHANGE	rs232.c	35;"	d	file:
IE_MODEM_STATUS_CHANGE	rs232.c	36;"	d	file:
IE_RECEIVER_READY	rs232.c	33;"	d	file:
IE_TRANSMITTER_READY	rs232.c	34;"	d	file:
IFF_BUSY	ip_int.h	104;"	d
IFF_DLL_WR_IP	ip_int.h	108;"	d
IFF_EMPTY	ip_int.h	101;"	d
IFF_GIPCONF_IP	ip_int.h	111;"	d
IFF_INUSE	ip_int.h	102;"	d
IFF_NETBROAD_IP	ip_int.h	110;"	d
IFF_OPTSET	ip_int.h	103;"	d
IFF_READ_IP	ip_int.h	105;"	d
IFF_ROUTED	ip_int.h	109;"	d
IFF_WRITE_IP	ip_int.h	107;"	d
IFF_WRITE_MASK	ip_int.h	106;"	d
IF_MASK	system.c	112;"	d	file:
IMAP	super.h	49;"	d
IMR_CNTE	dp8390.h	96;"	d
IMR_OVWE	dp8390.h	95;"	d
IMR_PRXE	dp8390.h	91;"	d
IMR_PTXE	dp8390.h	92;"	d
IMR_RDCE	dp8390.h	97;"	d
IMR_RXEE	dp8390.h	93;"	d
IMR_TXEE	dp8390.h	94;"	d
IM_NAME_MAX	image.h	4;"	d
INDEX	console.c	44;"	d	file:
INET_IP_H	ip.h	6;"	d
INET_IP_INT_H	ip_int.h	6;"	d
INET__MQ_H	mq.h	8;"	d
INET__NW_TASK_H	inet.h	8;"	d
INET__OSDEP_ETH_H	osdep_eth.h	8;"	d
INFO_UPTODATE	mcd.c	124;"	d	file:
INITIALIZED	at_wini.c	109;"	d	file:
INIT_ASSERT	assert.h	20;"	d
INIT_ASSERT	assert.h	9;"	d
INIT_PANIC	inet.h	60;"	d
INIT_PRINTER	printer.c	48;"	d	file:
INIT_PSW	const.h	7;"	d
INIT_SP	const.h	22;"	d
INIT_TASK_PSW	const.h	8;"	d
INPROGRESS	asynchio.c	26;"	d	file:
INT	xt_wini.c	53;"	d	file:
INT2_CTL	const.h	81;"	d
INT2_CTLMASK	const.h	82;"	d
INTR_PRIVILEGE	protect.h	44;"	d
INT_286_GATE	protect.h	98;"	d
INT_CTL	const.h	79;"	d
INT_CTLMASK	const.h	80;"	d
INT_GATE_TYPE	protect.c	11;"	d	file:
INT_GATE_TYPE	protect.c	14;"	d	file:
INT_PND	esdi_wini.c	50;"	d	file:
INT_REG	esdi_wini.c	44;"	d	file:
INT_SET	esdi_wini.c	56;"	d	file:
INVAL_OP_VECTOR	protect.h	52;"	d
INVAL_TSS_VECTOR	protect.h	56;"	d
IN_CHAR	tty.h	80;"	d
IN_EOF	tty.h	84;"	d
IN_EOT	tty.h	83;"	d
IN_ESC	tty.h	85;"	d
IN_LEN	tty.h	81;"	d
IN_LSHIFT	tty.h	82;"	d
IN_USE	mproc.h	45;"	d
IOCPARM_MASK	inet.h	48;"	d
IOCTYPE_MASK	inet.h	47;"	d
IOCTYPE_MASK	inet.h	50;"	d
IOPL_MASK	system.c	113;"	d	file:
IOVEC_NR	dp8390.h	189;"	d
IOVEC_NR	osdep_eth.h	10;"	d
IO_H	io.h	8;"	d
IP0	ip.h	8;"	d
IPDL_ETH	ip_int.h	73;"	d
IPF_EMPTY	ip_int.h	69;"	d
IPF_IPADDRSET	ip_int.h	70;"	d
IPF_NETMASKSET	ip_int.h	71;"	d
IPR_GW_DOWN_TIMEOUT	ipr.h	30;"	d
IPR_H	ipr.h	6;"	d
IPR_MAX_FIXED_ROUTES	ipr.h	25;"	d
IPR_REDIRECT_TIMEOUT	ipr.h	29;"	d
IPR_TTL_TIMEOUT	ipr.h	28;"	d
IPR_UNRCH_TIMEOUT	ipr.h	27;"	d
IP_ASS_NR	ip_int.h	21;"	d
IP_DEV	sr.h	11;"	d
IP_DEV0	sr.h	14;"	d
IP_FD_NR	ip_int.h	19;"	d
IP_PORT_NR	ip_int.h	20;"	d
IP_ROUTER	ip_int.h	25;"	d
IP_SUN_BROADCAST	ip_int.h	23;"	d
IRQ0_VECTOR	const.h	52;"	d
IRQ8_VECTOR	const.h	53;"	d
ISCTL	editline.c	17;"	d	file:
ISEEK	inode.h	45;"	d
ISMETA	editline.c	20;"	d	file:
ISMULT	regexp.c	140;"	d	file:
ISR_CNT	dp8390.h	86;"	d
ISR_MASK	dp8390.h	80;"	d
ISR_OVW	dp8390.h	85;"	d
ISR_PRX	dp8390.h	81;"	d
ISR_PTX	dp8390.h	82;"	d
ISR_RDC	dp8390.h	87;"	d
ISR_RST	dp8390.h	88;"	d
ISR_RXE	dp8390.h	83;"	d
ISR_TXE	dp8390.h	84;"	d
ISS_INC_FREQ	tcp.h	8;"	d
IS_CLOEXEC	test38.c	34;"	d	file:
IS_LINE_STATUS_CHANGE	rs232.c	42;"	d	file:
IS_MODEM_STATUS_CHANGE	rs232.c	39;"	d	file:
IS_RECEIVER_READY	rs232.c	41;"	d	file:
IS_TRANSMITTER_READY	rs232.c	40;"	d	file:
ITEMS	test7.c	23;"	d	file:
ITERATIONS	test1.c	13;"	d	file:
ITERATIONS	test11.c	13;"	d	file:
ITERATIONS	test2.c	13;"	d	file:
ITERATIONS	test20.c	28;"	d	file:
ITERATIONS	test21.c	18;"	d	file:
ITERATIONS	test22.c	13;"	d	file:
ITERATIONS	test23.c	15;"	d	file:
ITERATIONS	test24.c	27;"	d	file:
ITERATIONS	test25.c	20;"	d	file:
ITERATIONS	test26.c	29;"	d	file:
ITERATIONS	test27.c	17;"	d	file:
ITERATIONS	test28.c	24;"	d	file:
ITERATIONS	test29.c	22;"	d	file:
ITERATIONS	test3.c	14;"	d	file:
ITERATIONS	test30.c	23;"	d	file:
ITERATIONS	test31.c	16;"	d	file:
ITERATIONS	test32.c	16;"	d	file:
ITERATIONS	test33.c	16;"	d	file:
ITERATIONS	test34.c	23;"	d	file:
ITERATIONS	test35.c	18;"	d	file:
ITERATIONS	test36.c	16;"	d	file:
ITERATIONS	test37.c	16;"	d	file:
ITERATIONS	test38.c	28;"	d	file:
ITERATIONS	test39.c	24;"	d	file:
ITERATIONS	test40.c	16;"	d	file:
ITERATIONS	test5.c	12;"	d	file:
ITERATIONS	test7.c	21;"	d	file:
ITERATIONS	test8.c	16;"	d	file:
I_MOUNT	inode.h	43;"	d
I_PIPE	inode.h	41;"	d
I_can_chown	test34.c	/^int I_can_chown;$/;"	v
I_can_chown	test35.c	/^int I_can_chown;$/;"	v
Input	editline.c	/^STATIC CONST CHAR	*Input = NIL;$/;"	v
JMP	installboot.c	31;"	d	file:
JMPOFFE	installboot.c	33;"	d	file:
JMPOFFM	installboot.c	32;"	d	file:
JMP_OPCODE	klib88.s	/^#define JMP_OPCODE	0xE9	\/* opcode used for patching *\/$/;"	d
KBIT	keyboard.c	31;"	d	file:
KB_ACK	keyboard.c	26;"	d	file:
KB_BUSY	keyboard.c	27;"	d	file:
KB_COMMAND	keyboard.c	21;"	d	file:
KB_GATE_A20	keyboard.c	22;"	d	file:
KB_IN_BYTES	keyboard.c	43;"	d	file:
KB_PULSE_OUTPUT	keyboard.c	23;"	d	file:
KB_RESET	keyboard.c	24;"	d	file:
KB_STATUS	keyboard.c	25;"	d	file:
KERNEL	bootimage.c	42;"	d	file:
KERNEL_D_MAGIC	bootimage.c	59;"	d	file:
KEYBD	keyboard.c	18;"	d	file:
KEYBOARD_IRQ	const.h	58;"	d
KEYMAP	editline.c	/^} KEYMAP;$/;"	t	typeref:struct:_KEYMAP	file:
KMEM_PATH	ps.c	116;"	d	file:
K_CHMEM	bootimage.c	33;"	d	file:
K_CLAIM	bootimage.c	32;"	d	file:
K_HDR	bootimage.c	35;"	d	file:
K_HIGH	bootimage.c	34;"	d	file:
K_I386	boothead.s	/^	K_I386	    =	0x0001	! Call Minix in 386 mode$/;"	d
K_I386	bootimage.c	31;"	d	file:
K_RET	boothead.s	/^	K_RET	    =	0x0020	! Returns to the monitor on reboot$/;"	d
K_RET	bootimage.c	36;"	d	file:
K_STACK_BYTES	const.h	101;"	d
K_STACK_BYTES	const.h	5;"	d
Key	editline.c	/^    CHAR	Key;$/;"	m	struct:_KEYMAP	file:
L	test7.c	28;"	d	file:
LAST_FEW	forkexit.c	24;"	d	file:
LATCH_COUNT	clock.c	60;"	d	file:
LATERN	cursesio.c	106;"	d	file:
LC_2STOP_BITS	rs232.c	45;"	d	file:
LC_ADDRESS_DIVISOR	rs232.c	49;"	d	file:
LC_BREAK	rs232.c	48;"	d	file:
LC_PAREVEN	rs232.c	47;"	d	file:
LC_PARITY	rs232.c	46;"	d	file:
LDH_DEFAULT	at_wini.c	32;"	d	file:
LDH_LBA	at_wini.c	33;"	d	file:
LDT	protect.h	94;"	d
LDT_SIZE	protect.h	6;"	d
LEAD_OUT	mcd.c	42;"	d	file:
LEAPYEAR	loc_time.h	9;"	d
LED_CODE	keyboard.c	28;"	d	file:
LEFTARROW	cursesio.c	100;"	d	file:
LEN	crypt.c	24;"	d	file:
LEVEL0_VECTOR	const.h	44;"	d
LIBRARY	Makefile	/^LIBRARY	= ..\/libc.a$/;"	m
LIGHT_ON	esdi_wini.c	85;"	d	file:
LIMIT_HIGH	protect.h	127;"	d
LINES	cursesio.c	/^int LINES, COLS;$/;"	v
LINE_LEFT	sb16.h	158;"	d
LINE_RIGHT	sb16.h	157;"	d
LINK	test17.c	54;"	d	file:
LINK	test18.c	54;"	d	file:
LINKCOUNT	test17.c	30;"	d	file:
LINO	em_abs.h	9;"	d
LINO_AD	em_abs.h	6;"	d
LN3D2	tanh.c	44;"	d	file:
LNV	sinh.c	49;"	d	file:
LOADOFF	bootblock.s	/^	LOADOFF	   =	0x7C00	! 0x0000:LOADOFF is where this code is loaded$/;"	d
LOADOFF	extboot.s	/^	LOADOFF	   =	0x7C00	! 0x0000:LOADOFF is where this code is loaded$/;"	d
LOADOFF	masterboot.s	/^	LOADOFF	   =	0x7C00	! 0x0000:LOADOFF is where this code is loaded$/;"	d
LOADSEG	boothead.s	/^	LOADSEG     =	0x1000	! Where this code is loaded.$/;"	d
LOG_MINOR	tty.c	67;"	d	file:
LONGS_REVERSED	get_put.h	18;"	d
LOWSEC	bootblock.s	/^	LOWSEC     =	     8	! Offset of logical first sector in partition$/;"	d
LOW_EXP	fphook.c	82;"	d	file:
LSEEK	test17.c	50;"	d	file:
LSEEK	test18.c	50;"	d	file:
LS_BREAK_INTERRUPT	rs232.c	55;"	d	file:
LS_BREAK_INTERRUPT	rs232.c	80;"	d	file:
LS_FRAMING_ERR	rs232.c	54;"	d	file:
LS_FRAMING_ERR	rs232.c	79;"	d	file:
LS_OVERRUN_ERR	rs232.c	52;"	d	file:
LS_OVERRUN_ERR	rs232.c	77;"	d	file:
LS_PARITY_ERR	rs232.c	53;"	d	file:
LS_PARITY_ERR	rs232.c	78;"	d	file:
LS_TRANSMITTER_READY	rs232.c	56;"	d	file:
L_FORMAT	ps.c	132;"	d	file:
L_HEADER	ps.c	131;"	d	file:
L_ctermid	ctermid.c	21;"	d	file:
L_cuserid	cuserid.c	13;"	d	file:
L_cuserid	getlogin.c	13;"	d	file:
Length	editline.c	/^STATIC SIZE_T		Length;$/;"	v
Line	editline.c	/^STATIC CHAR		*Line;$/;"	v
Lines	editline.c	/^    CHAR	*Lines[HIST_SIZE];$/;"	m	struct:_HISTORY	file:
M	lrand.c	29;"	d	file:
MAGIC	extboot.s	/^	MAGIC	   =	   510	! Location of the AA55 magic number$/;"	d
MAGIC	masterboot.s	/^	MAGIC	   =	   510	! Location of the AA55 magic number$/;"	d
MAGIC	regexp.c	38;"	d	file:
MAGIC	regsub.c	29;"	d	file:
MAGIC_OFF	bootimage.c	56;"	d	file:
MASK	test17.c	31;"	d	file:
MASK	test18.c	31;"	d	file:
MASTER	floppy.c	53;"	d	file:
MAXADDRS	gethnmadr.c	52;"	d	file:
MAXADDRS	gethostent.c	61;"	d	file:
MAXALIASES	gethnmadr.c	51;"	d	file:
MAXALIASES	gethostent.c	60;"	d	file:
MAXALIASES	getprotoent.c	34;"	d	file:
MAXALIASES	getservent.c	32;"	d	file:
MAXBIT	adder.c	20;"	d	file:
MAXERR	test17.c	18;"	d	file:
MAXERR	test18.c	19;"	d	file:
MAXHOSTNAMELEN	ether.h	129;"	d
MAXHOSTNAMELEN	rcmd.c	45;"	d	file:
MAXLINK	test17.c	29;"	d	file:
MAXLINK	test18.c	30;"	d	file:
MAXOPEN	test17.c	28;"	d	file:
MAXOPEN	test18.c	29;"	d	file:
MAXPACKET	gethnmadr.c	84;"	d	file:
MAXPACKET	gethnmadr.c	86;"	d	file:
MAXPACKET	res_query.c	66;"	d	file:
MAXPACKET	res_query.c	68;"	d	file:
MAXPATHLEN	rcmd.c	46;"	d	file:
MAX_286_SEG_SIZE	protect.h	72;"	d
MAX_ARP_RETRIES	arp.c	28;"	d	file:
MAX_BUF2	cache2.c	24;"	d	file:
MAX_BUFREQ_PRI	buf.h	12;"	d
MAX_DEVICES	aha_scsi.c	311;"	d	file:
MAX_DRIVES	at_wini.c	97;"	d	file:
MAX_DRIVES	bios_wini.c	35;"	d	file:
MAX_DRIVES	esdi_wini.c	78;"	d	file:
MAX_DRIVES	xt_wini.c	75;"	d	file:
MAX_ERROR	t11a.c	10;"	d	file:
MAX_ERROR	t11b.c	9;"	d	file:
MAX_ERROR	test1.c	12;"	d	file:
MAX_ERROR	test11.c	14;"	d	file:
MAX_ERROR	test14.c	11;"	d	file:
MAX_ERROR	test16.c	12;"	d	file:
MAX_ERROR	test19.c	10;"	d	file:
MAX_ERROR	test2.c	14;"	d	file:
MAX_ERROR	test20.c	33;"	d	file:
MAX_ERROR	test21.c	19;"	d	file:
MAX_ERROR	test22.c	12;"	d	file:
MAX_ERROR	test23.c	14;"	d	file:
MAX_ERROR	test24.c	26;"	d	file:
MAX_ERROR	test25.c	19;"	d	file:
MAX_ERROR	test26.c	28;"	d	file:
MAX_ERROR	test27.c	16;"	d	file:
MAX_ERROR	test28.c	23;"	d	file:
MAX_ERROR	test29.c	21;"	d	file:
MAX_ERROR	test3.c	15;"	d	file:
MAX_ERROR	test30.c	22;"	d	file:
MAX_ERROR	test31.c	15;"	d	file:
MAX_ERROR	test32.c	15;"	d	file:
MAX_ERROR	test33.c	15;"	d	file:
MAX_ERROR	test34.c	22;"	d	file:
MAX_ERROR	test35.c	17;"	d	file:
MAX_ERROR	test36.c	15;"	d	file:
MAX_ERROR	test37.c	15;"	d	file:
MAX_ERROR	test38.c	27;"	d	file:
MAX_ERROR	test39.c	23;"	d	file:
MAX_ERROR	test40.c	15;"	d	file:
MAX_ERROR	test5.c	13;"	d	file:
MAX_ERROR	test6.c	13;"	d	file:
MAX_ERROR	test7.c	22;"	d	file:
MAX_ERROR	test8.c	18;"	d	file:
MAX_ERROR	test9.c	7;"	d	file:
MAX_ERRORS	at_wini.c	103;"	d	file:
MAX_ERRORS	esdi_wini.c	77;"	d	file:
MAX_ERRORS	floppy.c	118;"	d	file:
MAX_ERRORS	xt_wini.c	76;"	d	file:
MAX_ESC_PARMS	console.c	38;"	d	file:
MAX_EXP	ext_comp.c	436;"	d	file:
MAX_FD	test20.c	29;"	d	file:
MAX_IOCTL_S	sr.h	8;"	d
MAX_KB_ACK_RETRIES	keyboard.c	29;"	d	file:
MAX_KB_BUSY_RETRIES	keyboard.c	30;"	d	file:
MAX_NUM_ARGS	execlp.c	50;"	d	file:
MAX_RARP_RETRIES	arp.c	27;"	d	file:
MAX_RESULTS	floppy.c	119;"	d	file:
MAX_RESULTS	xt_wini.c	77;"	d	file:
MAX_SECS	at_wini.c	101;"	d	file:
MAX_SECS	at_wini.c	99;"	d	file:
MAX_SECS	bios_wini.c	36;"	d	file:
MAX_SECTORS	floppy.c	93;"	d	file:
MAX_TRACKS	mcd.c	41;"	d	file:
MAX_WIN_RETRY	xt_wini.c	81;"	d	file:
MCD_AUDIO_BUSY	mcd.c	72;"	d	file:
MCD_AUDIO_DISK	mcd.c	74;"	d	file:
MCD_BLOCK_MASK	mcd.c	35;"	d	file:
MCD_BLOCK_SHIFT	mcd.c	34;"	d	file:
MCD_BLOCK_SIZE	mcd.c	33;"	d	file:
MCD_BUSY	mcd.c	82;"	d	file:
MCD_CMD_ERROR	mcd.c	71;"	d	file:
MCD_CONTROL_PORT	mcd.c	28;"	d	file:
MCD_COOKED	mcd.c	66;"	d	file:
MCD_DATALENGTH	mcd.c	65;"	d	file:
MCD_DATA_AVAILABLE	mcd.c	81;"	d	file:
MCD_DATA_PORT	mcd.c	26;"	d	file:
MCD_DEBUG	mcd.c	19;"	d	file:
MCD_DISK_CHANGED	mcd.c	76;"	d	file:
MCD_DISK_IN	mcd.c	77;"	d	file:
MCD_DOOR_OPEN	mcd.c	78;"	d	file:
MCD_ECC_MODE	mcd.c	64;"	d	file:
MCD_EJECT	mcd.c	57;"	d	file:
MCD_FLAG_PORT	mcd.c	27;"	d	file:
MCD_GET_Q_CHANNEL	mcd.c	48;"	d	file:
MCD_GET_STATUS	mcd.c	49;"	d	file:
MCD_GET_TOC	mcd.c	63;"	d	file:
MCD_GET_VERSION	mcd.c	55;"	d	file:
MCD_GET_VOL_INFO	mcd.c	47;"	d	file:
MCD_IO_BASE_ADDRESS	mcd.c	25;"	d	file:
MCD_IRQ	mcd.c	22;"	d	file:
MCD_MUTE_DATA	mcd.c	62;"	d	file:
MCD_PICKLE	mcd.c	58;"	d	file:
MCD_READ_ERROR	mcd.c	73;"	d	file:
MCD_READ_FROM_TO	mcd.c	54;"	d	file:
MCD_RESET	mcd.c	51;"	d	file:
MCD_RETRIES	mcd.c	39;"	d	file:
MCD_SET_DRIVE_MODE	mcd.c	53;"	d	file:
MCD_SET_MODE	mcd.c	50;"	d	file:
MCD_SKIP	mcd.c	32;"	d	file:
MCD_SPINNING	mcd.c	75;"	d	file:
MCD_STOP	mcd.c	56;"	d	file:
MCD_STOP_AUDIO	mcd.c	52;"	d	file:
MCD_TOC	mcd.c	67;"	d	file:
MC_DTR	rs232.c	59;"	d	file:
MC_OUT2	rs232.c	61;"	d	file:
MC_RTS	rs232.c	60;"	d	file:
MEMCHECK_ADR	keyboard.c	39;"	d	file:
MEMCHECK_MAG	keyboard.c	40;"	d	file:
MEM_BYTES	const.h	113;"	d
MEM_INC	editline.h	38;"	d
MEM_PATH	ps.c	117;"	d	file:
MESSAGE	_sendrec.s	/^MESSAGE = 12$/;"	d
META	editline.c	19;"	d	file:
META	regexp.c	141;"	d	file:
MIC	sb16.h	154;"	d
MIDLINE	cursesio.c	117;"	d	file:
MILLISEC	clock.c	54;"	d	file:
MINIX	mpx386.s	/^MINIX:				! this is the entry point for the MINIX kernel$/;"	l
MINIX	mpx88.s	/^MINIX:				! this is the entry point for the MINIX kernel$/;"	l
MINIXPOS	boot.h	19;"	d
MINOR_fd0a	drvlib.h	22;"	d
MINOR_hd1a	drvlib.h	21;"	d
MINOR_st0	aha_scsi.c	317;"	d	file:
MIXER_AGC	sb16.h	144;"	d
MIXER_BASS_LEFT	sb16.h	147;"	d
MIXER_BASS_RIGHT	sb16.h	148;"	d
MIXER_CD_LEFT	sb16.h	131;"	d
MIXER_CD_RIGHT	sb16.h	132;"	d
MIXER_DAC_LEFT	sb16.h	127;"	d
MIXER_DAC_LEVEL	sb16.h	124;"	d
MIXER_DAC_RIGHT	sb16.h	128;"	d
MIXER_DATA	sb16.h	91;"	d
MIXER_FM_LEFT	sb16.h	129;"	d
MIXER_FM_RIGHT	sb16.h	130;"	d
MIXER_GAIN_IN_LEFT	sb16.h	140;"	d
MIXER_GAIN_IN_RIGHT	sb16.h	141;"	d
MIXER_GAIN_OUT_LEFT	sb16.h	142;"	d
MIXER_GAIN_OUT_RIGHT	sb16.h	143;"	d
MIXER_IN_LEFT	sb16.h	138;"	d
MIXER_IN_RIGHT	sb16.h	139;"	d
MIXER_IRQ_STATUS	sb16.h	151;"	d
MIXER_LINE_LEFT	sb16.h	133;"	d
MIXER_LINE_RIGHT	sb16.h	134;"	d
MIXER_MASTER_LEFT	sb16.h	125;"	d
MIXER_MASTER_RIGHT	sb16.h	126;"	d
MIXER_MIC_LEVEL	sb16.h	135;"	d
MIXER_OUTPUT_CTRL	sb16.h	137;"	d
MIXER_PC_LEVEL	sb16.h	136;"	d
MIXER_REG	sb16.h	90;"	d
MIXER_RESET	sb16.h	123;"	d
MIXER_SET_DMA	sb16.h	150;"	d
MIXER_SET_IRQ	sb16.h	149;"	d
MIXER_TREBLE_LEFT	sb16.h	145;"	d
MIXER_TREBLE_RIGHT	sb16.h	146;"	d
MODE_MASK	test27.c	15;"	d	file:
MONO_BASE	console.c	28;"	d	file:
MONO_MODE	boot.h	33;"	d
MONO_SIZE	console.c	30;"	d	file:
MON_CS_INDEX	protect.h	15;"	d
MON_CS_SELECTOR	protect.h	31;"	d
MOTOR_OFF	floppy.c	96;"	d	file:
MOTOR_SHIFT	floppy.c	56;"	d	file:
MQ_SIZE	mq.c	10;"	d	file:
MSB_AT_LOW_ADDRESS	byte_order.h	2;"	d
MSEC_PER_TICK	boot.h	25;"	d
MSW_AT_LOW_ADDRESS	byte_order.h	3;"	d
MS_CTS	rs232.c	64;"	d	file:
MS_CTS	rs232.c	83;"	d	file:
MS_DRLSD	rs232.c	66;"	d	file:
MS_RLSD	rs232.c	65;"	d	file:
MVC_ARGS	klib386.s	/^MVC_ARGS	=	4 + 4 + 4 + 4	! 4 + 4 + 4$/;"	d
MVC_ARGS	klib88.s	/^MVC_ARGS	=	2 + 2 + 2 + 2	! 2 + 2 + 2$/;"	d
M_1_PI	localmath.h	14;"	d
M_1_SQRT2	localmath.h	23;"	d
M_2PI	localmath.h	8;"	d
M_2_PI	localmath.h	15;"	d
M_3PI_4	localmath.h	9;"	d
M_3PI_8	localmath.h	11;"	d
M_4_PI	localmath.h	16;"	d
M_6845	console.c	41;"	d	file:
M_E	localmath.h	17;"	d
M_EULER	localmath.h	24;"	d
M_LN10	localmath.h	21;"	d
M_LN2	localmath.h	20;"	d
M_LN_MAX_D	localmath.h	41;"	d
M_LN_MIN_D	localmath.h	42;"	d
M_LOG10E	localmath.h	19;"	d
M_LOG2E	localmath.h	18;"	d
M_PI	localmath.h	7;"	d
M_PI_2	localmath.h	10;"	d
M_PI_4	localmath.h	12;"	d
M_PI_8	localmath.h	13;"	d
M_SQRT2	localmath.h	22;"	d
Map	editline.c	/^FORWARD KEYMAP		Map[33];$/;"	v
Map	editline.c	/^STATIC KEYMAP	Map[33] = {$/;"	v
Mark	editline.c	/^STATIC int		Mark;$/;"	v
MaxName	test23.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test24.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test25.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test26.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test27.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test28.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test30.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test31.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test32.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test33.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test34.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test35.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test36.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test37.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test38.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test39.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxName	test40.c	/^char MaxName[NAME_MAX + 1];	\/* Name of maximum length *\/$/;"	v
MaxPath	test23.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test24.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test25.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test26.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test27.c	/^char MaxPath[PATH_MAX];$/;"	v
MaxPath	test28.c	/^char MaxPath[PATH_MAX];$/;"	v
MaxPath	test30.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test31.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test32.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test33.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test34.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test35.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test36.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test37.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test38.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test39.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
MaxPath	test40.c	/^char MaxPath[PATH_MAX];		\/* Same for path *\/$/;"	v
McdStatus	mcd.c	/^PRIVATE int McdStatus = NO_DISK;        \/* A new (or no) disk is inserted *\/ $/;"	v
MetaMap	editline.c	/^FORWARD KEYMAP		MetaMap[17];$/;"	v
MetaMap	editline.c	/^STATIC KEYMAP	MetaMap[17]= {$/;"	v
Mkdir	test34.c	34;"	d	file:
Mkdir	test35.c	25;"	d	file:
Mkfifo	test33.c	22;"	d	file:
Mkfifo	test34.c	33;"	d	file:
Mkfifo	test35.c	24;"	d	file:
Mkfifo	test40.c	21;"	d	file:
N	ne2000.c	22;"	d	file:
N	test34.c	24;"	d	file:
N	test35.c	19;"	d	file:
NB	test19.c	11;"	d	file:
NBOUNDS	test19.c	12;"	d	file:
NDIGINEXP	fphook.c	81;"	d	file:
NDIGITS	ext_comp.c	551;"	d	file:
NE1000_SIZE	ne2000.h	15;"	d
NE1000_START	ne2000.h	14;"	d
NE2000_H	ne2000.h	8;"	d
NE2000_SIZE	ne2000.h	17;"	d
NE2000_START	ne2000.h	16;"	d
NEGATE_STROBE	printer.c	46;"	d	file:
NEW	editline.h	42;"	d
NEWLINE	editline.c	/^STATIC char		NEWLINE[]= CRLF;$/;"	v
NEXITS	atexit.c	5;"	d	file:
NEXITS	exit.c	10;"	d	file:
NEXT	regexp.c	127;"	d	file:
NE_DATA	ne2000.h	11;"	d
NE_DP8390	ne2000.h	10;"	d
NE_RESET	ne2000.h	12;"	d
NFDBITS	res_send.c	101;"	d	file:
NF_EMPTY	ip_write.c	42;"	d	file:
NF_INUSE	ip_write.c	43;"	d	file:
NF_SUSPENDED	ip_write.c	44;"	d	file:
NIL	editline.c	/^STATIC CHAR		NIL[] = "";$/;"	v
NIL	test17.c	43;"	d	file:
NIL	test18.c	43;"	d	file:
NIL_DEV	driver.h	37;"	d
NIL_FILP	file.h	15;"	d
NIL_HOLE	alloc.c	22;"	d	file:
NIL_INODE	inode.h	37;"	d
NIL_MPROC	mproc.h	55;"	d
NIL_MPROC	trace.c	29;"	d	file:
NIL_PROC	proc.h	87;"	d
NIL_SUPER	super.h	48;"	d
NITER	sqrt.c	13;"	d	file:
NLEN	system.c	327;"	d	file:
NMI_VECTOR	const.h	37;"	d
NOCRASH	test17.c	16;"	d	file:
NOCRASH	test18.c	17;"	d	file:
NOFUN	boot.c	/^enum whatfun { NOFUN, SELECT, DEFFUN, USERFUN } menufun(environment *e)$/;"	e	enum:whatfun	file:
NOFUN	edparams.c	/^enum whatfun { NOFUN, SELECT, DEFFUN, USERFUN } menufun(environment *e)$/;"	e	enum:whatfun	file:
NONL	cursesio.c	/^bool NONL;$/;"	v
NORMAL_STATUS	printer.c	60;"	d	file:
NORMBIT	FP_shift.h	13;"	d
NOTHING	regexp.c	86;"	d	file:
NOT_ESCAPED	tty.h	74;"	d
NOT_REVIVING	fproc.h	32;"	d
NOT_SUSPENDED	fproc.h	30;"	d
NO_ARG	editline.c	14;"	d	file:
NO_CYL	floppy.c	129;"	d	file:
NO_DENS	floppy.c	130;"	d	file:
NO_DISK	mcd.c	130;"	d	file:
NO_DMA_INT	xt_wini.c	54;"	d	file:
NO_MAP	proc.h	73;"	d
NO_MOUNT	inode.h	42;"	d
NO_PAPER	printer.c	59;"	d	file:
NO_PID	init.c	47;"	d	file:
NO_PIPE	inode.h	40;"	d
NO_SECTOR	floppy.c	128;"	d	file:
NO_SEEK	inode.h	44;"	d
NQ	const.h	128;"	d
NQ	const.h	130;"	d
NR_CHARS	doscan.c	22;"	d	file:
NR_DEVICES	at_wini.c	104;"	d	file:
NR_DEVICES	bios_wini.c	37;"	d	file:
NR_DEVICES	esdi_wini.c	79;"	d	file:
NR_DEVICES	xt_wini.c	78;"	d	file:
NR_DISKDEVS	aha_scsi.c	312;"	d	file:
NR_DRIVES	floppy.c	120;"	d	file:
NR_GENDEVS	aha_scsi.c	314;"	d	file:
NR_HEADS	floppy.c	92;"	d	file:
NR_HOLES	alloc.c	21;"	d	file:
NR_IRQ_VECTORS	const.h	56;"	d
NR_MEMS	const.h	104;"	d
NR_MEMS	const.h	88;"	d
NR_RAMS	memory.c	20;"	d	file:
NR_REGS	const.h	107;"	d
NR_SECTORS	xt_wini.c	67;"	d	file:
NR_SUBDEVS	aha_scsi.c	316;"	d	file:
NR_SUBDEVS	at_wini.c	106;"	d	file:
NR_SUBDEVS	bios_wini.c	39;"	d	file:
NR_SUBDEVS	esdi_wini.c	82;"	d	file:
NR_SUBDEVS	xt_wini.c	80;"	d	file:
NR_TAPEDEVS	aha_scsi.c	313;"	d	file:
NSIGNIFICANT	ext_comp.c	552;"	d	file:
NT	floppy.c	124;"	d	file:
NULL	execlp.c	47;"	d	file:
NULL	execlp.c	48;"	d	file:
NUMLEN	doscan.c	21;"	d	file:
NUM_BLOCKS	test13.c	16;"	d	file:
NUM_TIMES	test12.c	12;"	d	file:
NUNGETCH	curspriv.h	14;"	d
NWEO_DEFAULT	eth.h	8;"	d
NWIO_DEFAULT	ip_int.h	133;"	d
NameTooLong	test34.c	/^char NameTooLong[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
NameTooLong	test35.c	/^char NameTooLong[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
NextFree	malloc.c	31;"	d	file:
NextSlot	malloc.c	30;"	d	file:
OBJECTS	Makefile	/^OBJECTS	= \\$/;"	m
ODEVHUP	rs232.c	194;"	d	file:
ODEVREADY	rs232.c	191;"	d	file:
ODONE	rs232.c	188;"	d	file:
OFF	ngf4.c	16;"	d	file:
OFF	ngf8.c	16;"	d	file:
OFFSET_HIGH_SHIFT	protect.h	115;"	d
OFF_MASK	klib88.s	/^#define OFF_MASK	0x000F	\/* offset mask for phys_b -> hclick:offset *\/$/;"	d
OK	test17.c	34;"	d	file:
OK	test18.c	34;"	d	file:
ON_LINE	printer.c	61;"	d	file:
OP	regexp.c	126;"	d	file:
OPEN	regexp.c	91;"	d	file:
OPEN	test17.c	48;"	d	file:
OPEN	test18.c	48;"	d	file:
OPERAND	regexp.c	128;"	d	file:
OPL3_BOTH	sb16.h	94;"	d
OPL3_LEFT	sb16.h	92;"	d
OPL3_RIGHT	sb16.h	93;"	d
OP_IOCTL	asynchio.c	31;"	d	file:
OP_READ	asynchio.c	29;"	d	file:
OP_WRITE	asynchio.c	30;"	d	file:
OQUEUED	rs232.c	192;"	d	file:
ORAW	rs232.c	189;"	d	file:
OSOFTBITS	rs232.c	195;"	d	file:
OSWREADY	rs232.c	193;"	d	file:
OVERFLOW_DIR_NR	test24.c	25;"	d	file:
OVERFLOW_VECTOR	const.h	39;"	d
OWAKEUP	rs232.c	190;"	d	file:
O_APPEND	fopen.c	39;"	d	file:
O_APPEND	freopen.c	24;"	d	file:
O_CREAT	fopen.c	37;"	d	file:
O_CREAT	freopen.c	22;"	d	file:
O_NOCTTY	tty.h	9;"	d
O_NONBLOCK	tty.h	10;"	d
O_RDONLY	fopen.c	17;"	d	file:
O_RDONLY	freopen.c	18;"	d	file:
O_RDWR	fopen.c	19;"	d	file:
O_RDWR	freopen.c	20;"	d	file:
O_TRUNC	fopen.c	38;"	d	file:
O_TRUNC	freopen.c	23;"	d	file:
O_WRONLY	fopen.c	18;"	d	file:
O_WRONLY	freopen.c	19;"	d	file:
OldPoint	editline.c	/^STATIC int		OldPoint;$/;"	v
PAGE_FAULT_VECTOR	protect.h	104;"	d
PAGE_GRAN_SHIFT	protect.h	116;"	d
PARAGRAPH	cursesio.c	125;"	d	file:
PARAMSEC	boot.h	10;"	d
PARAMSEC	edparams.c	26;"	d	file:
PARTPOS	installboot.c	36;"	d	file:
PART_TABLE	extboot.s	/^	PART_TABLE =	   446	! Location of partition table within this code$/;"	d
PART_TABLE	masterboot.s	/^	PART_TABLE =	   446	! Location of partition table within this code$/;"	d
PASSWD	getpwent.c	/^static char PASSWD[]= "\/etc\/passwd";	\/* The password file. *\/$/;"	v	file:
PASSWD_FILE	test34.c	38;"	d	file:
PASSWD_FILE	test35.c	31;"	d	file:
PATH_UTMP	init.c	/^char PATH_UTMP[] = "\/etc\/utmp";		\/* current logins *\/$/;"	v
PATH_WTMP	init.c	/^char PATH_WTMP[] = "\/usr\/adm\/wtmp";	\/* login\/logout history *\/$/;"	v
PAUSED	mproc.h	48;"	d
PCM_DENSITY	klib88.s	/^PCM_DENSITY	=	256	! resolution of check$/;"	d
PCR	const.h	91;"	d
PC_ARGS	klib386.s	/^PC_ARGS	=	4 + 4 + 4 + 4	! 4 + 4 + 4$/;"	d
PDPNOHANG	test17.c	17;"	d	file:
PDPNOHANG	test18.c	18;"	d	file:
PENDING	proc.h	76;"	d
PENTRYSIZE	boothead.s	/^	PENTRYSIZE  =	    16	! Partition table entry size.$/;"	d
PENTRYSIZE	extboot.s	/^	PENTRYSIZE =	    16	! Size of one partition table entry$/;"	d
PENTRYSIZE	masterboot.s	/^	PENTRYSIZE =	    16	! Size of one partition table entry$/;"	d
PIDSLOTS	init.c	39;"	d	file:
PIPE	test17.c	56;"	d	file:
PIPE	test18.c	56;"	d	file:
PIPESIZE	test17.c	27;"	d	file:
PIPESIZE	test18.c	28;"	d	file:
PLUS	regexp.c	89;"	d	file:
PLUSMINUS	cursesio.c	109;"	d	file:
PMODE	fopen.c	13;"	d	file:
PMODE	freopen.c	13;"	d	file:
POLYNOM1	localmath.h	27;"	d
POLYNOM10	localmath.h	36;"	d
POLYNOM11	localmath.h	37;"	d
POLYNOM12	localmath.h	38;"	d
POLYNOM13	localmath.h	39;"	d
POLYNOM2	localmath.h	28;"	d
POLYNOM3	localmath.h	29;"	d
POLYNOM4	localmath.h	30;"	d
POLYNOM5	localmath.h	31;"	d
POLYNOM6	localmath.h	32;"	d
POLYNOM7	localmath.h	33;"	d
POLYNOM8	localmath.h	34;"	d
POLYNOM9	localmath.h	35;"	d
PORT_B	const.h	92;"	d
PRESENT	protect.h	78;"	d
PRINTER_IRQ	const.h	65;"	d
PRIVATE	inet.h	57;"	d
PROCESS_MAX	bootimage.c	41;"	d	file:
PROC_H	proc.h	2;"	d
PROTECTION_VECTOR	protect.h	59;"	d
PROTO_H	proto.h	4;"	d
PR_ARGS	klib386.s	/^PR_ARGS	=	4 + 4 + 4		! 4 + 4 + 4$/;"	d
PR_ARGS_B	klib386.s	/^PR_ARGS_B =	4 + 4 + 4		! 4 + 4 + 4$/;"	d
PTRSIZE	_exec.c	14;"	d	file:
PTRSIZE	_execn.c	4;"	d	file:
PTRSIZE	malloc.c	28;"	d	file:
PTYPX_MINOR	tty.c	70;"	d	file:
PTY_ACTIVE	pty.c	56;"	d	file:
PTY_CLOSED	pty.c	58;"	d	file:
PUBLIC	inet.h	55;"	d
PWDAUTH	crypt.c	/^static char PWDAUTH[] = "\/usr\/lib\/pwdauth";$/;"	v	file:
PW_ARGS	klib386.s	/^PW_ARGS	=	4 + 4 + 4		! 4 + 4 + 4$/;"	d
PW_ARGS_B	klib386.s	/^PW_ARGS_B =	4 + 4 + 4		! 4 + 4 + 4$/;"	d
P_FLOPPY	drvlib.h	23;"	d
P_INIT_OFF	bootimage.c	63;"	d	file:
P_PRIMARY	drvlib.h	24;"	d
P_SIZ_OFF	bootimage.c	62;"	d	file:
P_SLOT_FREE	proc.h	72;"	d
P_STOP	proc.h	78;"	d
P_SUB	drvlib.h	25;"	d
PathTooLong	test34.c	/^char PathTooLong[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
PathTooLong	test35.c	/^char PathTooLong[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
PlayMss	mcd.c	/^PRIVATE struct cd_play_mss PlayMss;     \/* Keep track of where we are if we$/;"	v	typeref:struct:cd_play_mss
Point	editline.c	/^STATIC int		Point;$/;"	v
Pos	editline.c	/^    int		Pos;$/;"	m	struct:_HISTORY	file:
Prompt	editline.c	/^STATIC CONST char	*Prompt;$/;"	v
PushBack	editline.c	/^STATIC int		PushBack;$/;"	v
Pushed	editline.c	/^STATIC int		Pushed;$/;"	v
Putchar	update.c	/^static void Putchar(ch)$/;"	f	file:
Q	lrand.c	30;"	d	file:
R	lrand.c	31;"	d	file:
R	test17.c	37;"	d	file:
R	test18.c	37;"	d	file:
RARP_REPLY	arp.h	13;"	d
RARP_REQUEST	arp.h	12;"	d
RARP_TIMEOUT	arp.c	29;"	d	file:
RATIO	boot.h	8;"	d
RATIO	installboot.c	28;"	d	file:
RCR_AB	dp8390.h	138;"	d
RCR_AM	dp8390.h	139;"	d
RCR_AR	dp8390.h	137;"	d
RCR_MON	dp8390.h	141;"	d
RCR_PRO	dp8390.h	140;"	d
RCR_SEP	dp8390.h	136;"	d
RD_BUF	test20.c	32;"	d	file:
RD_IOVEC	osdep_eth.h	11;"	d
READ	test17.c	47;"	d	file:
READ	test18.c	47;"	d	file:
READ	test7.c	24;"	d	file:
READABLE	protect.h	87;"	d
READ_EOF	test18.c	32;"	d	file:
REBOOT_CMD	init.c	/^char *REBOOT_CMD[] =	{ "shutdown", "now", "CTRL-ALT-DEL", NULL };$/;"	v
RECEIVE	_sendrec.s	/^RECEIVE = 2$/;"	d
RECEIVING	proc.h	75;"	d
RECOVERYTIME	at_wini.c	108;"	d	file:
REG_BASE0	at_wini.c	23;"	d	file:
REG_BASE1	at_wini.c	24;"	d	file:
REG_COMMAND	at_wini.c	55;"	d	file:
REG_COUNT	at_wini.c	27;"	d	file:
REG_CTL	at_wini.c	66;"	d	file:
REG_CYL_HI	at_wini.c	30;"	d	file:
REG_CYL_LO	at_wini.c	29;"	d	file:
REG_DATA	at_wini.c	25;"	d	file:
REG_ERROR	at_wini.c	46;"	d	file:
REG_LDH	at_wini.c	31;"	d	file:
REG_PRECOMP	at_wini.c	26;"	d	file:
REG_SECTOR	at_wini.c	28;"	d	file:
REG_STATUS	at_wini.c	37;"	d	file:
RENEW	editline.h	44;"	d
REPLY_DELAY	mcd.c	40;"	d	file:
RESULT	asynchio.c	27;"	d	file:
REVIVING	fproc.h	33;"	d
RFAIL	regexp.c	139;"	d	file:
RIGHTARROW	cursesio.c	99;"	d	file:
ROOT_INO	rawfs.h	33;"	d
ROUTE_NR	ipr.c	14;"	d	file:
RPL	protect.h	63;"	d
RS232_IRQ	const.h	62;"	d
RS232_MINOR	tty.c	68;"	d	file:
RSR_CRC	dp8390.h	145;"	d
RSR_DIS	dp8390.h	150;"	d
RSR_FAE	dp8390.h	146;"	d
RSR_FO	dp8390.h	147;"	d
RSR_MPA	dp8390.h	148;"	d
RSR_PHY	dp8390.h	149;"	d
RSR_PRX	dp8390.h	144;"	d
RS_IBUFSIZE	rs232.c	90;"	d	file:
RS_IHIGHWATER	rs232.c	99;"	d	file:
RS_ILOWWATER	rs232.c	98;"	d	file:
RS_OBUFSIZE	rs232.c	91;"	d	file:
RS_OLOWWATER	rs232.c	105;"	d	file:
RTF_EMPTY	ipr.h	21;"	d
RTF_FIXED	ipr.h	23;"	d
RTF_INUSE	ipr.h	22;"	d
RULE_LEN	misc.c	39;"	d	file:
RUNNING	tty.h	76;"	d
RW	test17.c	39;"	d	file:
RW	test18.c	39;"	d	file:
RWX	test17.c	41;"	d	file:
RWX	test18.c	41;"	d	file:
R_STATE	ps.c	165;"	d	file:
Remove	test17.c	/^void Remove(fdes, fname)$/;"	f
Remove	test18.c	/^void Remove(fdes, fname)$/;"	f
Repeat	editline.c	/^STATIC int		Repeat;$/;"	v
SAFETY_BYTES	break.c	94;"	d	file:
SAFETY_CLICKS	break.c	95;"	d	file:
SAME	link.c	23;"	d	file:
SB16_H	sb16.h	2;"	d
SB_BASE_ADDR	sb16.h	11;"	d
SB_DEBUG	sb16.h	4;"	d
SB_DEBUG_2	sb16.h	5;"	d
SB_DMA_16	sb16.h	15;"	d
SB_DMA_8	sb16.h	14;"	d
SB_IRQ	sb16.h	10;"	d
SB_TIMEOUT	sb16.h	7;"	d
SCHED_RATE	clock.c	55;"	d	file:
SCREEN_INC	editline.h	39;"	d
SCREEN_ROWS	editline.c	13;"	d	file:
SCREEN_WIDTH	editline.c	12;"	d	file:
SCROLL_DOWN	console.c	35;"	d	file:
SCROLL_UP	console.c	34;"	d	file:
SCSI_CAPACITY	aha_scsi.c	196;"	d	file:
SCSI_DEVCDROM	aha_scsi.c	242;"	d	file:
SCSI_DEVCOMM	aha_scsi.c	246;"	d	file:
SCSI_DEVCPU	aha_scsi.c	240;"	d	file:
SCSI_DEVDISK	aha_scsi.c	237;"	d	file:
SCSI_DEVJUKEBOX	aha_scsi.c	245;"	d	file:
SCSI_DEVMAX	aha_scsi.c	247;"	d	file:
SCSI_DEVOPTICAL	aha_scsi.c	244;"	d	file:
SCSI_DEVPRN	aha_scsi.c	239;"	d	file:
SCSI_DEVSCANNER	aha_scsi.c	243;"	d	file:
SCSI_DEVTAPE	aha_scsi.c	238;"	d	file:
SCSI_DEVUNKNOWN	aha_scsi.c	248;"	d	file:
SCSI_DEVWORM	aha_scsi.c	241;"	d	file:
SCSI_ERASE	aha_scsi.c	170;"	d	file:
SCSI_INQUIRY	aha_scsi.c	168;"	d	file:
SCSI_LOADUNLD	aha_scsi.c	173;"	d	file:
SCSI_MDSELECT	aha_scsi.c	169;"	d	file:
SCSI_MDSENSE	aha_scsi.c	171;"	d	file:
SCSI_RDLIMITS	aha_scsi.c	163;"	d	file:
SCSI_READ	aha_scsi.c	164;"	d	file:
SCSI_READ1	aha_scsi.c	197;"	d	file:
SCSI_REQSENSE	aha_scsi.c	162;"	d	file:
SCSI_REWIND	aha_scsi.c	161;"	d	file:
SCSI_SPACE	aha_scsi.c	167;"	d	file:
SCSI_STRTSTP	aha_scsi.c	172;"	d	file:
SCSI_TIMEOUT	aha_scsi.c	308;"	d	file:
SCSI_UNITRDY	aha_scsi.c	160;"	d	file:
SCSI_WREOF	aha_scsi.c	166;"	d	file:
SCSI_WRITE	aha_scsi.c	165;"	d	file:
SCSI_WRITE1	aha_scsi.c	198;"	d	file:
SECONDARY_IRQ	const.h	61;"	d
SECONDS_PER_MINUTE	mcd.c	38;"	d	file:
SECS_DAY	loc_time.h	8;"	d
SECTORS	bootblock.s	/^	SECTORS	   =	     4	! Offset into parameters to sectors per track$/;"	d
SECTORS	boothead.s	/^	SECTORS	    =	     4	! Offset into parameters to sectors per track$/;"	d
SECTORS_PER_SECOND	mcd.c	37;"	d	file:
SECTOR_MASK	driver.h	53;"	d
SECTOR_SHIFT	boot.h	7;"	d
SECTOR_SHIFT	driver.h	52;"	d
SECTOR_SIZE	boot.h	6;"	d
SECTOR_SIZE	driver.h	51;"	d
SECTOR_SIZE	edparams.c	24;"	d	file:
SECTOR_SIZE	installboot.c	27;"	d	file:
SECTOR_SIZE_CODE	floppy.c	122;"	d	file:
SEEK_ST0	floppy.c	62;"	d	file:
SEGMENT	protect.h	81;"	d
SEGSIZE	peekpoke.c	17;"	d	file:
SEG_NOT_VECTOR	protect.h	57;"	d
SELECT	boot.c	/^enum whatfun { NOFUN, SELECT, DEFFUN, USERFUN } menufun(environment *e)$/;"	e	enum:whatfun	file:
SELECT	edparams.c	/^enum whatfun { NOFUN, SELECT, DEFFUN, USERFUN } menufun(environment *e)$/;"	e	enum:whatfun	file:
SELECT	printer.c	47;"	d	file:
SEND	_sendrec.s	/^SEND = 1$/;"	d
SENDING	proc.h	74;"	d
SENDQ_NR	dp8390.h	199;"	d
SENDQ_PAGES	dp8390.h	200;"	d
SENSE_ABORTED_CMD	aha_scsi.c	232;"	d	file:
SENSE_BLANK_CHECK	aha_scsi.c	230;"	d	file:
SENSE_HARDWARE	aha_scsi.c	228;"	d	file:
SENSE_NOT_READY	aha_scsi.c	227;"	d	file:
SENSE_NO_SENSE	aha_scsi.c	225;"	d	file:
SENSE_RECOVERED	aha_scsi.c	226;"	d	file:
SENSE_UNIT_ATT	aha_scsi.c	229;"	d	file:
SENSE_VENDOR	aha_scsi.c	231;"	d	file:
SEPARATE	mproc.h	50;"	d
SERVER_Q	const.h	123;"	d
SETPSW	const.h	10;"	d
SETPSW	const.h	110;"	d
SET_CLOEXEC	test38.c	35;"	d	file:
SFF_BUSY	sr.c	64;"	d	file:
SFF_FLAGS	sr.c	60;"	d	file:
SFF_FREE	sr.c	61;"	d	file:
SFF_INUSE	sr.c	63;"	d	file:
SFF_IOCTL_IP	sr.c	65;"	d	file:
SFF_IOCTL_SUSP	sr.c	70;"	d	file:
SFF_MINOR	sr.c	62;"	d	file:
SFF_PENDING_REQ	sr.c	68;"	d	file:
SFF_READ_IP	sr.c	66;"	d	file:
SFF_READ_SUSP	sr.c	71;"	d	file:
SFF_SUSPENDED	sr.c	69;"	d	file:
SFF_WRITE_IP	sr.c	67;"	d	file:
SFF_WRITE_SUSP	sr.c	72;"	d	file:
SGL_BIAS	FP_bias.h	14;"	d
SGL_CARRYOUT	FP_shift.h	25;"	d
SGL_EXACT	FP_shift.h	21;"	d
SGL_EXPSHIFT	FP_shift.h	18;"	d
SGL_M1LEFT	FP_shift.h	19;"	d
SGL_MASK	FP_shift.h	26;"	d
SGL_MAX	FP_bias.h	23;"	d
SGL_MIN	FP_bias.h	24;"	d
SGL_ROUNDUP	FP_shift.h	24;"	d
SGL_RUNPACK	FP_shift.h	22;"	d
SGL_ZERO	FP_shift.h	20;"	d
SHADOW_Q	const.h	127;"	d
SIGACTION	test29.c	4;"	d	file:
SIGBIT_0	_sigset.c	19;"	d	file:
SIGMASK	_sigset.c	22;"	d	file:
SIGN	cmf4.c	22;"	d	file:
SIGN	cmf8.c	19;"	d	file:
SIGNATOFF	boot.h	30;"	d
SIGNATURE	boot.h	29;"	d
SIGNATURE	installboot.c	29;"	d	file:
SIGNUM	test1.c	11;"	d	file:
SIGPOS	installboot.c	35;"	d	file:
SIGS	test8.c	17;"	d	file:
SIGSUSPENDED	mproc.h	53;"	d
SIG_PENDING	proc.h	77;"	d
SIG_ZERO	test5.c	45;"	d	file:
SIG_ZERO	test5.c	49;"	d	file:
SIMPLE	regexp.c	146;"	d	file:
SINGLE	FP_types.h	/^typedef	unsigned long	SINGLE;$/;"	t
SIZE	test3.c	16;"	d	file:
SIZE_T	editline.h	18;"	d
SLASH_SCAN	keyboard.c	35;"	d	file:
SLOWDEBUG	malloc.c	5;"	d	file:
SMART	at_wini.c	111;"	d	file:
SPEC2	floppy.c	95;"	d	file:
SPSTART	regexp.c	147;"	d	file:
SQUARE_WAVE	clock.c	61;"	d	file:
SRCDEST	_sendrec.s	/^SRCDEST = 8$/;"	d
SRCHI	klib88.s	/^SRCHI	=	6$/;"	d
SRCLO	klib88.s	/^SRCLO	=	4$/;"	d
SR_CANCEL_IOCTL	sr.h	18;"	d
SR_CANCEL_READ	sr.h	19;"	d
SR_CANCEL_WRITE	sr.h	20;"	d
SR_H	sr.h	6;"	d
SS_INDEX	protect.h	13;"	d
SS_SELECTOR	boothead.s	/^	SS_SELECTOR =	   5*8	! Monitor stack$/;"	d
SS_SELECTOR	protect.h	29;"	d
ST0	floppy.c	40;"	d	file:
ST0_BITS	floppy.c	60;"	d	file:
ST1	floppy.c	41;"	d	file:
ST2	floppy.c	42;"	d	file:
ST3	floppy.c	43;"	d	file:
ST3_FAULT	floppy.c	72;"	d	file:
ST3_READY	floppy.c	74;"	d	file:
ST3_WR_PROTECT	floppy.c	73;"	d	file:
STACK_CHANGED	break.c	24;"	d	file:
STACK_FAULT_VECTOR	protect.h	58;"	d
STACK_GUARD	proc.h	69;"	d
STAR	regexp.c	87;"	d	file:
STAT	test17.c	57;"	d	file:
STAT	test18.c	57;"	d	file:
STATIC	editline.h	24;"	d
STATIC	editline.h	26;"	d
STATIC	regexp.c	161;"	d	file:
STATUS	editline.c	/^} STATUS;$/;"	t	typeref:enum:_STATUS	file:
STATUS_BSY	at_wini.c	38;"	d	file:
STATUS_CRD	at_wini.c	43;"	d	file:
STATUS_DRQ	at_wini.c	42;"	d	file:
STATUS_ERR	at_wini.c	45;"	d	file:
STATUS_IDX	at_wini.c	44;"	d	file:
STATUS_MASK	printer.c	62;"	d	file:
STATUS_RDY	at_wini.c	39;"	d	file:
STATUS_SC	at_wini.c	41;"	d	file:
STATUS_WF	at_wini.c	40;"	d	file:
STAT_REG	esdi_wini.c	40;"	d	file:
STOPPED	mproc.h	52;"	d
STOPPED	tty.h	77;"	d
STREQ	test15.c	18;"	d	file:
STR_FUL	esdi_wini.c	53;"	d	file:
ST_CYL	floppy.c	44;"	d	file:
ST_HEAD	floppy.c	45;"	d	file:
ST_PCN	floppy.c	47;"	d	file:
ST_SEC	floppy.c	46;"	d	file:
SUB_PER_DRIVE	aha_scsi.c	315;"	d	file:
SUB_PER_DRIVE	at_wini.c	105;"	d	file:
SUB_PER_DRIVE	bios_wini.c	38;"	d	file:
SUB_PER_DRIVE	esdi_wini.c	81;"	d	file:
SUB_PER_DRIVE	mcd.c	43;"	d	file:
SUB_PER_DRIVE	xt_wini.c	79;"	d	file:
SUN_0WND_BUG	tcp.h	11;"	d
SUN_TRANS_BUG	tcp.h	14;"	d
SUSPENDED	fproc.h	31;"	d
SYS386_VECTOR	const.h	43;"	d
SYSVEC	_sendrec.s	/^SYSVEC = 33$/;"	d
SYS_PORTA	esdi_wini.c	84;"	d	file:
SYS_VECTOR	const.h	42;"	d
S_FORMAT	ps.c	130;"	d	file:
S_HEADER	ps.c	129;"	d	file:
S_ISDIR	unix.h	21;"	d
S_PRESENT	aha_scsi.c	329;"	d	file:
S_RDONLY	aha_scsi.c	331;"	d	file:
S_READY	aha_scsi.c	330;"	d	file:
S_STATE	ps.c	164;"	d	file:
Screen	editline.c	/^STATIC char		*Screen;$/;"	v
ScreenCount	editline.c	/^STATIC SIZE_T		ScreenCount;$/;"	v
ScreenSize	editline.c	/^STATIC SIZE_T		ScreenSize;$/;"	v
Signal	editline.c	/^STATIC int		Signal;$/;"	v
Signal	test5.c	/^void (*Signal(int a, void (*b)(int)))(int)$/;"	f
Size	editline.c	/^    int		Size;$/;"	m	struct:_HISTORY	file:
SplitPath	complete.c	/^SplitPath(path, dirpart, filepart)$/;"	f
Stat	test22.c	17;"	d	file:
Stat	test25.c	24;"	d	file:
Stat	test26.c	33;"	d	file:
Stat	test29.c	27;"	d	file:
Stat	test30.c	27;"	d	file:
Stat	test31.c	20;"	d	file:
Stat	test32.c	20;"	d	file:
Stat	test33.c	20;"	d	file:
Stat	test34.c	32;"	d	file:
Stat	test35.c	23;"	d	file:
Stat	test36.c	20;"	d	file:
Stat	test38.c	32;"	d	file:
Stat	test39.c	28;"	d	file:
Stat	test40.c	20;"	d	file:
System	test22.c	15;"	d	file:
System	test23.c	17;"	d	file:
System	test24.c	30;"	d	file:
System	test25.c	22;"	d	file:
System	test26.c	31;"	d	file:
System	test27.c	19;"	d	file:
System	test28.c	28;"	d	file:
System	test29.c	25;"	d	file:
System	test30.c	25;"	d	file:
System	test31.c	18;"	d	file:
System	test32.c	18;"	d	file:
System	test33.c	18;"	d	file:
System	test34.c	30;"	d	file:
System	test35.c	21;"	d	file:
System	test36.c	18;"	d	file:
System	test38.c	30;"	d	file:
System	test39.c	26;"	d	file:
System	test40.c	18;"	d	file:
TABLE	misc.c	/^} TABLE;$/;"	t	typeref:struct:table	file:
TAB_MASK	tty.h	5;"	d
TAB_SIZE	tty.h	4;"	d
TASK_GATE	protect.h	97;"	d
TASK_PRIVILEGE	protect.h	45;"	d
TASK_Q	const.h	122;"	d
TCF_ACK_TIMER_SET	tcp_int.h	130;"	d
TCF_EMPTY	tcp_int.h	123;"	d
TCF_FIN_RECV	tcp_int.h	125;"	d
TCF_FIN_SENT	tcp_int.h	129;"	d
TCF_INUSE	tcp_int.h	124;"	d
TCF_MORE2WRITE	tcp_int.h	127;"	d
TCF_RCV_PUSH	tcp_int.h	126;"	d
TCF_SEND_ACK	tcp_int.h	128;"	d
TCP0	tcp.h	37;"	d
TCP_ACK_DELAY	tcp.h	29;"	d
TCP_ACK_DELAY	tcp.h	31;"	d
TCP_CONN_NR	tcp_int.h	194;"	d
TCP_DEF_MAX_NO_RETRANS	tcp.h	24;"	d
TCP_DEF_MSS	tcp.h	27;"	d
TCP_DEF_OPT	tcp.h	34;"	d
TCP_DEF_RTT	tcp.h	25;"	d
TCP_DEF_TIME_OUT	tcp.h	23;"	d
TCP_DEF_TOS	tcp.h	21;"	d
TCP_DEF_TTL	tcp.h	22;"	d
TCP_DEF_URG_WND	tcp.h	20;"	d
TCP_DELAY__H	tcp_delay.h	6;"	d
TCP_DEV0	sr.h	15;"	d
TCP_FD_NR	tcp_int.h	193;"	d
TCP_H	tcp.h	6;"	d
TCP_INT_H	tcp_int.h	6;"	d
TCP_MAX_DATAGRAM	tcp.h	9;"	d
TCP_MAX_WND_SIZE	tcp.h	10;"	d
TCP_PORT_NR	tcp_int.h	192;"	d
TCP_PRI_CONN_INUSE	buf.h	22;"	d
TCP_PRI_CONNwoUSER	buf.h	21;"	d
TCP_PRI_FRAG2SEND	buf.h	20;"	d
TCR_0EXTERNAL	dp8390.h	120;"	d
TCR_1EXTERNAL	dp8390.h	121;"	d
TCR_ATD	dp8390.h	122;"	d
TCR_CRC	dp8390.h	116;"	d
TCR_ELC	dp8390.h	117;"	d
TCR_INTERNAL	dp8390.h	119;"	d
TCR_NORMAL	dp8390.h	118;"	d
TCR_OFST	dp8390.h	123;"	d
TCS_CLOSED	tcp_int.h	132;"	d
TCS_CLOSE_WAIT	tcp_int.h	139;"	d
TCS_CLOSING	tcp_int.h	140;"	d
TCS_ESTABLISHED	tcp_int.h	136;"	d
TCS_FIN_WAIT_1	tcp_int.h	137;"	d
TCS_FIN_WAIT_2	tcp_int.h	138;"	d
TCS_LAST_ACK	tcp_int.h	141;"	d
TCS_LISTEN	tcp_int.h	133;"	d
TCS_SYN_RECEIVED	tcp_int.h	134;"	d
TCS_SYN_SENT	tcp_int.h	135;"	d
TCS_TIME_WAIT	tcp_int.h	142;"	d
TEEHEAD	cursesio.c	122;"	d	file:
TEELEFT	cursesio.c	120;"	d	file:
TEENORMAL	cursesio.c	123;"	d	file:
TEERIGHT	cursesio.c	121;"	d	file:
TEST1PATTERN	klib386.s	/^TEST1PATTERN	=	0x55		! memory test pattern 1$/;"	d
TEST1PATTERN	klib88.s	/^TEST1PATTERN	=	0x55	! memory test pattern 1$/;"	d
TEST2PATTERN	klib386.s	/^TEST2PATTERN	=	0xAA		! memory test pattern 2$/;"	d
TEST2PATTERN	klib88.s	/^TEST2PATTERN	=	0xAA	! memory test pattern 2$/;"	d
TFF_CONNECT	tcp_int.h	58;"	d
TFF_CONNECTED	tcp_int.h	64;"	d
TFF_EMPTY	tcp_int.h	53;"	d
TFF_INUSE	tcp_int.h	54;"	d
TFF_IOCTL_IP	tcp_int.h	55;"	d
TFF_IOC_INIT_SP	tcp_int.h	57;"	d
TFF_OPTSET	tcp_int.h	56;"	d
TFF_PUSH_DATA	tcp_int.h	61;"	d
TFF_READ_IP	tcp_int.h	62;"	d
TFF_RECV_URG	tcp_int.h	63;"	d
TFF_WRITE_IP	tcp_int.h	59;"	d
TFF_WR_URG	tcp_int.h	60;"	d
TI	protect.h	62;"	d
TICKS_PER_DAY	boot.h	26;"	d
TIMEOUT	at_wini.c	107;"	d	file:
TIMEOUT	floppy.c	123;"	d	file:
TIMER0	const.h	93;"	d
TIMER2	const.h	94;"	d
TIMER_COUNT	clock.c	63;"	d	file:
TIMER_FREQ	clock.c	64;"	d	file:
TIMER_FREQ	clock.c	70;"	d	file:
TIMER_MODE	const.h	95;"	d
TIME_MAX	loc_time.h	13;"	d
TIME_NEVER	tty.h	88;"	d
TOC_UPTODATE	mcd.c	123;"	d	file:
TOlower	editline.c	/^    TOupper, TOlower$/;"	e	enum:_CASE	file:
TOupper	editline.c	/^    TOupper, TOlower$/;"	e	enum:_CASE	file:
TP	ext_comp.c	434;"	d	file:
TPF_DELAY_TCP	tcp_int.h	29;"	d
TPF_EMPTY	tcp_int.h	22;"	d
TPF_MORE2WRITE	tcp_int.h	28;"	d
TPF_READ_IP	tcp_int.h	24;"	d
TPF_READ_SP	tcp_int.h	25;"	d
TPF_SUSPEND	tcp_int.h	23;"	d
TPF_WRITE_IP	tcp_int.h	26;"	d
TPF_WRITE_SP	tcp_int.h	27;"	d
TPS_EMPTY	tcp_int.h	31;"	d
TPS_ERROR	tcp_int.h	35;"	d
TPS_GETCONF	tcp_int.h	33;"	d
TPS_MAIN	tcp_int.h	34;"	d
TPS_SETPROTO	tcp_int.h	32;"	d
TRACEBIT	const.h	109;"	d
TRACEBIT	const.h	9;"	d
TRACED	mproc.h	51;"	d
TRANS_ST0	floppy.c	61;"	d	file:
TRAP_286_GATE	protect.h	99;"	d
TRIALS	test14.c	10;"	d	file:
TRUE	adder.c	18;"	d	file:
TR_ADDR	system.c	842;"	d	file:
TR_DATA	system.c	843;"	d	file:
TR_PROCNR	system.c	840;"	d	file:
TR_REQUEST	system.c	841;"	d	file:
TR_VLSIZE	system.c	844;"	d	file:
TSR_ABT	dp8390.h	129;"	d
TSR_CDH	dp8390.h	132;"	d
TSR_COL	dp8390.h	128;"	d
TSR_CRS	dp8390.h	130;"	d
TSR_DFR	dp8390.h	127;"	d
TSR_FU	dp8390.h	131;"	d
TSR_OWC	dp8390.h	133;"	d
TSR_PTX	dp8390.h	126;"	d
TSS2_S_SP0	mpx88.s	/^#define TSS2_S_SP0	2$/;"	d
TSS3_S_SP0	mpx386.s	/^#define TSS3_S_SP0	4$/;"	d
TSS_BUSY	protect.h	89;"	d
TSS_INDEX	protect.h	16;"	d
TSS_SELECTOR	protect.h	32;"	d
TSS_TYPE	protect.c	12;"	d	file:
TSS_TYPE	protect.c	15;"	d	file:
TST_CHECK	aha_scsi.c	289;"	d	file:
TST_LUNBUSY	aha_scsi.c	290;"	d	file:
TTYPX_MINOR	tty.c	69;"	d	file:
TTYTAB	getttyent.c	/^static char TTYTAB[]= "\/etc\/ttytab";	\/* The table of terminal devices. *\/$/;"	v	file:
TTY_CLOSED	pty.c	57;"	d	file:
TTY_IN_BYTES	tty.h	3;"	d
TTY_MAJ	ps.c	90;"	d	file:
TTYback	editline.c	182;"	d	file:
TTYbackn	editline.c	/^TTYbackn(n)$/;"	f
TTYflush	editline.c	/^TTYflush()$/;"	f
TTYget	editline.c	/^TTYget()$/;"	f
TTYinfo	editline.c	/^TTYinfo()$/;"	f
TTYput	editline.c	/^TTYput(c)$/;"	f
TTYputs	editline.c	/^TTYputs(p)$/;"	f
TTYrows	editline.c	/^STATIC int		TTYrows;$/;"	v
TTYshow	editline.c	/^TTYshow(c)$/;"	f
TTYspecial	editline.c	/^TTYspecial(c)$/;"	f
TTYstring	editline.c	/^TTYstring(p)$/;"	f
TTYwidth	editline.c	/^STATIC int		TTYwidth;$/;"	v
TT_REBOOT	init.c	/^struct ttyent TT_REBOOT = { "console", "-", REBOOT_CMD, NULL };$/;"	v	typeref:struct:ttyent
TYPE_H	type.h	2;"	d
TYPE_NRST	aha_scsi.c	320;"	d	file:
TYPE_RST	aha_scsi.c	321;"	d	file:
TYPE_SD	aha_scsi.c	319;"	d	file:
TZ_LEN	misc.c	40;"	d	file:
T_STATE	ps.c	166;"	d	file:
Tbase	boot.c	/^u32_t Tbase, Tcount;$/;"	v
Tbase	edparams.c	/^u32_t Tbase, Tcount;$/;"	v
Tcount	boot.c	/^u32_t Tbase, Tcount;$/;"	v
Tcount	edparams.c	/^u32_t Tbase, Tcount;$/;"	v
Thandler	boot.c	/^char *Thandler;$/;"	v
Thandler	edparams.c	/^char *Thandler;$/;"	v
Time	test35.c	27;"	d	file:
Time	test37.c	19;"	d	file:
TimezoneTable	misc.c	/^static TABLE TimezoneTable[] = {$/;"	v	file:
ToLongName	test23.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test24.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test25.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test26.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test27.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test28.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test30.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test31.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test32.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test33.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test36.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test37.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test38.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test39.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongName	test40.c	/^char ToLongName[NAME_MAX + 2];	\/* Name of maximum +1 length *\/$/;"	v
ToLongPath	test23.c	/^char ToLongPath[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
ToLongPath	test24.c	/^char ToLongPath[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
ToLongPath	test25.c	/^char ToLongPath[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
ToLongPath	test26.c	/^char ToLongPath[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
ToLongPath	test27.c	/^char ToLongPath[PATH_MAX + 1];$/;"	v
ToLongPath	test28.c	/^char ToLongPath[PATH_MAX + 1];$/;"	v
ToLongPath	test30.c	/^char ToLongPath[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
ToLongPath	test31.c	/^char ToLongPath[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
ToLongPath	test32.c	/^char ToLongPath[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
ToLongPath	test33.c	/^char ToLongPath[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
ToLongPath	test36.c	/^char ToLongPath[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
ToLongPath	test37.c	/^char ToLongPath[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
ToLongPath	test38.c	/^char ToLongPath[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
ToLongPath	test39.c	/^char ToLongPath[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
ToLongPath	test40.c	/^char ToLongPath[PATH_MAX + 1];	\/* Same for path, both too long *\/$/;"	v
Toc	mcd.c	/^PRIVATE struct cd_toc_entry Toc[MAX_TRACKS];  \/* Buffer for toc *\/$/;"	v	typeref:struct:cd_toc_entry
U	test7.c	27;"	d	file:
UART_FREQ	rs232.c	30;"	d	file:
UART_FREQ	rs232.c	74;"	d	file:
UCHARAT	regexp.c	133;"	d	file:
UCHARAT	regexp.c	135;"	d	file:
UCHARAT	regsub.c	33;"	d	file:
UCHARAT	regsub.c	35;"	d	file:
UDP0	udp.h	15;"	d
UDP_DEF_OPT	udp.h	8;"	d
UDP_DEV0	sr.h	16;"	d
UDP_FD_NR	udp.c	19;"	d	file:
UDP_H	udp.h	6;"	d
UDP_IP_FLAGS	udp.h	12;"	d
UDP_MAX_DATAGRAM	udp.h	9;"	d
UDP_PORT_NR	udp.c	18;"	d	file:
UDP_PRI_EXP_FDBUFS	buf.h	24;"	d
UDP_PRI_FDBUFS	buf.h	25;"	d
UDP_READ_EXP_TIME	udp.h	10;"	d
UDP_TOS	udp.h	11;"	d
UDP_TTL	udp.h	13;"	d
UFF_EMPTY	udp.c	64;"	d	file:
UFF_INUSE	udp.c	65;"	d	file:
UFF_IOCTL_IP	udp.c	66;"	d	file:
UFF_OPTSET	udp.c	69;"	d	file:
UFF_READ_IP	udp.c	67;"	d	file:
UFF_WRITE_IP	udp.c	68;"	d	file:
UMASK	test17.c	44;"	d	file:
UMASK	test18.c	44;"	d	file:
UNCALIBRATED	floppy.c	125;"	d	file:
UNCTL	editline.c	18;"	d	file:
UNKNOWN	adder.c	17;"	d	file:
UNLINK	test17.c	55;"	d	file:
UNLINK	test18.c	55;"	d	file:
UNLOCK	test7.c	26;"	d	file:
UNMETA	editline.c	21;"	d	file:
UNSCHAR	memccpy.c	14;"	d	file:
UNSCHAR	memccpy.c	16;"	d	file:
UNSET	boothead.s	/^	UNSET	= 0		! Must be computed$/;"	d
UPARROW	cursesio.c	102;"	d	file:
UPF_EMPTY	udp.c	34;"	d	file:
UPF_MORE2WRITE	udp.c	40;"	d	file:
UPF_READ_IP	udp.c	37;"	d	file:
UPF_READ_SP	udp.c	38;"	d	file:
UPF_SUSPEND	udp.c	39;"	d	file:
UPF_WRITE_IP	udp.c	35;"	d	file:
UPF_WRITE_SP	udp.c	36;"	d	file:
UPLEFT	cursesio.c	112;"	d	file:
UPLINE	cursesio.c	115;"	d	file:
UPMIDLINE	cursesio.c	116;"	d	file:
UPRIGHT	cursesio.c	111;"	d	file:
UPS_EMPTY	udp.c	42;"	d	file:
UPS_ERROR	udp.c	46;"	d	file:
UPS_GETCONF	udp.c	44;"	d	file:
UPS_MAIN	udp.c	45;"	d	file:
UPS_SETPROTO	udp.c	43;"	d	file:
USER	test17.c	23;"	d	file:
USER	test18.c	24;"	d	file:
USERFUN	boot.c	/^enum whatfun { NOFUN, SELECT, DEFFUN, USERFUN } menufun(environment *e)$/;"	e	enum:whatfun	file:
USERFUN	edparams.c	/^enum whatfun { NOFUN, SELECT, DEFFUN, USERFUN } menufun(environment *e)$/;"	e	enum:whatfun	file:
USER_ID	test17.c	20;"	d	file:
USER_ID	test18.c	21;"	d	file:
USER_PRIVILEGE	protect.h	46;"	d
USER_Q	const.h	124;"	d
USE_BUF	bios_wini.c	29;"	d	file:
USE_BUF	esdi_wini.c	34;"	d	file:
USE_BUF	xt_wini.c	24;"	d	file:
USE_EXP	fphook.c	83;"	d	file:
USE_MALLOCS	buf.c	20;"	d	file:
USE_TABLE	misc.c	88;"	d	file:
UTIME	test17.c	60;"	d	file:
UTIME	test18.c	60;"	d	file:
VD2M1	sinh.c	50;"	d	file:
VECTOR	const.h	71;"	d
VERTLINE	cursesio.c	124;"	d	file:
VIDEO_INDEX	protect.h	19;"	d
VIDEO_SELECTOR	protect.h	35;"	d
VID_ORG	console.c	46;"	d	file:
VVC_ARGS	klib386.s	/^VVC_ARGS	=	4 + 4 + 4 + 4	! 4 + 4 + 4$/;"	d
VVC_ARGS	klib88.s	/^VVC_ARGS	=	2 + 2 + 2 + 2	! 2 + 2 + 2$/;"	d
W	test17.c	38;"	d	file:
W	test18.c	38;"	d	file:
WAITING	mproc.h	46;"	d
WAKEUP	at_wini.c	94;"	d	file:
WAKEUP	floppy.c	97;"	d	file:
WDETH_H	wdeth.h	8;"	d
WET_790	wdeth.c	26;"	d	file:
WET_BRD_16BIT	wdeth.c	24;"	d	file:
WET_ETHERNET	wdeth.c	21;"	d	file:
WET_INTERF_CHIP	wdeth.c	23;"	d	file:
WET_SLT_16BIT	wdeth.c	25;"	d	file:
WET_STARLAN	wdeth.c	22;"	d	file:
WINI_0_PARM_VEC	const.h	75;"	d
WINI_1_PARM_VEC	const.h	76;"	d
WIN_DATA	xt_wini.c	27;"	d	file:
WIN_DMA	xt_wini.c	36;"	d	file:
WIN_ECC_READ	xt_wini.c	50;"	d	file:
WIN_READ	xt_wini.c	47;"	d	file:
WIN_RECALIBRATE	xt_wini.c	45;"	d	file:
WIN_SELECT	xt_wini.c	35;"	d	file:
WIN_SENSE	xt_wini.c	46;"	d	file:
WIN_SPECIFY	xt_wini.c	49;"	d	file:
WIN_STATUS	xt_wini.c	28;"	d	file:
WIN_WRITE	xt_wini.c	48;"	d	file:
WORDS_REVERSED	get_put.h	17;"	d
WORST	regexp.c	148;"	d	file:
WRITE	test17.c	46;"	d	file:
WRITE	test18.c	46;"	d	file:
WRITE	test7.c	25;"	d	file:
WRITEABLE	protect.h	88;"	d
WRITE_PROTECT	floppy.c	66;"	d	file:
WST_BUS	xt_wini.c	31;"	d	file:
WST_BUSY	xt_wini.c	32;"	d	file:
WST_DRQ	xt_wini.c	33;"	d	file:
WST_INPUT	xt_wini.c	30;"	d	file:
WST_IRQ	xt_wini.c	34;"	d	file:
WST_REQ	xt_wini.c	29;"	d	file:
W_STATE	ps.c	163;"	d	file:
XFR_REQ	esdi_wini.c	55;"	d	file:
XOR	installboot.c	34;"	d	file:
XT_WINI_IRQ	const.h	63;"	d
Xchar	get_put.h	11;"	d
Xchar	get_put.h	13;"	d
Xput2	get_put.h	22;"	d
Xput2	get_put.h	26;"	d
Xtable	doscan.c	/^static char	Xtable[NR_CHARS];$/;"	v	file:
YEAR0	loc_time.h	6;"	d
YEARSIZE	loc_time.h	10;"	d
Yanked	editline.c	/^STATIC CHAR		*Yanked;$/;"	v
ZMAP	super.h	50;"	d
Z_STATE	ps.c	162;"	d	file:
ZoneFromTable	misc.c	/^ZoneFromTable(long timezone)$/;"	f	file:
_BREAKCHAR	curspriv.h	8;"	d
_CASE	editline.c	/^typedef enum _CASE {$/;"	g	file:
_CONST	inet_addr.c	35;"	d	file:
_CONST	inet_addr.c	37;"	d	file:
_CONST	res_mkquery.c	53;"	d	file:
_CONST	res_mkquery.c	55;"	d	file:
_CONST	strcasecmp.c	11;"	d	file:
_CONST	strcasecmp.c	13;"	d	file:
_DCCHAR	curspriv.h	9;"	d
_DLCHAR	curspriv.h	10;"	d
_ENDLINE	curspriv.h	3;"	d
_FULLWIN	curspriv.h	4;"	d
_GOCHAR	curspriv.h	11;"	d
_HISTORY	editline.c	/^typedef struct _HISTORY {$/;"	s	file:
_KEYMAP	editline.c	/^typedef struct _KEYMAP {$/;"	s	file:
_MINIX	boot.c	15;"	d	file:
_MINIX	bootimage.c	6;"	d	file:
_MINIX	edparams.c	7;"	d	file:
_MINIX	fs.h	5;"	d
_MINIX	inet.h	10;"	d
_MINIX	installboot.c	8;"	d	file:
_MINIX	kernel.h	5;"	d
_MINIX	mm.h	5;"	d
_MINIX	rawfs.c	7;"	d	file:
_MINIX_SOURCE	ttyslot.c	12;"	d	file:
_NO_CHANGE	curspriv.h	7;"	d
_POSIX_SOURCE	boot.c	14;"	d	file:
_POSIX_SOURCE	bootimage.c	5;"	d	file:
_POSIX_SOURCE	edparams.c	6;"	d	file:
_POSIX_SOURCE	fs.h	4;"	d
_POSIX_SOURCE	installboot.c	7;"	d	file:
_POSIX_SOURCE	kernel.h	4;"	d
_POSIX_SOURCE	mm.h	4;"	d
_POSIX_SOURCE	rawfs.c	6;"	d	file:
_PRINTCHAR	curspriv.h	12;"	d
_PROTOTYPE	FP_types.h	68;"	d
_PROTOTYPE	FP_types.h	70;"	d
_PROTOTYPE	dev.h	/^typedef _PROTOTYPE (void (*dmap_t), (int task, message *m_ptr) );$/;"	t
_PROTOTYPE	i8259.c	/^typedef _PROTOTYPE( void (*vecaddr_t), (void) );$/;"	t	file:
_PROTOTYPE	tty.h	/^typedef _PROTOTYPE( void (*devfun_t), (struct tty *tp) );$/;"	t
_PROTOTYPE	tty.h	/^typedef _PROTOTYPE( void (*devfunarg_t), (struct tty *tp, int c) );$/;"	t
_PROTOTYPE	type.h	/^typedef _PROTOTYPE( int (*irq_handler_t), (int irq) );$/;"	t
_PROTOTYPE	type.h	/^typedef _PROTOTYPE( int (*rdwt_t), (message *m_ptr) );$/;"	t
_PROTOTYPE	type.h	/^typedef _PROTOTYPE( void (*dmaint_t), (void) );$/;"	t
_PROTOTYPE	type.h	/^typedef _PROTOTYPE( void (*watchdog_t), (void) );$/;"	t
_PROTOTYPE	type.h	/^typedef _PROTOTYPE( void task_t, (void) );$/;"	t
_SCROLLWIN	curspriv.h	5;"	d
_STATUS	editline.c	/^typedef enum _STATUS {$/;"	g	file:
_STOPCHAR	curspriv.h	13;"	d
_SUBWIN	curspriv.h	2;"	d
_SYSTEM	fs.h	6;"	d
_SYSTEM	inet.h	11;"	d
_SYSTEM	kernel.h	6;"	d
_SYSTEM	mm.h	6;"	d
_SYSTEM	syslib.h	3;"	d
_TABLE	table.c	5;"	d	file:
__FPTYPES	FP_types.h	26;"	d
__IsNan	isnan.c	/^int __IsNan(double d)$/;"	f
___exit	boothead.s	/^___exit:$/;"	l
___exit	klib386.s	/^___exit:$/;"	l
___exit	klib88.s	/^___exit:$/;"	l
___main	crtso.s	/^___main:				! for GCC$/;"	l
___main	klib386.s	/^___main:$/;"	l
___setjmp	setjmp.s	/^___setjmp:$/;"	l
___sigreturn	__sigreturn.s	/^___sigreturn:$/;"	l
__bad_assertion	assert.c	/^void __bad_assertion(const char *mess) {$/;"	f
__brk	boothead.s	/^__brk:				! __brk is for the standard C compiler$/;"	l
__brksize	brksize.s	/^__brksize: .data4 endbss$/;"	l
__cleanup	fflush.c	/^__cleanup(void)$/;"	f
__ctype	chartab.c	/^char __ctype[] = {$/;"	v
__end	em_end.s	/^__end:$/;"	l
__execve	_exec.c	/^PUBLIC int __execve(path, argv, envp, nargs, nenvps)$/;"	f
__exit	_exit.s	/^__exit:$/;"	l
__exit	boothead.s	/^__exit:$/;"	l
__exit	klib386.s	/^__exit:$/;"	l
__exit	klib88.s	/^__exit:$/;"	l
__fillbuf	fillbuf.c	/^__fillbuf(register FILE *stream)$/;"	f
__flushbuf	flushbuf.c	/^__flushbuf(int c, FILE * stream)$/;"	f
__fptrp	fptrp.s	/^__fptrp:$/;"	l
__funccnt	exit.c	/^int __funccnt = 0;$/;"	v
__functab	exit.c	/^void (*__functab[NEXITS])(void);$/;"	v
__huge_val	hugeval.c	/^__huge_val(void)$/;"	f
__iotab	data.c	/^FILE *__iotab[FOPEN_MAX] = {$/;"	v
__longjmp	setjmp.s	/^__longjmp:$/;"	l
__memcpy	_memmove.s	/^__memcpy:$/;"	l
__memmove	_memmove.s	/^__memmove:$/;"	l
__newsigset	sigmisc.c	/^__newsigset(sigset_t *p)$/;"	f
__oldsigset	sigmisc.c	/^__oldsigset(sigset_t *p)$/;"	f
__penvp	ncrtso.s	/^__penvp:	.data2 0$/;"	l
__receive	_sendrec.s	/^__receive:$/;"	l
__sbrk	boothead.s	/^__sbrk:$/;"	l
__send	_sendrec.s	/^__send:$/;"	l
__sendrec	_sendrec.s	/^__sendrec:$/;"	l
__stb	stb.c	/^__stb(n, f, t)$/;"	f
__stderr	data.c	/^struct __iobuf __stderr = {$/;"	v	typeref:struct:__iobuf
__stdin	data.c	/^struct __iobuf __stdin = {$/;"	v	typeref:struct:__iobuf
__stdout	data.c	/^struct __iobuf __stdout = {$/;"	v	typeref:struct:__iobuf
__strncat	_strncat.s	/^__strncat:$/;"	l
__strncmp	_strncmp.s	/^__strncmp:$/;"	l
__strncpy	_strncpy.s	/^__strncpy:$/;"	l
__strnlen	_strnlen.s	/^__strnlen:$/;"	l
__testsigset	sigmisc.c	/^__testsigset(void) {$/;"	f	file:
_access	access.s	/^_access:$/;"	l
_alarm	alarm.s	/^_alarm:$/;"	l
_alfun	_sleep.c	/^PRIVATE void _alfun(signo)$/;"	f
_alloca	alloca.s	/^_alloca:$/;"	l
_bcmp	bcmp.s	/^_bcmp:$/;"	l
_bcopy	bcopy.s	/^_bcopy:$/;"	l
_bf_bufsize	buf.c	/^PUBLIC size_t _bf_bufsize(acc_ptr)$/;"	f
_bios13	klib386.s	/^_bios13:$/;"	l
_bios13	klib88.s	/^_bios13:			! make a BIOS 0x13 call for disk I\/O$/;"	l
_bootstrap	boothead.s	/^_bootstrap:$/;"	l
_bottom	malloc.c	/^static void *_bottom, *_top, *_empty;$/;"	v	file:
_bounds_check	mpx386.s	/^_bounds_check:$/;"	l
_bounds_check	mpx88.s	/^_bounds_check:$/;"	l
_breakpoint_exception	mpx386.s	/^_breakpoint_exception:$/;"	l
_breakpoint_exception	mpx88.s	/^_breakpoint_exception:$/;"	l
_brk	boothead.s	/^_brk:$/;"	l
_brk	brk.s	/^_brk:$/;"	l
_bzero	bzero.s	/^_bzero:$/;"	l
_calls	exit.c	/^_calls(void)$/;"	f	file:
_cfgetispeed	_cfgetispeed.c	/^speed_t _cfgetispeed(const struct termios *termios_p)$/;"	f
_cfgetispeed	cfgetispeed.s	/^_cfgetispeed:$/;"	l
_cfgetospeed	_cfgetospeed.c	/^speed_t _cfgetospeed(const struct termios *termios_p)$/;"	f
_cfgetospeed	cfgetospeed.s	/^_cfgetospeed:$/;"	l
_cfsetispeed	_cfsetispeed.c	/^int _cfsetispeed(struct termios *termios_p, speed_t speed)$/;"	f
_cfsetispeed	cfsetispeed.s	/^_cfsetispeed:$/;"	l
_cfsetospeed	_cfsetospeed.c	/^int _cfsetospeed(struct termios *termios_p, speed_t speed)$/;"	f
_cfsetospeed	cfsetospeed.s	/^_cfsetospeed:$/;"	l
_chdir	chdir.s	/^_chdir:$/;"	l
_check_mem	klib386.s	/^_check_mem:$/;"	l
_check_mem	klib88.s	/^_check_mem:$/;"	l
_check_rhosts_file	rcmd.c	/^int	_check_rhosts_file = 1;$/;"	v
_checkhost	rcmd.c	/^_checkhost(rhost, lhost, len)$/;"	f	file:
_chmod	chmod.s	/^_chmod:$/;"	l
_chown	chown.s	/^_chown:$/;"	l
_chroot	chroot.s	/^_chroot:$/;"	l
_clean	exit.c	/^int (*_clean)(void) = NULL;$/;"	v
_close	close.s	/^_close:$/;"	l
_closedir	closedir.s	/^_closedir:$/;"	l
_copr_error	mpx386.s	/^_copr_error:$/;"	l
_copr_not_available	mpx386.s	/^_copr_not_available:$/;"	l
_copr_not_available	mpx88.s	/^_copr_not_available:$/;"	l
_copr_seg_overrun	mpx386.s	/^_copr_seg_overrun:$/;"	l
_copr_seg_overrun	mpx88.s	/^_copr_seg_overrun:$/;"	l
_cp_mess	klib386.s	/^_cp_mess:$/;"	l
_cp_mess	klib88.s	/^_cp_mess:$/;"	l
_creat	creat.s	/^_creat:$/;"	l
_cursgraftable	cursesio.c	/^unsigned int _cursgraftable[27] =$/;"	v
_cursident	cursesio.c	/^char _cursident[28] = "+,.-0ahI`fgjklmnopqrstuvwx~";$/;"	v
_cursvar	cursesio.c	/^cursv _cursvar;$/;"	v
_daylight	misc.c	/^int	_daylight = 0;$/;"	v
_days	misc.c	/^const char *_days[] = {$/;"	v
_dbl_ext_cvt	ext_comp.c	/^_dbl_ext_cvt(double value, struct EXTEND *e)$/;"	f
_dev_geometry	boothead.s	/^_dev_geometry:$/;"	l
_disable_irq	klib386.s	/^_disable_irq:$/;"	l
_disable_irq	klib88.s	/^_disable_irq:$/;"	l
_divide_error	mpx386.s	/^_divide_error:$/;"	l
_divide_error	mpx88.s	/^_divide_error:$/;"	l
_doprnt	doprnt.c	/^_doprnt(register const char *fmt, va_list ap, FILE *stream)$/;"	f
_doscan	doscan.c	/^_doscan(register FILE *stream, const char *format, va_list ap)$/;"	f
_double_fault	mpx386.s	/^_double_fault:$/;"	l
_double_fault	mpx88.s	/^_double_fault:$/;"	l
_dst_off	misc.c	/^long	_dst_off = 60 * 60;$/;"	v
_dstget	misc.c	/^_dstget(register struct tm *timep)$/;"	f
_dup	dup.s	/^_dup:$/;"	l
_dup2	dup2.s	/^_dup2:$/;"	l
_dup2	popen.c	/^_dup2(oldd, newd)$/;"	f	file:
_ecvt	ecvt.c	/^_ecvt(long double value, int ndigit, int *decpt, int *sign)$/;"	f
_edata	edata.s	/^_edata:$/;"	l
_empty	malloc.c	/^static void *_bottom, *_top, *_empty;$/;"	v	file:
_enable_irq	klib386.s	/^_enable_irq:$/;"	l
_enable_irq	klib88.s	/^_enable_irq:$/;"	l
_end	end.s	/^_end:$/;"	l
_etext	etext.s	/^_etext:$/;"	l
_ether_NoNsEnSe	ether.h	/^typedef struct in_addr *_ether_NoNsEnSe;$/;"	t	typeref:struct:in_addr
_ether_nOnSeNsE	ether.h	/^typedef struct hostent *_ether_nOnSeNsE;$/;"	t	typeref:struct:hostent
_execl	execl.s	/^_execl:$/;"	l
_execle	execle.s	/^_execle:$/;"	l
_execn	_execn.c	/^PUBLIC int _execn(name)$/;"	f
_execv	execv.s	/^_execv:$/;"	l
_execve	execve.s	/^_execve:$/;"	l
_exit	__exit.c	/^PUBLIC void _exit(status)$/;"	f
_exit	__exit.c	1;"	d	file:
_exit	boothead.s	/^_exit:$/;"	l
_exit	crypt.c	13;"	d	file:
_exit	klib386.s	/^_exit:$/;"	l
_exit	klib88.s	/^_exit:$/;"	l
_ext_dbl_cvt	ext_comp.c	/^_ext_dbl_cvt(struct EXTEND *e)$/;"	f
_ext_str_cvt	ext_comp.c	/^_ext_str_cvt(struct EXTEND *e, int ndigit, int *decpt, int *sign, int ecvtflag)$/;"	f
_f_print	fltpr.c	/^_f_print(va_list *ap, int flags, char *s, char c, int precision)$/;"	f
_f_print	fphook.c	/^_f_print(va_list *ap, int flags, char *s, char c, int precision)$/;"	f
_fcntl	fcntl.s	/^_fcntl:$/;"	l
_fcvt	ecvt.c	/^_fcvt(long double value, int ndigit, int *decpt, int *sign)$/;"	f
_fork	fork.s	/^_fork:$/;"	l
_fp_hook	fltpr.c	/^int _fp_hook = 1;$/;"	v
_fp_hook	fphook.c	/^int _fp_hook = 1;$/;"	v
_fpathconf	fpathconf.s	/^_fpathconf:$/;"	l
_frexp	frexp.s	/^_frexp:$/;"	l
_fstat	fstat.s	/^_fstat:$/;"	l
_gcvt	fphook.c	/^_gcvt(long double value, int ndigit, char *s, int flags)$/;"	f	file:
_general_protection	mpx386.s	/^_general_protection:$/;"	l
_general_protection	mpx88.s	/^_general_protection:$/;"	l
_get_bus	boothead.s	/^_get_bus:$/;"	l
_get_ext_memsize	boothead.s	/^_get_ext_memsize:$/;"	l
_get_memsize	boothead.s	/^_get_memsize:$/;"	l
_get_tick	boothead.s	/^_get_tick:$/;"	l
_get_video	boothead.s	/^_get_video:$/;"	l
_get_word	boothead.s	/^_get_word:$/;"	l
_getchar	boothead.s	/^_getchar:$/;"	l
_getcwd	getcwd.s	/^_getcwd:$/;"	l
_getegid	getegid.s	/^_getegid:$/;"	l
_geteuid	geteuid.s	/^_geteuid:$/;"	l
_getgid	getgid.s	/^_getgid:$/;"	l
_getgroups	getgroups.s	/^_getgroups:$/;"	l
_getpgrp	getpgrp.s	/^_getpgrp:$/;"	l
_getpid	getpid.s	/^_getpid:$/;"	l
_getppid	getppid.s	/^_getppid:$/;"	l
_getprocessor	getprocessor.s	/^_getprocessor:$/;"	l
_getuid	getuid.s	/^_getuid:$/;"	l
_hwint00	mpx386.s	/^_hwint00:		! Interrupt routine for irq 0 (the clock).$/;"	l
_hwint00	mpx88.s	/^_hwint00:		! Interrupt routine for irq 0 (the clock).$/;"	l
_hwint01	mpx386.s	/^_hwint01:		! Interrupt routine for irq 1 (keyboard)$/;"	l
_hwint01	mpx88.s	/^_hwint01:		! Interrupt routine for irq 1 (keyboard)$/;"	l
_hwint02	mpx386.s	/^_hwint02:		! Interrupt routine for irq 2 (cascade!)$/;"	l
_hwint02	mpx88.s	/^_hwint02:		! Interrupt routine for irq 2 (cascade!)$/;"	l
_hwint03	mpx386.s	/^_hwint03:		! Interrupt routine for irq 3 (second serial)$/;"	l
_hwint03	mpx88.s	/^_hwint03:		! Interrupt routine for irq 3 (second serial)$/;"	l
_hwint04	mpx386.s	/^_hwint04:		! Interrupt routine for irq 4 (first serial)$/;"	l
_hwint04	mpx88.s	/^_hwint04:		! Interrupt routine for irq 4 (first serial)$/;"	l
_hwint05	mpx386.s	/^_hwint05:		! Interrupt routine for irq 5 (XT winchester)$/;"	l
_hwint05	mpx88.s	/^_hwint05:		! Interrupt routine for irq 5 (XT winchester)$/;"	l
_hwint06	mpx386.s	/^_hwint06:		! Interrupt routine for irq 6 (floppy)$/;"	l
_hwint06	mpx88.s	/^_hwint06:		! Interrupt routine for irq 6 (floppy)$/;"	l
_hwint07	mpx386.s	/^_hwint07:		! Interrupt routine for irq 7 (printer)$/;"	l
_hwint07	mpx88.s	/^_hwint07:		! Interrupt routine for irq 7 (printer)$/;"	l
_hwint08	mpx386.s	/^_hwint08:		! Interrupt routine for irq 8 (realtime clock)$/;"	l
_hwint08	mpx88.s	/^_hwint08:		! Interrupt routine for irq 8 (realtime clock)$/;"	l
_hwint09	mpx386.s	/^_hwint09:		! Interrupt routine for irq 9 (irq 2 redirected)$/;"	l
_hwint09	mpx88.s	/^_hwint09:		! Interrupt routine for irq 9 (irq 2 redirected)$/;"	l
_hwint10	mpx386.s	/^_hwint10:		! Interrupt routine for irq 10$/;"	l
_hwint10	mpx88.s	/^_hwint10:		! Interrupt routine for irq 10$/;"	l
_hwint11	mpx386.s	/^_hwint11:		! Interrupt routine for irq 11$/;"	l
_hwint11	mpx88.s	/^_hwint11:		! Interrupt routine for irq 11$/;"	l
_hwint12	mpx386.s	/^_hwint12:		! Interrupt routine for irq 12$/;"	l
_hwint12	mpx88.s	/^_hwint12:		! Interrupt routine for irq 12$/;"	l
_hwint13	mpx386.s	/^_hwint13:		! Interrupt routine for irq 13 (FPU exception)$/;"	l
_hwint13	mpx88.s	/^_hwint13:		! Interrupt routine for irq 13 (FPU exception)$/;"	l
_hwint14	mpx386.s	/^_hwint14:		! Interrupt routine for irq 14 (AT winchester)$/;"	l
_hwint14	mpx88.s	/^_hwint14:		! Interrupt routine for irq 14 (AT winchester)$/;"	l
_hwint15	mpx386.s	/^_hwint15:		! Interrupt routine for irq 15$/;"	l
_hwint15	mpx88.s	/^_hwint15:		! Interrupt routine for irq 15$/;"	l
_i_compute	icompute.c	/^_i_compute(unsigned long val, int base, char *s, int nrdigits)$/;"	f
_idle_task	mpx386.s	/^_idle_task:			! executed when there is no work$/;"	l
_idle_task	mpx88.s	/^_idle_task:			! executed when there is no work$/;"	l
_in_byte	klib386.s	/^_in_byte:$/;"	l
_in_byte	klib88.s	/^_in_byte:$/;"	l
_in_word	klib386.s	/^_in_word:$/;"	l
_in_word	klib88.s	/^_in_word:$/;"	l
_inb	iolib.s	/^_inb:$/;"	l
_index	index.s	/^_index:$/;"	l
_int00	mpx88.s	/^_int00:				! interrupt through vector 0$/;"	l
_int01	mpx88.s	/^_int01:				! interrupt through vector 1, etc$/;"	l
_int02	mpx88.s	/^_int02:$/;"	l
_int03	mpx88.s	/^_int03:$/;"	l
_int04	mpx88.s	/^_int04:$/;"	l
_int05	mpx88.s	/^_int05:$/;"	l
_int06	mpx88.s	/^_int06:$/;"	l
_int07	mpx88.s	/^_int07:$/;"	l
_intr_disable	iolib.s	/^_intr_disable:$/;"	l
_intr_enable	iolib.s	/^_intr_enable:$/;"	l
_inval_opcode	mpx386.s	/^_inval_opcode:$/;"	l
_inval_opcode	mpx88.s	/^_inval_opcode:$/;"	l
_inval_tss	mpx386.s	/^_inval_tss:$/;"	l
_inval_tss	mpx88.s	/^_inval_tss:$/;"	l
_inw	iolib.s	/^_inw:$/;"	l
_ioctl	ioctl.s	/^_ioctl:$/;"	l
_isatty	isatty.s	/^_isatty:$/;"	l
_kill	kill.s	/^_kill:$/;"	l
_lc	setlocale.c	/^struct lconv _lc;$/;"	v	typeref:struct:lconv
_level0	klib386.s	/^_level0:$/;"	l
_level0	klib88.s	/^_level0:$/;"	l
_level0_call	mpx386.s	/^_level0_call:$/;"	l
_level0_call	mpx88.s	/^_level0_call:$/;"	l
_link	link.s	/^_link:$/;"	l
_loadname	loadname.c	/^PUBLIC void _loadname(name, msgptr)$/;"	f
_lock	klib386.s	/^_lock:$/;"	l
_lock	klib88.s	/^_lock:$/;"	l
_longjmp	setjmp.s	/^_longjmp:$/;"	l
_lseed	lrand.c	/^PRIVATE long _lseed = 1L;$/;"	v
_lseek	lseek.s	/^_lseek:$/;"	l
_main	bootblock.s	/^_main:$/;"	l
_main	extboot.s	/^_main:$/;"	l
_main	masterboot.s	/^_main:$/;"	l
_mem_rdw	klib386.s	/^_mem_rdw:$/;"	l
_mem_rdw	klib88.s	/^_mem_rdw:$/;"	l
_mem_vid_copy	klib386.s	/^_mem_vid_copy:$/;"	l
_mem_vid_copy	klib88.s	/^_mem_vid_copy:$/;"	l
_memchr	memchr.s	/^_memchr:$/;"	l
_memcmp	memcmp.s	/^_memcmp:$/;"	l
_memcpy	memcpy.s	/^_memcpy:$/;"	l
_memmove	memmove.s	/^_memmove:$/;"	l
_memset	memset.s	/^_memset:$/;"	l
_minix	boothead.s	/^_minix:$/;"	l
_mkdir	mkdir.s	/^_mkdir:$/;"	l
_mkfifo	mkfifo.s	/^_mkfifo:$/;"	l
_mknod	mknod.s	/^_mknod:$/;"	l
_mktemp	mktemp.s	/^_mktemp:$/;"	l
_modf	modf.s	/^_modf:$/;"	l
_mon2abs	boothead.s	/^_mon2abs:$/;"	l
_monitor	klib386.s	/^_monitor:$/;"	l
_monitor	klib88.s	/^_monitor:$/;"	l
_months	misc.c	/^const char *_months[] = {$/;"	v
_mount	mount.s	/^_mount:$/;"	l
_nmi	mpx386.s	/^_nmi:$/;"	l
_nmi	mpx88.s	/^_nmi:$/;"	l
_open	open.s	/^_open:$/;"	l
_opendir	opendir.s	/^_opendir:$/;"	l
_orig_tty	cursesio.c	/^struct termios _orig_tty, _tty;$/;"	v	typeref:struct:termios
_out_byte	klib386.s	/^_out_byte:$/;"	l
_out_byte	klib88.s	/^_out_byte:$/;"	l
_out_word	klib386.s	/^_out_word:$/;"	l
_out_word	klib88.s	/^_out_word:$/;"	l
_outb	iolib.s	/^_outb:$/;"	l
_outw	iolib.s	/^_outw:$/;"	l
_overflow	mpx386.s	/^_overflow:$/;"	l
_overflow	mpx88.s	/^_overflow:$/;"	l
_p_s_call	mpx386.s	/^_p_s_call:$/;"	l
_p_s_call	mpx88.s	/^_p_s_call:$/;"	l
_page_fault	mpx386.s	/^_page_fault:$/;"	l
_pathconf	pathconf.s	/^_pathconf:$/;"	l
_pause	pause.s	/^_pause:$/;"	l
_peekchar	boothead.s	/^_peekchar:$/;"	l
_pfloat	fphook.c	/^_pfloat(long double r, register char *s, int n, int flags)$/;"	f	file:
_phys_copy	klib386.s	/^_phys_copy:$/;"	l
_phys_copy	klib88.s	/^_phys_copy:$/;"	l
_pipe	pipe.s	/^_pipe:$/;"	l
_port_read	klib386.s	/^_port_read:$/;"	l
_port_read	klib88.s	/^_port_read:$/;"	l
_port_read_byte	klib386.s	/^_port_read_byte:$/;"	l
_port_read_byte	klib88.s	/^_port_read_byte:$/;"	l
_port_write	klib386.s	/^_port_write:$/;"	l
_port_write	klib88.s	/^_port_write:$/;"	l
_port_write_byte	klib386.s	/^_port_write_byte:$/;"	l
_port_write_byte	klib88.s	/^_port_write_byte:$/;"	l
_proto_stayopen	getprotoent.c	/^int _proto_stayopen;$/;"	v
_pscien	fphook.c	/^_pscien(long double r, register char *s, int n, int flags)$/;"	f	file:
_ptrace	ptrace.s	/^_ptrace:$/;"	l
_put_word	boothead.s	/^_put_word:$/;"	l
_putc	boothead.s	/^_putc:$/;"	l
_putchar	boothead.s	/^_putchar:$/;"	l
_putk	boothead.s	/^_putk:	mov	bx, sp$/;"	l
_raw_copy	boothead.s	/^_raw_copy:$/;"	l
_read	read.s	/^_read:$/;"	l
_readdir	readdir.s	/^_readdir:$/;"	l
_readsectors	boothead.s	/^_readsectors:$/;"	l
_reboot	reboot.s	/^_reboot:$/;"	l
_relocate	boothead.s	/^_relocate:$/;"	l
_rename	rename.s	/^_rename:$/;"	l
_rep_inb	iolib.s	/^_rep_inb:$/;"	l
_rep_inw	iolib.s	/^_rep_inw:$/;"	l
_rep_outb	iolib.s	/^_rep_outb:$/;"	l
_rep_outw	iolib.s	/^_rep_outw:$/;"	l
_res	res_init.c	/^struct state _res;$/;"	v	typeref:struct:state
_res_close	res_send.c	/^_res_close()$/;"	f
_reset	klib386.s	/^_reset:$/;"	l
_reset	klib88.s	/^_reset:$/;"	l
_reset_video	boothead.s	/^_reset_video:$/;"	l
_restart	mpx386.s	/^_restart:$/;"	l
_restart	mpx88.s	/^_restart:$/;"	l
_rewinddir	rewinddir.s	/^_rewinddir:$/;"	l
_rindex	rindex.s	/^_rindex:$/;"	l
_rmdir	rmdir.s	/^_rmdir:$/;"	l
_s_call	mpx386.s	/^_s_call:$/;"	l
_s_call	mpx88.s	/^_s_call:			! System calls are vectored here.$/;"	l
_sbrk	boothead.s	/^_sbrk:$/;"	l
_sbrk	sbrk.s	/^_sbrk:$/;"	l
_seekdir	seekdir.s	/^_seekdir:$/;"	l
_segment_not_present	mpx386.s	/^_segment_not_present:$/;"	l
_segment_not_present	mpx88.s	/^_segment_not_present:$/;"	l
_serv_stayopen	getservent.c	/^int _serv_stayopen;$/;"	v
_setgid	setgid.s	/^_setgid:$/;"	l
_setsid	setsid.s	/^_setsid:$/;"	l
_setuid	setuid.s	/^_setuid:$/;"	l
_sigaction	sigaction.s	/^_sigaction:$/;"	l
_sigaddset	sigaddset.s	/^_sigaddset:$/;"	l
_sigdelset	sigdelset.s	/^_sigdelset:$/;"	l
_sigemptyset	sigemptyset.s	/^_sigemptyset:$/;"	l
_sigfillset	sigfillset.s	/^_sigfillset:$/;"	l
_sigismember	sigismember.s	/^_sigismember:$/;"	l
_sigpending	sigpending.s	/^_sigpending:$/;"	l
_sigprocmask	sigprocmask.s	/^_sigprocmask:$/;"	l
_sigreturn	sigreturn.s	/^_sigreturn:$/;"	l
_sigsuspend	sigsuspend.s	/^_sigsuspend:$/;"	l
_single_step_exception	mpx386.s	/^_single_step_exception:$/;"	l
_single_step_exception	mpx88.s	/^_single_step_exception:$/;"	l
_sizes	mpx386.s	/^_sizes:				! sizes of kernel, mm, fs filled in by boot$/;"	l
_sizes	mpx88.s	/^_sizes:				! sizes of kernel, mm, fs filled in by boot$/;"	l
_sleep	sleep.s	/^_sleep:$/;"	l
_stack_exception	mpx386.s	/^_stack_exception:$/;"	l
_stack_exception	mpx88.s	/^_stack_exception:$/;"	l
_stat	stat.s	/^_stat:$/;"	l
_stime	stime.s	/^_stime:$/;"	l
_str_ext_cvt	ext_comp.c	/^_str_ext_cvt(const char *s, char **ss, struct EXTEND *e)$/;"	f
_strcat	strcat.s	/^_strcat:$/;"	l
_strchr	strchr.s	/^_strchr:$/;"	l
_strcmp	strcmp.s	/^_strcmp:$/;"	l
_strcpy	strcpy.s	/^_strcpy:$/;"	l
_strlen	strlen.s	/^_strlen:$/;"	l
_strncat	strncat.s	/^_strncat:$/;"	l
_strncmp	strncmp.s	/^_strncmp:$/;"	l
_strncpy	strncpy.s	/^_strncpy:$/;"	l
_strnlen	strnlen.s	/^_strnlen:$/;"	l
_strrchr	strrchr.s	/^_strrchr:$/;"	l
_sync	sync.s	/^_sync:$/;"	l
_sys_errlist	errlist.c	/^const char *_sys_errlist[] = {$/;"	v
_sys_nerr	errlist.c	/^const int _sys_nerr = sizeof(_sys_errlist) \/ sizeof(_sys_errlist[0]);$/;"	v
_syscall	syscall.c	/^PUBLIC int _syscall(who, syscallnr, msgptr)$/;"	f
_taskcall	taskcall.c	/^PUBLIC int _taskcall(who, syscallnr, msgptr)$/;"	f
_tcdrain	tcdrain.s	/^_tcdrain:$/;"	l
_tcflow	tcflow.s	/^_tcflow:$/;"	l
_tcflush	tcflush.s	/^_tcflush:$/;"	l
_tcgetattr	tcgetattr.s	/^_tcgetattr:$/;"	l
_tcsendbreak	tcsendbreak.s	/^_tcsendbreak:$/;"	l
_tcsetattr	tcsetattr.s	/^_tcsetattr:$/;"	l
_time	time.s	/^_time:$/;"	l
_times	times.s	/^_times:$/;"	l
_timezone	misc.c	/^long	_timezone = 0;$/;"	v
_tmp	hton.c	/^u16_t _tmp;$/;"	v
_tmp_l	hton.c	/^u32_t _tmp_l;$/;"	v
_top	malloc.c	/^static void *_bottom, *_top, *_empty;$/;"	v	file:
_tty	cursesio.c	/^struct termios _orig_tty, _tty;$/;"	v	typeref:struct:
_tzname	misc.c	/^char	*_tzname[2] = {ntstr, dststr};$/;"	v
_tzset	misc.c	/^_tzset(void)$/;"	f
_umask	umask.s	/^_umask:$/;"	l
_umount	umount.s	/^_umount:$/;"	l
_uname	uname.s	/^_uname:$/;"	l
_unlink	unlink.s	/^_unlink:$/;"	l
_unlock	klib386.s	/^_unlock:$/;"	l
_unlock	klib88.s	/^_unlock:$/;"	l
_utime	utime.s	/^_utime:$/;"	l
_validuser	rcmd.c	/^int _validuser(hostf, rhost, luser, ruser, baselen)$/;"	f
_vec2abs	boothead.s	/^_vec2abs:$/;"	l
_vid_vid_copy	klib386.s	/^_vid_vid_copy:$/;"	l
_vid_vid_copy	klib88.s	/^_vid_vid_copy:$/;"	l
_wait	wait.s	/^_wait:$/;"	l
_waitpid	waitpid.s	/^_waitpid:$/;"	l
_write	write.s	/^_write:$/;"	l
_writesectors	boothead.s	/^_writesectors:$/;"	l
_ytab	misc.c	/^const int _ytab[2][12] = {$/;"	v
a0	type.h	/^  reg_t a0;$/;"	m	struct:stackframe_s
a1	type.h	/^  reg_t a1;$/;"	m	struct:stackframe_s
a2	type.h	/^  reg_t a2;$/;"	m	struct:stackframe_s
a2l	boot.c	/^long a2l(char *a)$/;"	f
a2l	edparams.c	/^long a2l(char *a)$/;"	f
a2x	boot.c	/^unsigned a2x(char *a)$/;"	f
a3	type.h	/^  reg_t a3;$/;"	m	struct:stackframe_s
a4	type.h	/^  reg_t a4;$/;"	m	struct:stackframe_s
a46_data	arp.c	/^		} a46_data;$/;"	m	union:arp46::__anon15	typeref:struct:arp46::__anon15::__anon16	file:
a46_data	arp.c	/^	} a46_data;$/;"	m	struct:arp46	typeref:union:arp46::__anon15	file:
a46_dstaddr	arp.c	/^	ether_addr_t a46_dstaddr;$/;"	m	struct:arp46	file:
a46_dummy	arp.c	/^		char    a46_dummy[ETH_MIN_PACK_SIZE-ETH_HDR_SIZE];$/;"	m	union:arp46::__anon15	file:
a46_ethtype	arp.c	/^	ether_type_t a46_ethtype;$/;"	m	struct:arp46	file:
a46_hdr	arp.c	57;"	d	file:
a46_hln	arp.c	59;"	d	file:
a46_op	arp.c	61;"	d	file:
a46_pln	arp.c	60;"	d	file:
a46_pro	arp.c	58;"	d	file:
a46_sha	arp.c	62;"	d	file:
a46_spa	arp.c	63;"	d	file:
a46_srcaddr	arp.c	/^	ether_addr_t a46_srcaddr;$/;"	m	struct:arp46	file:
a46_tha	arp.c	64;"	d	file:
a46_tpa	arp.c	65;"	d	file:
a5	type.h	/^  reg_t a5;$/;"	m	struct:stackframe_s
a_bss	boothead.s	/^	a_bss	    =	    16$/;"	d
a_data	boothead.s	/^	a_data	    =	    12$/;"	d
a_dindir	rawfs.c	/^static block_t a_indir, a_dindir;	\/* Addresses of the indirects. *\/$/;"	v	file:
a_flags	boothead.s	/^	a_flags	    =	     2	! From a.out.h, struct exec$/;"	d
a_hdr	arp.c	/^			u16_t a_hdr, a_pro;$/;"	m	struct:arp46::__anon15::__anon16	file:
a_hln	arp.c	/^			u8_t a_hln, a_pln;$/;"	m	struct:arp46::__anon15::__anon16	file:
a_indir	rawfs.c	/^static block_t a_indir, a_dindir;	\/* Addresses of the indirects. *\/$/;"	v	file:
a_op	arp.c	/^			u16_t a_op;$/;"	m	struct:arp46::__anon15::__anon16	file:
a_pln	arp.c	/^			u8_t a_hln, a_pln;$/;"	m	struct:arp46::__anon15::__anon16	file:
a_pro	arp.c	/^			u16_t a_hdr, a_pro;$/;"	m	struct:arp46::__anon15::__anon16	file:
a_sha	arp.c	/^			ether_addr_t a_sha;$/;"	m	struct:arp46::__anon15::__anon16	file:
a_spa	arp.c	/^			u8_t a_spa[4];$/;"	m	struct:arp46::__anon15::__anon16	file:
a_text	boothead.s	/^	a_text	    =	     8$/;"	d
a_tha	arp.c	/^			ether_addr_t a_tha;$/;"	m	struct:arp46::__anon15::__anon16	file:
a_total	boothead.s	/^	a_total	    =	    24$/;"	d
a_tpa	arp.c	/^			u8_t a_tpa[4];$/;"	m	struct:arp46::__anon15::__anon16	file:
aa	test19.c	/^char aa[100];$/;"	v
abort	abort.c	/^abort(void)$/;"	f
abort	inet.c	/^void abort()$/;"	f
abs	abs.c	/^abs(register int i)$/;"	f
abs2seg	boothead.s	/^abs2seg:			! Translate the 32 bit address dx-ax to dx:ax$/;"	l
ac	gethnmadr.c	/^    char ac;$/;"	m	union:align	file:
ac_eth_port	arp.c	/^	int ac_eth_port;$/;"	m	struct:arp_cache	file:
ac_ethaddr	arp.c	/^	ether_addr_t ac_ethaddr;$/;"	m	struct:arp_cache	file:
ac_expire	arp.c	/^	time_t ac_expire;$/;"	m	struct:arp_cache	file:
ac_flags	arp.c	/^	int ac_flags;$/;"	m	struct:arp_cache	file:
ac_ipaddr	arp.c	/^	ipaddr_t ac_ipaddr;$/;"	m	struct:arp_cache	file:
ac_lastuse	arp.c	/^	time_t ac_lastuse;$/;"	m	struct:arp_cache	file:
ac_type	arp.c	/^	int ac_type;$/;"	m	struct:arp_cache	file:
acc	buf.h	/^typedef struct acc$/;"	s
acc_buffer	buf.h	/^	buf_t *acc_buffer;$/;"	m	struct:acc
acc_ext_link	buf.h	/^	struct acc *acc_next, *acc_ext_link;$/;"	m	struct:acc	typeref:struct:acc::
acc_free_list	buf.c	/^PRIVATE acc_t *acc_free_list;$/;"	v
acc_length	buf.h	/^	int acc_offset, acc_length;$/;"	m	struct:acc
acc_linkC	buf.h	/^	int acc_linkC;$/;"	m	struct:acc
acc_next	buf.h	/^	struct acc *acc_next, *acc_ext_link;$/;"	m	struct:acc	typeref:struct:acc::acc
acc_offset	buf.h	/^	int acc_offset, acc_length;$/;"	m	struct:acc
acc_t	buf.h	/^} acc_t;$/;"	t	typeref:struct:acc
acc_time	param.h	2;"	d
accept_line	editline.c	/^accept_line()$/;"	f
access	_access.c	/^PUBLIC int access(name, mode)$/;"	f
access	_access.c	2;"	d	file:
access	_mktemp.c	4;"	d	file:
access	type.h	/^  u8_t access;			\/* |P|DL|1|X|E|R|A| *\/$/;"	m	struct:segdesc_s
access_standards	test18.c	/^void access_standards()$/;"	f
accessors	buf.c	/^PRIVATE acc_t *accessors;$/;"	v
accessors	buf.c	/^PRIVATE acc_t accessors[ACC_NR];$/;"	v
accum_count	type.h	/^  unsigned long accum_count;	\/* accumulated clock ticks *\/$/;"	m	struct:milli_state
ack_to	tcp_send.c	/^PRIVATE void ack_to(conn, timer)$/;"	f
acos	asin.c	/^acos(double x)$/;"	f
activate	boot.c	/^int activate;$/;"	v
add	trp.s	/^add bx,dx$/;"	l
add	trp.s	/^add dx,'0'$/;"	l
add_code	aha_scsi.c	/^    byte add_code;		\/* additional sense code *\/$/;"	m	struct:__anon8	file:
add_exponent	ext_comp.c	/^add_exponent(struct EXTEND *e, int exp)$/;"	f	file:
add_ext	add_ext.c	/^add_ext(e1,e2)$/;"	f
add_ext	ext_comp.c	/^add_ext(struct EXTEND *e1, struct EXTEND *e2, struct EXTEND *e3)$/;"	f	file:
add_history	editline.c	/^add_history(p)$/;"	f
add_qual	aha_scsi.c	/^    byte add_qual;		\/* additional sense code qualifier *\/$/;"	m	struct:__anon8	file:
addparm	boot.c	/^void addparm(char *n)$/;"	f
addparm	edparams.c	/^void addparm(char *n)$/;"	f
addpath	_getcwd.c	/^static int addpath(const char *path, char **ap, const char *entry)$/;"	f	file:
addptr	boot.c	/^char *addptr;$/;"	v
addptr	edparams.c	/^char *addptr;$/;"	v
addr	boot.c	/^	u32_t	addr;$/;"	m	struct:cache_entry	file:
addr	param.h	3;"	d
addr	test9.c	/^ addr()$/;"	f
addr_8250	rs232.c	/^PRIVATE port_t addr_8250[] = {$/;"	v
addrcntl	aha_scsi.c	/^    byte addrcntl;		\/* Address and Direction Control: *\/$/;"	m	struct:__anon10	file:
addresses	bootblock.s	/^addresses:$/;"	l
addrread	ps.c	/^int addrread(fd, base, addr, buf, nbytes)$/;"	f
adf4	adf4.c	/^adf4(s2,s1)$/;"	f
adf8	adf8.c	/^adf8(s2,s1)$/;"	f
adjust	break.c	/^PUBLIC int adjust(rmp, data_clicks, sp)$/;"	f
adjust	extboot.s	/^adjust:	mov	di, #BUFFER+extbase	! Adjust ext part by extended base$/;"	l
adjx	extboot.s	/^adjx:	mov	bx, (di)$/;"	l
advance	path.c	/^PUBLIC struct inode *advance(dirp, string)$/;"	f
ae	cursesio.c	/^char *ae;			\/* alternative charset end *\/$/;"	v
aha_basereg	aha_scsi.c	/^PRIVATE int aha_basereg;	\/* base I\/O register *\/$/;"	v
aha_command	aha_scsi.c	/^PRIVATE void aha_command(outlen, outptr, inlen, inptr)$/;"	f
aha_irq	aha_scsi.c	/^PRIVATE int aha_irq;		\/* configured IRQ *\/$/;"	v
aha_model	aha_scsi.c	/^PRIVATE int aha_model;		\/* board model *\/$/;"	v
aha_reset	aha_scsi.c	/^PRIVATE int aha_reset()$/;"	f
aha_scsi_task	aha_scsi.c	/^PUBLIC void aha_scsi_task()$/;"	f
al	gethnmadr.c	/^    long al;$/;"	m	union:align	file:
alarm	_alarm.c	/^PUBLIC unsigned int alarm(sec)$/;"	f
alarm	_alarm.c	2;"	d	file:
alarm	asynchio.c	9;"	d	file:
alarm_handler	res_send.c	/^static void alarm_handler(sig)$/;"	f	file:
alarms	test5.c	/^_VOLATILE int childsigs, parsigs, alarms;$/;"	v
align	bootimage.c	115;"	d	file:
align	gethnmadr.c	/^typedef union align {$/;"	u	file:
align	installboot.c	176;"	d	file:
align	proc.h	/^  int align;			\/* make the struct size a multiple of 4 *\/$/;"	m	struct:proc
align2	proc.h	/^  int align2;			\/* make the struct size a multiple of 4 *\/$/;"	m	struct:proc
align_t	gethnmadr.c	/^} align_t;$/;"	t	typeref:union:align	file:
alloc	edparams.c	/^void *alloc(void *m, size_t n)$/;"	f
alloc_bit	super.c	/^PUBLIC bit_t alloc_bit(sp, map, origin)$/;"	f
alloc_inode	inode.c	/^PUBLIC struct inode *alloc_inode(dev, bits)$/;"	f
alloc_mem	alloc.c	/^PUBLIC phys_clicks alloc_mem(clicks)$/;"	f
alloc_segments	system.c	/^PUBLIC void alloc_segments(rp)$/;"	f
alloc_zone	cache.c	/^PUBLIC zone_t alloc_zone(dev, z)$/;"	f
alt1	keyboard.c	/^PRIVATE int alt1;		\/* left alt key state *\/$/;"	v
alt2	keyboard.c	/^PRIVATE int alt2;		\/* right alt key state *\/$/;"	v
and	trp.s	/^and dx,#7$/;"	l
ansi_colors	console.c	/^PRIVATE int ansi_colors[8] = {0, 4, 2, 6, 1, 5, 3, 7};$/;"	v
any	getprotoent.c	/^any(cp, match)$/;"	f	file:
any	getservent.c	/^any(cp, match)$/;"	f	file:
any_key	boothead.s	/^any_key:$/;"	l
ap_eth_fd	arp.c	/^	int ap_eth_fd;$/;"	m	struct:arp_port	file:
ap_eth_port	arp.c	/^	int ap_eth_port;$/;"	m	struct:arp_port	file:
ap_ethaddr	arp.c	/^	ether_addr_t ap_ethaddr;$/;"	m	struct:arp_port	file:
ap_flags	arp.c	/^	int ap_flags;$/;"	m	struct:arp_port	file:
ap_ipaddr	arp.c	/^	ipaddr_t ap_ipaddr;$/;"	m	struct:arp_port	file:
ap_rarp_func	arp.c	/^	rarp_func_t ap_rarp_func;$/;"	m	struct:arp_port	file:
ap_rarp_ref	arp.c	/^	int ap_rarp_ref;$/;"	m	struct:arp_port	file:
ap_rarp_retries	arp.c	/^	int ap_rarp_retries;$/;"	m	struct:arp_port	file:
ap_req_count	arp.c	/^	int ap_req_count;$/;"	m	struct:arp_port	file:
ap_req_func	arp.c	/^	arp_req_func_t ap_req_func;$/;"	m	struct:arp_port	file:
ap_req_ipaddr	arp.c	/^	ipaddr_t ap_req_ipaddr;$/;"	m	struct:arp_port	file:
ap_req_ref	arp.c	/^	int ap_req_ref;$/;"	m	struct:arp_port	file:
ap_state	arp.c	/^	int ap_state;$/;"	m	struct:arp_port	file:
ap_timer	arp.c	/^	timer_t ap_timer;$/;"	m	struct:arp_port	file:
ap_write_code	arp.c	/^	int ap_write_code;$/;"	m	struct:arp_port	file:
ap_write_ethaddr	arp.c	/^	ether_addr_t ap_write_ethaddr;$/;"	m	struct:arp_port	file:
ap_write_ipaddr	arp.c	/^	ipaddr_t ap_write_ipaddr;$/;"	m	struct:arp_port	file:
arg	boot.h	/^	char	*arg;		\/* name(arg) {value} *\/$/;"	m	struct:environment
arg	edparams.c	/^	char	*arg;$/;"	m	struct:environment	file:
argify	editline.c	/^argify(line, avp)$/;"	f
argvptr	getttyent.c	/^static char **argvptr;			\/* Place in word lists. *\/$/;"	v	file:
arp	cursesio.c	/^char *arp;			\/* pointer for use in tgetstr *\/$/;"	v
arp46	arp.c	/^typedef struct arp46$/;"	s	file:
arp46_t	arp.c	/^} arp46_t, rarp46_t;$/;"	t	typeref:struct:arp46	file:
arp_cache	arp.c	/^PRIVATE	arp_cache_t arp_cache[ARP_CACHE_NR];$/;"	v
arp_cache	arp.c	/^typedef struct arp_cache$/;"	s	file:
arp_cache_t	arp.c	/^} arp_cache_t;$/;"	t	typeref:struct:arp_cache	file:
arp_getdata	arp.c	/^PRIVATE acc_t *arp_getdata (fd, offset, count, for_ioctl)$/;"	f
arp_init	arp.c	/^PUBLIC void arp_init()$/;"	f
arp_ip_eth	arp.c	/^PUBLIC int arp_ip_eth (eth_port, ref, ipaddr, func)$/;"	f
arp_ip_eth_nonbl	arp.c	/^PUBLIC int arp_ip_eth_nonbl (eth_port, ipaddr, ethaddr)$/;"	f
arp_main	arp.c	/^PRIVATE void arp_main(port)$/;"	f
arp_port	arp.c	/^PRIVATE arp_port_t *arp_port;$/;"	v
arp_port	arp.c	/^typedef struct arp_port$/;"	s	file:
arp_port_t	arp.c	/^} arp_port_t;$/;"	t	typeref:struct:arp_port	file:
arp_port_table	arp.c	/^PRIVATE arp_port_t arp_port_table[ARP_PORT_NR];$/;"	v
arp_putdata	arp.c	/^PRIVATE int arp_putdata (fd, offset, data, for_ioctl)$/;"	f
arp_timeout	arp.c	/^PRIVATE void arp_timeout (fd, timer)$/;"	f
array	test2.c	/^int is, array[4], parsigs, parcum, sigct, cumsig, errct, subtest;$/;"	v
arraylimit	boot.c	37;"	d	file:
arraylimit	edparams.c	111;"	d	file:
arraylimit	getgrent.c	19;"	d	file:
arraylimit	getpwent.c	19;"	d	file:
arraylimit	getttyent.c	16;"	d	file:
arraysize	boot.c	36;"	d	file:
arraysize	edparams.c	110;"	d	file:
arraysize	getgrent.c	18;"	d	file:
arraysize	getpwent.c	18;"	d	file:
arraysize	getttyent.c	15;"	d	file:
as	cursesio.c	/^char *as;			\/* alternative charset start *\/$/;"	v
asctime	asctime.c	/^char *asctime(const struct tm *timeptr)$/;"	f
asin	asin.c	/^asin(double x)$/;"	f
asin_acos	asin.c	/^asin_acos(double x, int cosfl)$/;"	f	file:
assert	assert.h	14;"	d
assert	assert.h	22;"	d
assert_failed	malloc.c	/^static assert_failed()$/;"	f	file:
asyn_close	asynchio.c	/^int asyn_close(asynchio_t *asyn, int fd)$/;"	f
asyn_count	asynchio.c	/^static ssize_t asyn_count;$/;"	v	file:
asyn_current	asynchio.c	/^static int *asyn_current;$/;"	v	file:
asyn_data	asynchio.c	/^static void *asyn_data;$/;"	v	file:
asyn_errno	asynchio.c	/^static int asyn_errno;$/;"	v	file:
asyn_fd	asynchio.c	/^static int asyn_fd;$/;"	v	file:
asyn_init	asynchio.c	/^void asyn_init(asynchio_t *asyn)$/;"	f
asyn_ioctl	asynchio.c	/^int asyn_ioctl(asynchio_t *asyn, int fd, unsigned long request, void *data)$/;"	f
asyn_op	asynchio.c	/^static int asyn_op;$/;"	v	file:
asyn_read	asynchio.c	/^ssize_t asyn_read(asynchio_t *asyn, int fd, void *buf, size_t len)$/;"	f
asyn_req	asynchio.c	/^static int asyn_req;$/;"	v	file:
asyn_synch	asynchio.c	/^int asyn_synch(asynchio_t *asyn, int fd)$/;"	f
asyn_wait	asynchio.c	/^int asyn_wait(asynchio_t *asyn, int flags, struct timeval *to)$/;"	f
asyn_write	asynchio.c	/^ssize_t asyn_write(asynchio_t *asyn, int fd, const void *buf, size_t len)$/;"	f
at_eof	aha_scsi.c	/^	    char at_eof;	\/* got EOF mark *\/$/;"	m	struct:scsi::__anon12::__anon13	file:
at_eof	aha_scsi.c	353;"	d	file:
at_winchester_task	at_wini.c	/^PUBLIC void at_winchester_task()$/;"	f
atan	atan.c	/^atan(double x)$/;"	f
atan2	atan2.c	/^atan2(double y, double x)$/;"	f
atexit	atexit.c	/^atexit(void (*func)(void))$/;"	f
atof	atof.c	/^atof(const char *nptr)$/;"	f
atoi	atoi.c	/^atoi(register const char *nptr)$/;"	f
atol	atol.c	/^atol(register const char *nptr)$/;"	f
ax	protect.c	/^  reg_t ax;$/;"	m	struct:tss_s	file:
b	floppy.c	208;"	d	file:
b	test19.c	/^char b[4] = {0, 1, 2, 3}, c[4] = {10, 20, 30, 40}, d[4] = {6, 7, 8, 9};$/;"	v
b2_blocknr	cache2.c	/^  block_t b2_blocknr;		\/* block number *\/$/;"	m	struct:buf2	file:
b2_count	cache2.c	/^  u16_t b2_count;		\/* count of in-cache block groups *\/$/;"	m	struct:buf2	file:
b2_dev	cache2.c	/^  dev_t b2_dev;			\/* device number *\/$/;"	m	struct:buf2	file:
b2h16	aha_scsi.c	/^PRIVATE u16_t b2h16(b)$/;"	f
b2h24	aha_scsi.c	/^PRIVATE u32_t b2h24(b)$/;"	f
b2h32	aha_scsi.c	/^PRIVATE u32_t b2h32(b)$/;"	f
b64_add	adder.c	/^b64_add(e1,e2)$/;"	f
b64_add	ext_comp.c	/^b64_add(struct mantissa *e1, struct mantissa *e2)$/;"	f	file:
b64_lsft	shifter.c	/^b64_lsft(e1)$/;"	f
b64_rsft	shifter.c	/^b64_rsft(e1)$/;"	f
b64_sft	ext_comp.c	/^b64_sft(struct mantissa *e1, int n)$/;"	f	file:
b64_sft	shifter.c	/^b64_sft(e1,n)$/;"	f
b_body	boot.c	/^char *b_body(char *name)$/;"	f
b_body	edparams.c	/^char *b_body(char *name)$/;"	f
b_getenv	boot.c	583;"	d	file:
b_getenv	edparams.c	296;"	d	file:
b_setenv	boot.c	/^int b_setenv(int flags, char *name, char *arg, char *value)$/;"	f
b_setenv	edparams.c	/^int b_setenv(int flags, char *name, char *arg, char *value)$/;"	f
b_setvar	boot.c	/^int b_setvar(int flags, char *name, char *value)$/;"	f
b_setvar	edparams.c	/^int b_setvar(int flags, char *name, char *value)$/;"	f
b_unset	boot.c	/^void b_unset(char *name)$/;"	f
b_unset	edparams.c	/^void b_unset(char *name)$/;"	f
b_value	boot.c	/^char *b_value(char *name)$/;"	f
b_value	edparams.c	/^char *b_value(char *name)$/;"	f
back_over	tty.c	/^PRIVATE int back_over(tp)$/;"	f
backlink	protect.c	/^  reg_t backlink;$/;"	m	struct:tss_s	file:
backspace	editline.c	/^STATIC char		*backspace;$/;"	v
bad	extboot.s	/^bad:	stc			! Set carry flag$/;"	l
bad	masterboot.s	/^bad:	stc			! Set carry flag$/;"	l
base	at_wini.c	/^  unsigned base;		\/* base register of the register file *\/$/;"	m	struct:wini	file:
base	protect.c	/^  char base[sizeof(u32_t)];		\/* really u24_t + pad for 286 *\/$/;"	m	struct:desctableptr_s	file:
base	ttyname.c	/^PRIVATE char base[] = "\/dev";$/;"	v
base	type.h	/^  phys_clicks base;$/;"	m	struct:memory
base_high	type.h	/^  u8_t base_high;$/;"	m	struct:segdesc_s
base_low	type.h	/^  u16_t base_low;$/;"	m	struct:segdesc_s
base_middle	type.h	/^  u8_t base_middle;$/;"	m	struct:segdesc_s
basename	installboot.c	/^char *basename(char *name)$/;"	f
baudrate	termmisc.c	/^int baudrate()$/;"	f
bcd2bin	mcd.c	/^PRIVATE void bcd2bin(u8_t *bcd)$/;"	f
bcmp	bcmp.c	/^int bcmp(s1, s2, length)	\/* == 0 or != 0 for equality and inequality *\/ $/;"	f
bcmp	gethnmadr.c	70;"	d	file:
bcmp	gethostent.c	68;"	d	file:
bcopy	bcopy.c	/^void bcopy(src, dst, length)$/;"	f
bcopy	gethnmadr.c	71;"	d	file:
bcopy	res_mkquery.c	40;"	d	file:
bcopy	res_query.c	40;"	d	file:
beep	beep.c	/^void beep()$/;"	f
beep	console.c	/^PRIVATE void beep()$/;"	f
beeping	console.c	/^PRIVATE int beeping;		\/* speaker is beeping? *\/$/;"	v
beg_line	editline.c	/^beg_line()$/;"	f
begbss	bootblock.s	/^begbss:$/;"	l
begbss	boothead.s	/^begbss:$/;"	l
begbss	crtso.s	/^begbss:$/;"	l
begbss	extboot.s	/^begbss:$/;"	l
begbss	masterboot.s	/^begbss:$/;"	l
begbss	mpx386.s	/^begbss:$/;"	l
begbss	mpx88.s	/^begbss:$/;"	l
begbss	ncrtso.s	/^begbss:$/;"	l
begdata	bootblock.s	/^begdata:$/;"	l
begdata	boothead.s	/^begdata:$/;"	l
begdata	crtso.s	/^begdata:$/;"	l
begdata	extboot.s	/^begdata:$/;"	l
begdata	masterboot.s	/^begdata:$/;"	l
begdata	mpx386.s	/^begdata:$/;"	l
begdata	mpx88.s	/^begdata:$/;"	l
begdata	ncrtso.s	/^begdata:$/;"	l
begrom	crtso.s	/^begrom:$/;"	l
begrom	mpx386.s	/^begrom:$/;"	l
begtext	bootblock.s	/^begtext:$/;"	l
begtext	boothead.s	/^begtext:$/;"	l
begtext	crtso.s	/^begtext:$/;"	l
begtext	extboot.s	/^begtext:$/;"	l
begtext	masterboot.s	/^begtext:$/;"	l
begtext	mpx386.s	/^begtext:$/;"	l
begtext	ncrtso.s	/^begtext:$/;"	l
between	boot.c	38;"	d	file:
between	bootimage.c	66;"	d	file:
between	edparams.c	384;"	d	file:
between	installboot.c	40;"	d	file:
between	strtol.c	28;"	d	file:
bf_512free	buf.c	/^PRIVATE void bf_512free(buffer)$/;"	f
bf_afree	buf.c	/^PUBLIC void bf_afree(acc_ptr)$/;"	f
bf_append	buf.c	/^PUBLIC acc_t *bf_append(data_first, data_second)$/;"	f
bf_buf_gran	buf.c	/^PRIVATE size_t bf_buf_gran;$/;"	v
bf_bufsize	buf.h	69;"	d
bf_bufsize_file	buf.c	/^PUBLIC char *bf_bufsize_file;$/;"	v
bf_bufsize_line	buf.c	/^PUBLIC int bf_bufsize_line;$/;"	v
bf_check_all_bufs	buf.c	/^PUBLIC void bf_check_all_bufs()$/;"	f
bf_chkbuf	buf.h	150;"	d
bf_cut	buf.c	/^PUBLIC acc_t *bf_cut (data, offset, length)$/;"	f
bf_cut	buf.h	59;"	d
bf_cut_file	buf.c	/^PUBLIC char *bf_cut_file;$/;"	v
bf_cut_line	buf.c	/^PUBLIC int bf_cut_line;$/;"	v
bf_dupacc	buf.c	/^PUBLIC acc_t *bf_dupacc(acc_ptr)$/;"	f
bf_free_buffsize	buf.c	/^PUBLIC size_t bf_free_buffsize;$/;"	v
bf_freereq_t	buf.h	/^typedef void (*bf_freereq_t) ARGS(( int priority, size_t reqsize ));$/;"	t
bf_init	buf.c	/^PUBLIC void bf_init()$/;"	f
bf_logon	buf.c	/^PUBLIC void bf_logon(func)$/;"	f
bf_memreq	buf.c	/^PUBLIC acc_t *bf_memreq(size)$/;"	f
bf_memreq	buf.h	54;"	d
bf_memreq_file	buf.c	/^PUBLIC char *bf_memreq_file;$/;"	v
bf_memreq_line	buf.c	/^PUBLIC int bf_memreq_line;$/;"	v
bf_pack	buf.c	/^PUBLIC acc_t *bf_pack(old_acc)$/;"	f
bf_packIffLess	buf.c	/^PUBLIC acc_t *bf_packIffLess(pack, min_len)$/;"	f
bf_packIffLess	buf.h	64;"	d
bf_pack_file	buf.c	/^PUBLIC char *bf_pack_file;$/;"	v
bf_pack_line	buf.c	/^PUBLIC int bf_pack_line;$/;"	v
bf_small_memreq	buf.c	/^PRIVATE acc_t *bf_small_memreq(size)$/;"	f
bf_temporary_acc	buf.c	/^PUBLIC acc_t *bf_temporary_acc;$/;"	v
big16	aha_scsi.c	/^typedef byte big16[2];	\/* 16 bit big-endian values *\/$/;"	t	file:
big24	aha_scsi.c	/^typedef byte big24[3];	\/* AHA uses 24 bit, big-endian values! *\/$/;"	t	file:
big32	aha_scsi.c	/^typedef byte big32[4];	\/* Group 1 SCSI commands use 32 bit big-endian values *\/$/;"	t	file:
big_ten_powers	ext_comp.c	/^static struct EXTEND big_ten_powers[] = {  \/* representation of 10 ** (28*i) *\/$/;"	v	typeref:struct:EXTEND	file:
bigmin	em_fp8087.s	/^bigmin:$/;"	l
bigmin	fp8087.s	/^bigmin:$/;"	l
bill_ptr	proc.h	/^EXTERN struct proc *bill_ptr;	\/* ptr to process to bill for clock ticks *\/$/;"	v	typeref:struct:proc
bin2bcd	mcd.c	/^PRIVATE u8_t bin2bcd(u8_t b)$/;"	f
bios13	boothead.s	/^bios13:$/;"	l
bios_err	boot.c	/^char *bios_err(int err)$/;"	f
bios_winchester_task	bios_wini.c	/^PUBLIC void bios_winchester_task()$/;"	f
biosdev	boot.c	/^struct biosdev {$/;"	s	file:
bitmapsize	fslib.c	/^PUBLIC int bitmapsize(nr_bits)$/;"	f
bits	em_inn.s	/^bits:$/;"	l
bits	em_set.s	/^bits:$/;"	l
bits	inn.s	/^bits:$/;"	l
bits	set.s	/^bits:$/;"	l
bk_char	editline.c	/^bk_char()$/;"	f
bk_del_char	editline.c	/^bk_del_char()$/;"	f
bk_kill_word	editline.c	/^bk_kill_word()$/;"	f
bk_word	editline.c	/^bk_word()$/;"	f
bl	cursesio.c	/^char *bl;			\/* ring the bell *\/$/;"	v
blank_color	console.c	/^PUBLIC unsigned blank_color = BLANK_COLOR; \/* display code for blank *\/$/;"	v
block	at_wini.c	/^  unsigned long block;		\/* first sector to transfer *\/$/;"	m	struct:trans	file:
block	bios_wini.c	/^  unsigned long block;		\/* first sector to transfer *\/$/;"	m	struct:trans	file:
block	boot.c	/^	u32_t	block;$/;"	m	struct:cache_entry	file:
block	esdi_wini.c	/^  unsigned long block;		\/* first sector to transfer              *\/$/;"	m	struct:trans	file:
block2mss	mcd.c	/^PRIVATE void block2mss(block, mss)$/;"	f
block_size	aha_scsi.c	/^    unsigned block_size;	\/* device or media block size *\/$/;"	m	struct:scsi	file:
bool_t	rs232.c	/^typedef unsigned char bool_t;	\/* boolean *\/$/;"	t	file:
boot	boot.c	/^void boot(void)$/;"	f
boot	bootblock.s	/^boot:$/;"	l
boot	boothead.s	/^boot:$/;"	l
boot_device	boot.c	/^void boot_device(char *devname)$/;"	f
boot_magic	edparams.c	/^char boot_magic[] = { 0x31, 0xC0, 0x8E, 0xD8, 0xFA, 0x8E, 0xD0, 0xBC };$/;"	v
boot_parameters	main.c	/^PUBLIC struct bparam_s boot_parameters;$/;"	v	typeref:struct:bparam_s
boot_parameters	system.c	/^PUBLIC struct bparam_s boot_parameters;$/;"	v	typeref:struct:bparam_s
boot_part	boot.c	/^struct part_entry boot_part;$/;"	v	typeref:struct:part_entry
boot_time	clock.c	/^PRIVATE time_t boot_time;	\/* time in seconds of system boot *\/$/;"	v
bootdev	boot.c	/^} bootdev, tmpdev;$/;"	v	typeref:struct:biosdev
bootind	extboot.s	/^	bootind	   =	     0$/;"	d
bootind	masterboot.s	/^	bootind	   =	     0$/;"	d
bootminix	bootimage.c	/^void bootminix(void)$/;"	f
bootstrap	extboot.s	/^bootstrap:$/;"	l
bootstrap	masterboot.s	/^bootstrap:$/;"	l
bounds	test19.c	/^long bounds[NBOUNDS] = {7, 9, 50, 519, 520, 40000L};$/;"	v
bp	protect.c	/^  reg_t bp;$/;"	m	struct:tss_s	file:
bp_ctlbyte	drvlib.h	15;"	d
bp_cylinders	drvlib.h	10;"	d
bp_heads	drvlib.h	11;"	d
bp_landingzone	drvlib.h	16;"	d
bp_max_ecc	drvlib.h	14;"	d
bp_precomp	drvlib.h	13;"	d
bp_reduced_wr	drvlib.h	12;"	d
bp_sectors	drvlib.h	17;"	d
bread	installboot.c	/^void bread(FILE *f, char *name, void *buf, size_t len)$/;"	f
break	boothead.s	/^break:	.data2	_end		! A fake heap pointer$/;"	l
break_interrupts	rs232.c	/^  unsigned break_interrupts;$/;"	m	struct:rs232	file:
brk	_brk.c	/^PUBLIC int brk(addr)$/;"	f
brk	_brk.c	2;"	d	file:
bsearch	bsearch.c	/^bsearch(register const void *key, register const void *base,$/;"	f
bubble	extboot.s	/^bubble:	lea	di, PENTRYSIZE(si)	! Next entry$/;"	l
bubble	masterboot.s	/^bubble:	lea	di, PENTRYSIZE(si)	! Next entry$/;"	l
buf	buf.h	/^typedef struct buf$/;"	s
buf	getgrent.c	/^static char buf[1024];			\/* Read buffer. *\/$/;"	v	file:
buf	gethnmadr.c	/^	u_char buf[MAXPACKET];$/;"	m	union:querybuf	file:
buf	getpwent.c	/^static char buf[1024];			\/* Read buffer. *\/$/;"	v	file:
buf	getttyent.c	/^static char buf[512];			\/* Read buffer. *\/$/;"	v	file:
buf	test2.c	/^char buf[2048];$/;"	v
buf	test23.c	/^char buf[PATH_MAX];$/;"	v
buf	test4.c	/^char buf[1024];$/;"	v
buf	test7.c	/^char buf[ITEMS] = {0,1,2,3,4,5,6,7,8,9,8,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,8,9};$/;"	v
buf	test9.c	/^char buf[512];$/;"	v
buf2	cache2.c	/^PRIVATE struct buf2 {	\/* 2nd level cache per block administration *\/$/;"	s	file:
buf2	cache2.c	/^} buf2[MAX_BUF2];$/;"	v	typeref:struct:buf2
buf2_idx	cache2.c	/^PRIVATE unsigned buf2_idx;		\/* round-robin reuse index *\/$/;"	v
buf512	buf.c	/^typedef struct buf512$/;"	s	file:
buf512_free	buf.c	/^PRIVATE buf512_t *buf512_free;$/;"	v
buf512_t	buf.c	/^} buf512_t;$/;"	t	typeref:struct:buf512	file:
buf_count	putk.c	/^PRIVATE int buf_count;		\/* # characters in the buffer *\/$/;"	v
buf_data	buf.c	/^	char buf_data[512];$/;"	m	struct:buf512	file:
buf_data_p	buf.h	/^	char *buf_data_p;$/;"	m	struct:buf
buf_free	buf.h	/^	buffree_t buf_free;$/;"	m	struct:buf
buf_header	buf.c	/^	buf_t buf_header;$/;"	m	struct:buf512	file:
buf_linkC	buf.h	/^	int buf_linkC;$/;"	m	struct:buf
buf_next	buf.h	/^	void *buf_next;$/;"	m	struct:buf
buf_pool	main.c	/^PRIVATE void buf_pool()$/;"	f
buf_size	buf.h	/^	size_t buf_size;$/;"	m	struct:buf
buf_t	buf.h	/^} buf_t;$/;"	t	typeref:struct:buf
bufend	tty.h	95;"	d
buff	test19.c	/^char buff[30000];$/;"	v
buffer	driver.c	/^PRIVATE u8_t buffer[(unsigned) 2 * DMA_BUF_SIZE + BUF_EXTRA];$/;"	v
buffer	param.h	4;"	d
buffer	test13.c	/^char buffer[BLOCK_SIZE];$/;"	v
buffers512	buf.c	/^PRIVATE buf512_t *buffers512;$/;"	v
buffers512	buf.c	/^PRIVATE buf512_t buffers512[BUF512_NR];$/;"	v
buffree_t	buf.h	/^typedef void (*buffree_t) ARGS(( struct buf *buffer ));$/;"	t
buflen	getgrent.c	/^static ssize_t buflen= 0;		\/* Remaining characters in buf. *\/$/;"	v	file:
buflen	getpwent.c	/^static ssize_t buflen= 0;		\/* Remaining characters in buf. *\/$/;"	v	file:
buflen	getttyent.c	/^static ssize_t buflen= 0;		\/* Remaining characters in buf. *\/$/;"	v	file:
buflen	tty.h	94;"	d
bufptr	getgrent.c	/^static char *bufptr;			\/* Place in buf. *\/$/;"	v	file:
bufptr	getpwent.c	/^static char *bufptr;			\/* Place in buf. *\/$/;"	v	file:
bufptr	getttyent.c	/^static char *bufptr;			\/* Place in buf. *\/$/;"	v	file:
bwrite	installboot.c	/^void bwrite(FILE *f, char *name, void *buf, size_t len)$/;"	f
bx	protect.c	/^  reg_t bx;$/;"	m	struct:tss_s	file:
bx	type.h	/^  reg_t bx;                     \/*  | *\/$/;"	m	struct:stackframe_s
byte	aha_scsi.c	/^typedef unsigned char byte;$/;"	t	file:
bytes	ether.h	/^    unsigned char bytes[6];		\/* byteorder safe initialization *\/$/;"	m	union:etheraddr
bytes	ethere2a.c	15;"	d	file:
bzero	bzero.c	/^void bzero(dst, length)$/;"	f
bzero	res_mkquery.c	39;"	d	file:
c	test19.c	/^char b[4] = {0, 1, 2, 3}, c[4] = {10, 20, 30, 40}, d[4] = {6, 7, 8, 9};$/;"	v
c_attr	console.c	/^  unsigned c_attr;		\/* character attribute *\/$/;"	m	struct:console	file:
c_blank	console.c	/^  unsigned c_blank;		\/* blank attribute *\/$/;"	m	struct:console	file:
c_column	console.c	/^  int c_column;			\/* current column number (0-origin) *\/$/;"	m	struct:console	file:
c_complete	editline.c	/^c_complete()$/;"	f
c_cur	console.c	/^  unsigned c_cur;		\/* current position of cursor in video RAM *\/$/;"	m	struct:console	file:
c_esc_intro	console.c	/^  char c_esc_intro;		\/* Distinguishing character following ESC *\/$/;"	m	struct:console	file:
c_esc_parmp	console.c	/^  int *c_esc_parmp;		\/* pointer to current escape parameter *\/$/;"	m	struct:console	file:
c_esc_parmv	console.c	/^  int c_esc_parmv[MAX_ESC_PARMS];	\/* list of escape parameters *\/$/;"	m	struct:console	file:
c_esc_state	console.c	/^  char c_esc_state;		\/* 0=normal, 1=ESC, 2=ESC[ *\/$/;"	m	struct:console	file:
c_handler	mcd.c	/^PRIVATE int c_handler(irq)$/;"	f
c_limit	console.c	/^  unsigned c_limit;		\/* limit of this console's video memory *\/$/;"	m	struct:console	file:
c_mode	param.h	18;"	d
c_name	param.h	19;"	d
c_org	console.c	/^  unsigned c_org;		\/* location in RAM where 6845 base points *\/$/;"	m	struct:console	file:
c_possible	editline.c	/^c_possible()$/;"	f
c_ramqueue	console.c	/^  u16_t c_ramqueue[CONS_RAM_WORDS];	\/* buffer for video RAM *\/$/;"	m	struct:console	file:
c_row	console.c	/^  int c_row;			\/* current row (0 at top of screen) *\/$/;"	m	struct:console	file:
c_rwords	console.c	/^  int c_rwords;			\/* number of WORDS (not bytes) in outqueue *\/$/;"	m	struct:console	file:
c_start	console.c	/^  unsigned c_start;		\/* start of video memory of this console *\/$/;"	m	struct:console	file:
c_tty	console.c	/^  tty_t *c_tty;			\/* associated TTY struct *\/$/;"	m	struct:console	file:
cabs	hypot.c	/^cabs(p_compl)$/;"	f
cache	boot.c	/^} cache[CACHE_SIZE];$/;"	v	typeref:struct:cache_entry
cache_entry	boot.c	/^struct cache_entry {$/;"	s	file:
cache_live	boot.c	/^int cache_live= 0;$/;"	v
cache_live	boot.c	153;"	d	file:
caddr	boot.h	/^EXTERN u32_t caddr, daddr;	\/* Code and data address of the boot program. *\/$/;"	v
calc_iovec_size	dp8390.c	/^static int calc_iovec_size(iovp)$/;"	f	file:
call	trp.s	/^call    (bx)$/;"	l
call	trp.s	/^call .Write$/;"	l
call	trp.s	/^call __exit$/;"	l
call_ctty	device.c	/^PUBLIC void call_ctty(task_nr, mess_ptr)$/;"	f
call_task	device.c	/^PUBLIC void call_task(task_nr, mess_ptr)$/;"	f
caller	printer.c	/^PRIVATE int caller;		\/* process to tell when printing done (FS) *\/$/;"	v
calloc	calloc.c	/^calloc(size_t nelem, size_t elsize)$/;"	f
capab	termcap.c	/^char *capab = (char *)NULL;		\/* the capability itself *\/$/;"	v
caps_off	keyboard.c	/^PRIVATE int caps_off;		\/* 1 = normal position, 0 = depressed *\/$/;"	v
capslock	keyboard.c	/^PRIVATE int capslock;		\/* caps lock key state *\/$/;"	v
case_down_word	editline.c	/^case_down_word()$/;"	f
case_up_word	editline.c	/^case_up_word()$/;"	f
catch	getpass.c	/^static void catch(int sig)$/;"	f	file:
catch	test9.c	/^void catch(s)$/;"	f
catch1	test8.c	/^void catch1(signo)$/;"	f
catch14	test8.c	/^void catch14(signo, code, scp)$/;"	f
catch15	test8.c	/^void catch15(signo)$/;"	f
catch2	test8.c	/^void catch2(signo)$/;"	f
catch3	test8.c	/^void catch3(signo)$/;"	f
catch4	test8.c	/^void catch4(signo)$/;"	f
catch5	test8.c	/^void catch5(signo)$/;"	f
cause_alarm	clock.c	/^PRIVATE void cause_alarm()$/;"	f
cause_sig	system.c	/^PUBLIC void cause_sig(proc_nr, sig_nr)$/;"	f
cbreak	setterm.c	/^void cbreak()$/;"	f
cbrkmode	curspriv.h	/^  bool     cbrkmode;$/;"	m	struct:__anon20
cbyte	memcmp.s	/^cbyte:	test	ecx, ecx	! Set 'Z' flag if ecx = 0$/;"	l
ccb	aha_scsi.c	/^  ccb_t ccb;			\/* Command Control Block *\/$/;"	m	struct:request	file:
ccb_cmd0	aha_scsi.c	402;"	d	file:
ccb_cmd1	aha_scsi.c	403;"	d	file:
ccb_lun	aha_scsi.c	277;"	d	file:
ccb_scid	aha_scsi.c	273;"	d	file:
ccb_sense	aha_scsi.c	404;"	d	file:
ccb_t	aha_scsi.c	/^} ccb_t;$/;"	t	typeref:struct:__anon10	file:
ccbptr	aha_scsi.c	/^  big24 ccbptr;		\/* pointer to Command Control Block *\/$/;"	m	struct:__anon2	file:
cdb0_t	aha_scsi.c	/^} cdb0_t;$/;"	t	typeref:union:__anon3	file:
cdb1_t	aha_scsi.c	/^} cdb1_t;$/;"	t	typeref:union:__anon6	file:
ceil	ceil.c	/^ceil(double x)$/;"	f
ceol	editline.c	/^ceol()$/;"	f
cff4	cff4.c	/^cff4(src)$/;"	f
cff8	cff8.c	/^cff8(src)$/;"	f
cfi	cfi.c	/^cfi(ds,ss,src)$/;"	f
cfu	cfu.c	/^cfu(ds,ss,src)$/;"	f
change	stadir.c	/^PRIVATE int change(iip, name_ptr, len)$/;"	f
charsigned	test15.c	/^int charsigned;			\/* Result. *\/$/;"	v
chdir	_chdir.c	/^PUBLIC int chdir(name)$/;"	f
chdir	_chdir.c	2;"	d	file:
chdir	_getcwd.c	6;"	d	file:
check	test15.c	/^void check(thing, number)$/;"	f
check	test17.c	/^void check(scall, number)$/;"	f
check	test18.c	/^void check(scall, number)$/;"	f
check_init	xt_wini.c	/^PRIVATE int check_init()$/;"	f
check_pending	signal.c	/^PRIVATE void check_pending()$/;"	f
check_sig	signal.c	/^PUBLIC int check_sig(proc_id, signo)$/;"	f
checkdir	test20.c	/^void checkdir(dirp, t)$/;"	f
child	param.h	5;"	d
child	test1.c	/^void child(i)$/;"	f
child	test5.c	/^void child(parpid)$/;"	f
child1	test1.c	/^void child1()$/;"	f
child_stime	proc.h	/^  clock_t child_stime;		\/* cumulative sys time of children *\/$/;"	m	struct:proc
child_utime	proc.h	/^  clock_t child_utime;		\/* cumulative user time of children *\/$/;"	m	struct:proc
childsigs	test5.c	/^_VOLATILE int childsigs, parsigs, alarms;$/;"	v
chk_dir	test24.c	/^void chk_dir(dirp)		\/* dir should contain             *\/$/;"	f
chk_dstaddr	ip_write.c	/^PRIVATE chk_dstaddr (dst)$/;"	f
chmem	boothead.s	/^chmem:	.ascii	" memory, use chmem to increase the heap\\n\\0"$/;"	l
chmod	_chmod.c	/^PUBLIC int chmod(name, mode)$/;"	f
chmod	_chmod.c	2;"	d	file:
chmod_8_dirs	test17.c	/^void chmod_8_dirs(sw)$/;"	f
chmod_8_dirs	test18.c	/^void chmod_8_dirs(sw)$/;"	f
choice	masterboot.s	/^choice:		.ascii	"\\0\\r\\n\\0"$/;"	l
chown	_chown.c	/^PUBLIC int chown(name, owner, grp)$/;"	f
chown	_chown.c	2;"	d	file:
chroot	_chroot.c	/^PUBLIC int chroot(name)$/;"	f
chroot	_chroot.c	2;"	d	file:
cif4	cif4.c	/^cif4(ss,src)$/;"	f
cif8	cif8.c	/^cif8(ss,src)$/;"	f
cl	cursesio.c	/^char *cl;			\/* clear screen capability *\/$/;"	v
clean_up_the_mess	test17.c	/^void clean_up_the_mess()$/;"	f
clean_up_the_mess	test18.c	/^void clean_up_the_mess()$/;"	f
cleanup	common.c	/^void cleanup()$/;"	f
cleanup	forkexit.c	/^PRIVATE void cleanup(child)$/;"	f
clear_array	test17.c	/^void clear_array(b)$/;"	f
clear_array	test18.c	/^void clear_array(b)$/;"	f
clear_line	editline.c	/^clear_line()$/;"	f
clear_zone	write.c	/^PUBLIC void clear_zone(rip, pos, flag)$/;"	f
clearerr	clearerr.c	/^(clearerr)(FILE *stream)$/;"	f
clearok	options.c	/^void clearok(win, flag)$/;"	f
clearsigstate	test8.c	/^void clearsigstate()$/;"	f
click_shift	bootimage.c	/^unsigned click_shift;$/;"	v
click_shift	bootimage.c	28;"	d	file:
click_size	bootimage.c	/^unsigned click_size;	\/* click_size = Smallest kernel memory object. *\/$/;"	v
click_to_hclick	const.h	27;"	d
click_to_hclick	const.h	29;"	d
client_reply	arp.c	/^PRIVATE void client_reply (port, ethaddr)$/;"	f
clock_handler	clock.c	/^PRIVATE int clock_handler(irq)$/;"	f
clock_mess	driver.c	/^PUBLIC void clock_mess(ticks, func)$/;"	f
clock_mess	time.c	/^PRIVATE message clock_mess;$/;"	v
clock_mess	utility.c	/^PRIVATE message clock_mess;$/;"	v
clock_stop	clock.c	/^PUBLIC void clock_stop()$/;"	f
clock_task	clock.c	/^PUBLIC void clock_task()$/;"	f
clock_time	utility.c	/^PUBLIC time_t clock_time()$/;"	f
cloexec_test	test7.c	/^void cloexec_test()$/;"	f
close	_close.c	/^PUBLIC int close(fd)$/;"	f
close	_close.c	2;"	d	file:
close	_closedir.c	6;"	d	file:
close	_dup2.c	2;"	d	file:
close	_opendir.c	6;"	d	file:
close	_pathconf.c	4;"	d	file:
close	_uname.c	11;"	d	file:
close	crypt.c	9;"	d	file:
close	getgrent.c	10;"	d	file:
close	getpass.c	11;"	d	file:
close	getpwent.c	10;"	d	file:
close	getttyent.c	6;"	d	file:
close_alot	test17.c	/^int close_alot(number)$/;"	f
close_alot	test18.c	/^int close_alot(number)$/;"	f
close_mainuser	tcp.c	/^PRIVATE void close_mainuser(tcp_conn, tcp_fd)$/;"	f
closedir	_closedir.c	/^int closedir(DIR *dp)$/;"	f
closedir	_closedir.c	7;"	d	file:
closedir	_getcwd.c	7;"	d	file:
clraa	test19.c	/^void clraa()$/;"	f
clrscr	cursesio.c	/^void clrscr()$/;"	f
clrupdate	update.c	/^static void clrupdate(scr)$/;"	f	file:
clword	memcmp.s	/^clword:	shrd	eax, ecx, 2	! Save low two bits of ecx in eax$/;"	l
cm	cursesio.c	/^char *cm;			\/* cursor motion capability *\/$/;"	v
cm_1exit	klib88.s	/^cm_1exit:$/;"	l
cm_exit	klib386.s	/^cm_exit:$/;"	l
cm_exit	klib88.s	/^cm_exit:$/;"	l
cm_loop	klib386.s	/^cm_loop:$/;"	l
cm_loop	klib88.s	/^cm_loop:$/;"	l
cmd	aha_scsi.c	/^    byte cmd[sizeof(cdb1_t)];	\/* SCSI Command Descriptor Block *\/$/;"	m	struct:__anon10	file:
cmdlen	aha_scsi.c	/^    byte cmdlen;		\/* SCSI Command Length (6 for Group 0) *\/$/;"	m	struct:__anon10	file:
cmds	boot.c	/^token *cmds;		\/* String of commands to execute. *\/$/;"	v
cmds	edparams.c	/^token *cmds;		\/* String of commands to execute. *\/$/;"	v
cmf4	cmf4.c	/^cmf4(f1,f2)$/;"	f
cmf8	cmf8.c	/^cmf8(d1,d2)$/;"	f
cmp	trp.s	/^cmp dx,#21$/;"	l
cmp_ext	ext_comp.c	/^cmp_ext(struct EXTEND *e1, struct EXTEND *e2)$/;"	f	file:
co_mode	param.h	6;"	d
code_base	glo.h	/^EXTERN phys_bytes code_base;	\/* base of kernel code *\/$/;"	v
color	console.c	101;"	d	file:
columns	editline.c	/^columns(ac, av)$/;"	f
comID	boothead.s	/^comID:	xor	ax, ax$/;"	l
com_out	at_wini.c	/^PRIVATE int com_out(cmd)$/;"	f
com_out	xt_wini.c	/^PRIVATE int com_out(mode, commandp)$/;"	f
com_simple	at_wini.c	/^PRIVATE int com_simple(cmd)$/;"	f
command	at_wini.c	/^  u8_t	command;$/;"	m	struct:command	file:
command	at_wini.c	/^struct command {$/;"	s	file:
command	esdi_wini.c	/^PRIVATE int command[4];		\/* controller command buffer             *\/$/;"	v
common_open	open.c	/^PRIVATE int common_open(oflags, omode)$/;"	f
common_setalarm	clock.c	/^PRIVATE void common_setalarm(proc_nr, delta_ticks, function)$/;"	f
common_test_nr	common.c	/^int common_test_nr = -1, errct = 0, subtest;$/;"	v
comp_array	test17.c	/^int comp_array(a, b, range)$/;"	f
comp_array	test18.c	/^int comp_array(a, b, range)$/;"	f
comp_inodes	test17.c	/^void comp_inodes(m, m1)$/;"	f
comp_stats	test17.c	/^void comp_stats(stbf1, stbf2)$/;"	f
compact	compact.c	/^compact(f,to,size)$/;"	f
compare	_strncmp.s	/^compare:$/;"	l
compare	assert.h	16;"	d
compare	assert.h	23;"	d
compare	complete.c	/^compare(p1, p2)$/;"	f
compat_getc	tty.c	/^PRIVATE int compat_getc(tp, tc)$/;"	f
compat_getp	tty.c	/^PRIVATE int compat_getp(tp, sg)$/;"	f
compat_setc	tty.c	/^PRIVATE int compat_setc(tp, tc)$/;"	f
compat_setp	tty.c	/^PRIVATE int compat_setp(tp, sg)$/;"	f
complex	hypot.c	/^struct complex {$/;"	s	file:
comprmap	genmap.c	/^u8_t comprmap[4 + NR_SCAN_CODES * MAP_COLS * 9\/8 * 2 + 1];$/;"	v
comspec	aha_scsi.c	/^    big32 comspec;		\/* command specific info *\/$/;"	m	struct:__anon8	file:
con_loadfont	console.c	/^PUBLIC int con_loadfont(user_phys)$/;"	f
conf_hw	dp8390.c	/^static void conf_hw(dep)$/;"	f	file:
conn_right4fd	tcp.c	/^PRIVATE int conn_right4fd(tcp_conn, tcp_fd)$/;"	f
cons_echo	console.c	/^PRIVATE void cons_echo(tp, c)$/;"	f
cons_org0	console.c	/^PRIVATE void cons_org0()$/;"	f
cons_stop	console.c	/^PUBLIC void cons_stop()$/;"	f
cons_table	console.c	/^PRIVATE console_t cons_table[NR_CONS];$/;"	v
cons_write	console.c	/^PRIVATE void cons_write(tp)$/;"	f
console	console.c	/^typedef struct console {$/;"	s	file:
console_t	console.c	/^} console_t;$/;"	t	typeref:struct:console	file:
control	aha_scsi.c	190;"	d	file:
control	installboot.c	41;"	d	file:
control	keyboard.c	/^PRIVATE int control;		\/* control key state *\/$/;"	v
conv2	fslib.c	/^PUBLIC unsigned conv2(norm, w)$/;"	f
conv2	utility.c	/^PUBLIC unsigned conv2(norm, w)$/;"	f
conv4	fslib.c	/^PUBLIC long conv4(norm, x)$/;"	f
conv4	utility.c	/^PUBLIC long conv4(norm, x)$/;"	f
conv_inode	fslib.c	/^PUBLIC void conv_inode(rip, dip, dip2, rw_flag, magic)$/;"	f
copy	boothead.s	/^copy:$/;"	l
copy_param	xt_wini.c	/^PRIVATE void copy_param(src, dest)$/;"	f
copy_region	editline.c	/^copy_region()$/;"	f
copyadjust	boothead.s	/^copyadjust:$/;"	l
copydone	boothead.s	/^copydone:$/;"	l
copyexec	installboot.c	/^void copyexec(char *proc, FILE *procf, char *image, FILE *imagef, long n)$/;"	f
copygdt	mpx386.s	/^copygdt:$/;"	l
copystr	boot.c	/^char *copystr(char *s)$/;"	f
copystr	edparams.c	/^char *copystr(char *s)$/;"	f
cos	sin.c	/^cos(double x)$/;"	f
cosh	sinh.c	/^cosh(double x)$/;"	f
count	aha_scsi.c	/^  unsigned count;		\/* number of bytes to transfer *\/$/;"	m	struct:request	file:
count	at_wini.c	/^  u8_t	count;$/;"	m	struct:command	file:
count	at_wini.c	/^  unsigned count;		\/* byte count *\/$/;"	m	struct:trans	file:
count	bios_wini.c	/^  unsigned count;		\/* byte count *\/$/;"	m	struct:trans	file:
count	esdi_wini.c	/^  unsigned count;		\/* byte count                            *\/$/;"	m	struct:trans	file:
count_max	aha_scsi.c	/^    unsigned count_max;		\/* maximum single read or write *\/$/;"	m	struct:scsi	file:
cp	cursesio.c	/^char *cp;			\/* character pointer *\/$/;"	v
cp_b2u	sr.c	/^PRIVATE int cp_b2u (acc_ptr, proc, dest)$/;"	f
cp_mess	proc.c	/^PRIVATE void cp_mess(src, src_p, src_m, dst_p, dst_m)$/;"	f
cp_u2b	sr.c	/^PRIVATE int cp_u2b (proc, src, var_acc_ptr, size)$/;"	f
cproc_addr	proc.h	98;"	d
cpu_state	type.h	/^  struct cpu_state {$/;"	s	struct:fsave
cpu_state	type.h	/^  } cpu_state;$/;"	m	struct:fsave	typeref:struct:fsave::cpu_state
cpvec	sr.c	/^PRIVATE cpvec_t cpvec[CPVEC_NR];$/;"	v
cr3	protect.c	/^  reg_t cr3;$/;"	m	struct:tss_s	file:
cr_file	test10.c	/^void cr_file(name, size)$/;"	f
creat	_creat.c	/^PUBLIC int creat(name, mode)$/;"	f
creat	_creat.c	2;"	d	file:
create_RST	tcp_recv.c	/^PRIVATE void create_RST(tcp_conn, ip_hdr, tcp_hdr)$/;"	f
crtso	crtso.s	/^crtso:$/;"	l
crtso	ncrtso.s	/^crtso:		mov	bx,sp$/;"	l
crypt	crypt.c	/^char *crypt(const char *key, const char *salt)$/;"	f
cs	bootimage.c	/^	u32_t	cs;		\/* Code segment. *\/$/;"	m	struct:process	file:
cs	protect.c	/^  reg_t cs;$/;"	m	struct:tss_s	file:
cs	type.h	/^  reg_t cs;                     \/*  | *\/$/;"	m	struct:stackframe_s
cs64k	klib88.s	/^cs64k:	mov	ax, #DS_SELECTOR$/;"	l
cs_prot	boothead.s	/^cs_prot:$/;"	l
cs_real	boothead.s	/^cs_real:$/;"	l
csinit	klib386.s	/^csinit:	mov	eax, DS_SELECTOR$/;"	l
csinit	klib88.s	/^csinit:$/;"	l
csinit	mpx386.s	/^csinit:$/;"	l
cstart	start.c	/^PUBLIC void cstart(cs, ds, mcs, mds, parmoff, parmsize)$/;"	f
ctermid	ctermid.c	/^char *ctermid(name_space)$/;"	f
ctime	ctime.c	/^ctime(const time_t *timer)$/;"	f
cts	rs232.c	/^  char cts;			\/* normally 0, but MS_CTS if CLOCAL is set *\/$/;"	m	struct:rs232	file:
ctty_close	device.c	/^PUBLIC void ctty_close(task_nr, mess_ptr)$/;"	f
ctty_open	device.c	/^PUBLIC void ctty_open(task_nr, mess_ptr)$/;"	f
cuf4	cuf4.c	/^cuf4(ss,src)$/;"	f
cuf8	cuf8.c	/^cuf8(ss,src)$/;"	f
cumsig	test2.c	/^int is, array[4], parsigs, parcum, sigct, cumsig, errct, subtest;$/;"	v
cumsig	test8.c	/^int iteration, cumsig, subtest, errct = 0, sig1, sig2;$/;"	v
curcons	console.c	/^PRIVATE console_t *curcons;	\/* currently visible *\/$/;"	v
curdir	test6.c	/^char curdir[PATH_MAX];$/;"	v
curfil	rawfs.c	/^static struct inode curfil;		\/* Inode of file under examination *\/$/;"	v	typeref:struct:inode	file:
current	glo.h	/^EXTERN int current;		\/* currently visible console *\/$/;"	v
current_spec1	floppy.c	/^PRIVATE int current_spec1;	\/* latest spec1 sent to the controller *\/$/;"	v
curs_set	curs_set.c	/^void curs_set(visibility)$/;"	f
curscol	curspriv.h	/^  int	   curscol;$/;"	m	struct:__anon20
curscr	cursesio.c	/^WINDOW *stdscr, *curscr;$/;"	v
cursrow	curspriv.h	/^  int	   cursrow;			\/* position of physical cursor *\/$/;"	m	struct:__anon20
cursv	curspriv.h	/^} cursv;$/;"	t	typeref:struct:__anon20
cuserid	cuserid.c	/^char *cuserid(user_name)$/;"	f
cv64ul	installboot.c	44;"	d	file:
cvt	ecvt.c	/^cvt(long double value, int ndigit, int *decpt, int *sign, int ecvtflag)$/;"	f	file:
cwd	test23.c	/^char cwd[PATH_MAX];		\/* Space for path names. *\/$/;"	v
cwd2	test23.c	/^char cwd2[PATH_MAX];$/;"	v
cword	memcmp.s	/^cword:	shrd	eax, ecx, 1	! Save low bit of ecx in eax$/;"	l
cx	protect.c	/^  reg_t cx;$/;"	m	struct:tss_s	file:
cx	type.h	/^  reg_t cx;                     \/*  | *\/$/;"	m	struct:stackframe_s
cyl_hi	at_wini.c	/^  u8_t	cyl_hi;$/;"	m	struct:command	file:
cyl_lo	at_wini.c	/^  u8_t	cyl_lo;$/;"	m	struct:command	file:
cylinders	bios_wini.c	/^  unsigned cylinders;		\/* number of cylinders *\/$/;"	m	struct:wini	file:
d	FP_types.h	/^	unsigned long	d[2];$/;"	m	struct:__anon18
d	aha_scsi.c	/^    } d;$/;"	m	union:__anon3	typeref:struct:__anon3::__anon4	file:
d	aha_scsi.c	/^    } d;$/;"	m	union:__anon6	typeref:struct:__anon6::__anon7	file:
d	floppy.c	/^PRIVATE int d;			\/* diskette\/drive combination *\/$/;"	v
d	test19.c	/^char b[4] = {0, 1, 2, 3}, c[4] = {10, 20, 30, 40}, d[4] = {6, 7, 8, 9};$/;"	v
d1	type.h	/^  reg_t d1;$/;"	m	struct:stackframe_s
d2	type.h	/^  reg_t d2;$/;"	m	struct:stackframe_s
d3	type.h	/^  reg_t d3;$/;"	m	struct:stackframe_s
d4	type.h	/^  reg_t d4;$/;"	m	struct:stackframe_s
d5	type.h	/^  reg_t d5;$/;"	m	struct:stackframe_s
d6	type.h	/^  reg_t d6;$/;"	m	struct:stackframe_s
d7	type.h	/^  reg_t d7;$/;"	m	struct:stackframe_s
d_bufcut	tcp_send.c	25;"	d	file:
d_control	aha_scsi.c	/^	byte d_control;		\/* Reserved and link bit fields, set to 0 *\/$/;"	m	struct:__anon3::__anon4	file:
d_control	aha_scsi.c	/^	byte d_control;		\/* reserved and link bit fields, set to 0 *\/$/;"	m	struct:__anon6::__anon7	file:
d_lba	aha_scsi.c	/^        big24 d_lba;		\/* LUN and logical block address *\/$/;"	m	struct:__anon3::__anon4	file:
d_lba	aha_scsi.c	/^        big32 d_lba;		\/* Logical Block Address *\/$/;"	m	struct:__anon6::__anon7	file:
d_lunra	aha_scsi.c	/^	byte d_lunra;		\/* LUN etc. *\/$/;"	m	struct:__anon6::__anon7	file:
d_nblocks	aha_scsi.c	/^	big16 d_nblocks;	\/* transfer size in blocks *\/$/;"	m	struct:__anon6::__anon7	file:
d_nblocks	aha_scsi.c	/^	byte d_nblocks;		\/* Transfer size in blocks *\/$/;"	m	struct:__anon3::__anon4	file:
d_scsi_op	aha_scsi.c	/^	byte d_scsi_op;		\/* SCSI Operation Code *\/$/;"	m	struct:__anon3::__anon4	file:
d_scsi_op	aha_scsi.c	/^	byte d_scsi_op;		\/* SCSI Operation Code *\/$/;"	m	struct:__anon6::__anon7	file:
daddr	boot.h	/^EXTERN u32_t caddr, daddr;	\/* Code and data address of the boot program. *\/$/;"	v
data	bootimage.c	/^	u32_t	data;		\/* To access the data segment. *\/$/;"	m	struct:process	file:
data_base	glo.h	/^EXTERN phys_bytes data_base;	\/* base of kernel data *\/$/;"	v
datalen	aha_scsi.c	/^    big24 datalen;		\/* Data Length:  3 bytes, big endian *\/$/;"	m	struct:__anon10	file:
datalen	aha_scsi.c	/^    big24 datalen;		\/* length of a memory segment *\/$/;"	m	struct:__anon11	file:
dataptr	aha_scsi.c	/^    big24 dataptr;		\/* Data Pointer: 3 bytes, big endian *\/$/;"	m	struct:__anon10	file:
dataptr	aha_scsi.c	/^    big24 dataptr;		\/* address of a memory segment *\/$/;"	m	struct:__anon11	file:
date_of	misc.c	/^date_of(register struct dsttype *dst, struct tm *timep)$/;"	f	file:
daylight	misc.c	/^	const int daylight;$/;"	m	struct:table	file:
daylight	misc.c	/^int	daylight = 0;$/;"	v
de_16bit	dp8390.h	/^	int de_16bit;$/;"	m	struct:dpeth
de_address	dp8390.h	/^	ether_addr_t de_address;$/;"	m	struct:dpeth
de_arp_ethaddr	ip_int.h	/^			ether_addr_t de_arp_ethaddr;$/;"	m	struct:ip_port::__anon21::__anon22
de_arp_pack	ip_int.h	/^			acc_t *de_arp_pack;$/;"	m	struct:ip_port::__anon21::__anon22
de_base_port	dp8390.h	/^	port_t de_base_port;$/;"	m	struct:dpeth
de_client	dp8390.h	/^	int de_client;$/;"	m	struct:dpeth
de_data_port	dp8390.h	/^	port_t de_data_port;$/;"	m	struct:dpeth
de_dp8390_port	dp8390.h	/^	port_t de_dp8390_port;$/;"	m	struct:dpeth
de_fd	ip_int.h	/^			int de_fd;$/;"	m	struct:ip_port::__anon21::__anon22
de_flags	dp8390.h	/^	int de_flags;$/;"	m	struct:dpeth
de_flags	ip_int.h	/^			int de_flags;$/;"	m	struct:ip_port::__anon21::__anon22
de_getblockf	dp8390.h	/^	dp_getblock_t de_getblockf; $/;"	m	struct:dpeth
de_initf	dp8390.h	/^	dp_initf_t de_initf; $/;"	m	struct:dpeth
de_irq	dp8390.h	/^	int de_irq;$/;"	m	struct:dpeth
de_linmem	dp8390.h	/^	phys_bytes de_linmem;$/;"	m	struct:dpeth
de_memsegm	dp8390.h	/^	segm_t de_memsegm;$/;"	m	struct:dpeth
de_mode	dp8390.h	/^	int de_mode;$/;"	m	struct:dpeth
de_nic2userf	dp8390.h	/^	dp_nic2userf_t de_nic2userf; $/;"	m	struct:dpeth
de_offset_page	dp8390.h	/^	int de_offset_page;$/;"	m	struct:dpeth
de_port	ip_int.h	/^			int de_port;$/;"	m	struct:ip_port::__anon21::__anon22
de_prog_IO	dp8390.h	/^	int de_prog_IO;$/;"	m	struct:dpeth
de_ramsize	dp8390.h	/^	int de_ramsize;$/;"	m	struct:dpeth
de_read_iovec	dp8390.h	/^	iovec_dat_t de_read_iovec;$/;"	m	struct:dpeth
de_read_s	dp8390.h	/^	vir_bytes de_read_s;$/;"	m	struct:dpeth
de_sendmsg	dp8390.h	/^	message de_sendmsg;$/;"	m	struct:dpeth
de_sendq	dp8390.h	/^	} de_sendq[SENDQ_NR];$/;"	m	struct:dpeth	typeref:struct:dpeth::sendq
de_sendq_head	dp8390.h	/^	int de_sendq_head;		\/* Enqueue at the head *\/$/;"	m	struct:dpeth
de_sendq_nr	dp8390.h	/^	int de_sendq_nr;$/;"	m	struct:dpeth
de_sendq_tail	dp8390.h	/^	int de_sendq_tail;		\/* Dequeue at the tail *\/$/;"	m	struct:dpeth
de_startpage	dp8390.h	/^	int de_startpage;$/;"	m	struct:dpeth
de_stat	dp8390.h	/^	eth_stat_t de_stat;$/;"	m	struct:dpeth
de_state	ip_int.h	/^			int de_state;$/;"	m	struct:ip_port::__anon21::__anon22
de_stopf	dp8390.h	/^	dp_stopf_t de_stopf; $/;"	m	struct:dpeth
de_stoppage	dp8390.h	/^	int de_stoppage;$/;"	m	struct:dpeth
de_table	dp8390.c	/^static dpeth_t de_table[DE_PORT_NR];$/;"	v	file:
de_tmp_iovec	dp8390.h	/^	iovec_dat_t de_tmp_iovec;$/;"	m	struct:dpeth
de_user2nicf	dp8390.h	/^	dp_user2nicf_t de_user2nicf; $/;"	m	struct:dpeth
de_wr_ethaddr	ip_int.h	/^			ether_addr_t de_wr_ethaddr;$/;"	m	struct:ip_port::__anon21::__anon22
de_wr_frag	ip_int.h	/^			acc_t *de_wr_frag;$/;"	m	struct:ip_port::__anon21::__anon22
de_wr_frame	ip_int.h	/^			acc_t *de_wr_frame;$/;"	m	struct:ip_port::__anon21::__anon22
de_wr_ipaddr	ip_int.h	/^			ipaddr_t de_wr_ipaddr;$/;"	m	struct:ip_port::__anon21::__anon22
de_write_iovec	dp8390.h	/^	iovec_dat_t de_write_iovec;$/;"	m	struct:dpeth
debug	dp8390.c	62;"	d	file:
debug	ne2000.c	19;"	d	file:
debug	wdeth.c	18;"	d	file:
dec	boothead.s	/^	dec	di		! Do we allow another reset?$/;"	d
dec	boothead.s	/^	dec	dx		! Assume AT$/;"	d
dec	boothead.s	/^	dec	dx		! It is an XT$/;"	d
dec	extboot.s	/^	dec	di$/;"	d
dec	klib88.s	/^	dec	di$/;"	d
dec	masterboot.s	/^	dec	di$/;"	d
dec	trp.s	/^dec bx$/;"	l
defuse	floppy.c	/^PRIVATE void defuse()$/;"	f
defval	boot.h	/^	char	*defval;	\/* Safehouse for default values. *\/$/;"	m	struct:environment
defval	edparams.c	/^	char	*defval;	\/* Safehouse for default values. *\/$/;"	m	struct:environment	file:
del_char	editline.c	/^del_char()$/;"	f
del_slot	alloc.c	/^PRIVATE void del_slot(prev_ptr, hp)$/;"	f
delay	boot.c	/^int delay(char *msec)$/;"	f
delay	edparams.c	/^int delay(char *msec)$/;"	f
delete_string	editline.c	/^delete_string(count)$/;"	f
delwin	windel.c	/^void delwin(win)$/;"	f
desctableptr_s	protect.c	/^struct desctableptr_s {$/;"	s	file:
dest	ether.h	/^    ether_addr dest;$/;"	m	struct:etherpacket
dest	ether.h	/^    ether_addr dest;$/;"	m	struct:ethervec
dev_io	device.c	/^PUBLIC int dev_io(op, nonblock, dev, pos, bytes, proc, buff)$/;"	f
dev_ioctl	tty.c	/^PRIVATE void dev_ioctl(tp)$/;"	f
dev_mess	device.c	/^PRIVATE message dev_mess;$/;"	v
dev_mess	mount.c	/^PRIVATE message dev_mess;$/;"	v
dev_mess	open.c	/^PRIVATE message dev_mess;$/;"	v
dev_opcl	device.c	/^PUBLIC void dev_opcl(task_nr, mess_ptr)$/;"	f
devhd	masterboot.s	/^devhd:		.ascii	"\/dev\/hd?\\b"$/;"	l
devhup	rs232.c	141;"	d	file:
device	boot.c	/^	int device, primary, secondary;$/;"	m	struct:biosdev	file:
device	boot.h	/^EXTERN u16_t device;		\/* Drive being booted from. *\/$/;"	v
device	bootblock.s	/^	device	   =	     0	! The boot device$/;"	d
device	driver.h	/^struct device {$/;"	s
device	edparams.c	/^int device;			\/* Device to edit parameters. *\/$/;"	v
device	extboot.s	/^device:	.data1	0			! \/dev\/hd<drive><logical>$/;"	l
devname	edparams.c	/^char *devname;			\/* Name of device. *\/$/;"	v
devqual	aha_scsi.c	/^    byte devqual;		\/* Device-Type Qualifier *\/$/;"	m	struct:__anon9	file:
devready	rs232.c	129;"	d	file:
devready	rs232.c	167;"	d	file:
devtype	aha_scsi.c	/^    byte devtype;		\/* Peripheral Device Type *\/$/;"	m	struct:__anon9	file:
devtype	aha_scsi.c	/^    char devtype;		\/* SCSI_DEVDISK, SCSI_DEVTAPE, ... *\/$/;"	m	struct:scsi	file:
di	protect.c	/^  reg_t di;$/;"	m	struct:tss_s	file:
di	type.h	/^  reg_t di;			\/* di through cx are not accessed in C *\/$/;"	m	struct:stackframe_s
diff	t11a.c	/^int diff(s1, s2)$/;"	f
diff	t11b.c	/^int diff(s1, s2)$/;"	f
difftime	difftime.c	/^difftime(time_t time1, time_t time0)$/;"	f
dindir	rawfs.c	/^static char dindir[BLOCK_SIZE];		\/* Double indirect block. *\/$/;"	v	file:
dir	test17.c	/^								   "r-x", "rw-", "rwx"}, *dir[8] = {"d---", "d--x", "d-w-", "d-wx", "dr--", "dr-x",$/;"	v
dir	test17.c	/^char *dir[];$/;"	v
dir	test18.c	/^								   "r-x", "rw-", "rwx"}, *dir[8] = {"d---", "d--x", "d-w-", "d-wx", "dr--", "dr-x",$/;"	v
dir	test18.c	/^char *dir[];$/;"	v
dirbuf	rawfs.c	/^static char dirbuf[BLOCK_SIZE];		\/* Scratch\/Directory block. *\/$/;"	v	file:
direct	rawfs.c	41;"	d	file:
dirpos	rawfs.c	/^static off_t dirpos;			\/* Reading pos in a dir. *\/$/;"	v	file:
dis_already	klib386.s	/^dis_already:$/;"	l
dis_already	klib88.s	/^dis_already:$/;"	l
disable_0	klib386.s	/^disable_0:$/;"	l
disable_0	klib88.s	/^disable_0:$/;"	l
disable_8	klib386.s	/^disable_8:$/;"	l
disable_8	klib88.s	/^disable_8:$/;"	l
disaster	ps.c	/^void disaster(sig)$/;"	f
disk	aha_scsi.c	/^	} disk;$/;"	m	union:scsi::__anon12	typeref:struct:scsi::__anon12::__anon14	file:
div	div.c	/^div(register int numer, register int denom)$/;"	f
div_ext	div_ext.c	/^div_ext(e1,e2)$/;"	f
div_hi_port	rs232.c	/^  port_t div_hi_port;$/;"	m	struct:rs232	file:
div_low_port	rs232.c	/^  port_t div_low_port;$/;"	m	struct:rs232	file:
divb	extboot.s	/^	divb	dl			! al = disk, ah = partition within disk$/;"	d
divb	masterboot.s	/^	divb	dl			! al = disk, ah = partition within disk$/;"	d
dl_eth	ip_int.h	/^		} dl_eth;$/;"	m	union:ip_port::__anon21	typeref:struct:ip_port::__anon21::__anon22
dll_eth_arp_func	ip_write.c	/^PRIVATE void dll_eth_arp_func (port, ethaddr)$/;"	f
dll_eth_get_work	ip_write.c	/^PRIVATE void dll_eth_get_work(ip_port)$/;"	f
dll_eth_ready	ip_write.c	/^PRIVATE int dll_eth_ready (port, dst)$/;"	f
dll_eth_write	ip_write.c	/^PRIVATE void dll_eth_write (ip_port, dst, pack)$/;"	f
dll_eth_write_frame	ip_write.c	/^PUBLIC void dll_eth_write_frame (ip_port)$/;"	f
dll_ready	ip_write.c	/^PRIVATE int dll_ready(port, dst)$/;"	f
dll_write	ip_write.c	/^PRIVATE void dll_write (port, dst, pack)$/;"	f
dma	bios_wini.c	/^  phys_bytes dma;		\/* DMA physical address *\/$/;"	m	struct:trans	file:
dma	esdi_wini.c	/^  phys_bytes dma;		\/* DMA physical address                  *\/$/;"	m	struct:trans	file:
dma_bytes_left	driver.h	26;"	d
dma_bytes_left	sb16.h	170;"	d
dma_channel	esdi_wini.c	/^PRIVATE int dma_channel;	\/* fixed disk dma channel number         *\/$/;"	v
dma_setup	floppy.c	/^PRIVATE void dma_setup(tp)$/;"	f
dma_t	aha_scsi.c	/^} dma_t;$/;"	t	typeref:struct:__anon11	file:
dmalimit	aha_scsi.c	/^  dma_t *dmalimit;		\/* adapter model dependent limit to list *\/$/;"	m	struct:request	file:
dmalist	aha_scsi.c	/^  dma_t dmalist[NR_IOREQS];	\/* scatter\/gather dma list *\/$/;"	m	struct:request	file:
dmap	dev.h	/^extern struct dmap {$/;"	s
dmap	table.c	/^PUBLIC struct dmap dmap[] = {$/;"	v	typeref:struct:dmap
dmap_close	dev.h	/^  dmap_t dmap_close;$/;"	m	struct:dmap
dmap_open	dev.h	/^  dmap_t dmap_open;$/;"	m	struct:dmap
dmap_rw	dev.h	/^  dmap_t dmap_rw;$/;"	m	struct:dmap
dmap_task	dev.h	/^  int dmap_task;$/;"	m	struct:dmap
dmaptr	aha_scsi.c	/^  dma_t *dmaptr;		\/* to add scatter\/gather entries *\/$/;"	m	struct:request	file:
dn_comp	res_comp.c	/^dn_comp(exp_dn, comp_dn, length, dnptrs, lastdnptr)$/;"	f
dn_expand	res_comp.c	/^dn_expand(msg, eomorig, comp_dn, exp_dn, length)$/;"	f
dn_find	res_comp.c	/^dn_find(exp_dn, msg, dnptrs, lastdnptr)$/;"	f	file:
dn_skipname	res_comp.c	/^dn_skipname(comp_dn, eom)$/;"	f
doRainbow	ÏÂÔØËµÃ÷.htm	/^function doRainbow()$/;"	f
doRainbowAnchor	ÏÂÔØËµÃ÷.htm	/^function doRainbowAnchor()$/;"	f
do_abort	system.c	/^PRIVATE int do_abort(m_ptr)$/;"	f
do_alarm	signal.c	/^PUBLIC int do_alarm()$/;"	f
do_brk	break.c	/^PUBLIC int do_brk()$/;"	f
do_cancel	printer.c	/^PRIVATE void do_cancel(m_ptr)$/;"	f
do_cancel	tty.c	/^PRIVATE void do_cancel(tp, m_ptr)$/;"	f
do_case	editline.c	/^do_case(type)$/;"	f
do_chdir	stadir.c	/^PUBLIC int do_chdir()$/;"	f
do_check	test39.c	/^int do_check()$/;"	f
do_chroot	stadir.c	/^PUBLIC int do_chroot()$/;"	f
do_clocktick	clock.c	/^PRIVATE void do_clocktick()$/;"	f
do_close	open.c	/^PUBLIC int do_close()$/;"	f
do_close	tty.c	/^PRIVATE void do_close(tp, m_ptr)$/;"	f
do_copy	system.c	/^PRIVATE int do_copy(m_ptr)$/;"	f
do_creat	open.c	/^PUBLIC int do_creat()$/;"	f
do_diocntl	driver.c	/^PUBLIC int do_diocntl(dp, m_ptr)$/;"	f
do_done	printer.c	/^PRIVATE void do_done()$/;"	f
do_endsig	system.c	/^PRIVATE int do_endsig(m_ptr)$/;"	f
do_escape	console.c	/^PRIVATE void do_escape(cons, c)$/;"	f
do_eth_read	ip.c	/^PRIVATE void do_eth_read(port)$/;"	f
do_exec	exec.c	/^PUBLIC int do_exec()$/;"	f
do_exec	system.c	/^PRIVATE int do_exec(m_ptr)$/;"	f
do_fork	forkexit.c	/^PUBLIC int do_fork()$/;"	f
do_fork	system.c	/^PRIVATE int do_fork(m_ptr)$/;"	f
do_forward	editline.c	/^do_forward(move)$/;"	f
do_fresh	system.c	/^PRIVATE int do_fresh(m_ptr)     \/* for 68000 only *\/$/;"	f
do_fstat	stadir.c	/^PUBLIC int do_fstat()$/;"	f
do_gboot	system.c	/^PRIVATE int do_gboot(m_ptr)$/;"	f
do_get_time	clock.c	/^PRIVATE void do_get_time()$/;"	f
do_getmap	system.c	/^PRIVATE int do_getmap(m_ptr)$/;"	f
do_getset	getset.c	/^PUBLIC int do_getset()$/;"	f
do_getsp	system.c	/^PRIVATE int do_getsp(m_ptr)$/;"	f
do_getstat	dp8390.c	/^static void do_getstat(mp)$/;"	f	file:
do_getuptime	clock.c	/^PRIVATE void do_getuptime()$/;"	f
do_hist	editline.c	/^do_hist(move)$/;"	f
do_init	dp8390.c	/^static void do_init(mp)$/;"	f	file:
do_insert_hist	editline.c	/^do_insert_hist(p)$/;"	f
do_int	dp8390.c	/^static void do_int(dep)$/;"	f	file:
do_ioctl	device.c	/^PUBLIC int do_ioctl()$/;"	f
do_ioctl	tty.c	/^PRIVATE void do_ioctl(tp, m_ptr)$/;"	f
do_ioctl_compat	tty.c	/^PRIVATE void do_ioctl_compat(tp, m_ptr)$/;"	f
do_kill	signal.c	/^PUBLIC int do_kill()$/;"	f
do_kill	system.c	/^PRIVATE int do_kill(m_ptr)$/;"	f
do_ksig	signal.c	/^PUBLIC int do_ksig()$/;"	f
do_link	link.c	/^PUBLIC int do_link()$/;"	f
do_lseek	open.c	/^PUBLIC int do_lseek()$/;"	f
do_macro	editline.c	/^do_macro(c)$/;"	f
do_mem	system.c	/^PRIVATE int do_mem(m_ptr)$/;"	f
do_mkdir	open.c	/^PUBLIC int do_mkdir()$/;"	f
do_mknod	open.c	/^PUBLIC int do_mknod()$/;"	f
do_mm_exit	forkexit.c	/^PUBLIC int do_mm_exit()$/;"	f
do_mount	mount.c	/^PUBLIC int do_mount()$/;"	f
do_newmap	system.c	/^PRIVATE int do_newmap(m_ptr)$/;"	f
do_nop	driver.c	/^PUBLIC int do_nop(dp, m_ptr)$/;"	f
do_open	open.c	/^PUBLIC int do_open()$/;"	f
do_open	tty.c	/^PRIVATE void do_open(tp, m_ptr)$/;"	f
do_pause	signal.c	/^PUBLIC int do_pause()$/;"	f
do_pipe	pipe.c	/^PUBLIC int do_pipe()$/;"	f
do_pty	pty.c	/^PUBLIC void do_pty(tp, m_ptr)$/;"	f
do_pty	tty.c	88;"	d	file:
do_rdwt	driver.c	/^PUBLIC int do_rdwt(dp, m_ptr)$/;"	f
do_read	read.c	/^PUBLIC int do_read()$/;"	f
do_read	tty.c	/^PRIVATE void do_read(tp, m_ptr)$/;"	f
do_reboot	signal.c	/^PUBLIC int do_reboot()$/;"	f
do_rename	link.c	/^PUBLIC int do_rename()$/;"	f
do_sendrec	mnx_eth.c	/^PRIVATE int do_sendrec (tofrom, mptr1, mptr2)$/;"	f
do_sendsig	system.c	/^PRIVATE int do_sendsig(m_ptr)$/;"	f
do_set_time	clock.c	/^PRIVATE void do_set_time(m_ptr)$/;"	f
do_setalarm	clock.c	/^PRIVATE void do_setalarm(m_ptr)$/;"	f
do_setsid	device.c	/^PUBLIC int do_setsid()$/;"	f
do_setsyn_alrm	clock.c	/^PRIVATE void do_setsyn_alrm(m_ptr)$/;"	f
do_sigaction	signal.c	/^PUBLIC int do_sigaction()$/;"	f
do_sigpending	signal.c	/^PUBLIC int do_sigpending()$/;"	f
do_sigprocmask	signal.c	/^PUBLIC int do_sigprocmask()$/;"	f
do_sigreturn	signal.c	/^PUBLIC int do_sigreturn()$/;"	f
do_sigreturn	system.c	/^PRIVATE int do_sigreturn(m_ptr)$/;"	f
do_sigsuspend	signal.c	/^PUBLIC int do_sigsuspend()$/;"	f
do_stat	stadir.c	/^PUBLIC int do_stat()$/;"	f
do_stime	time.c	/^PUBLIC int do_stime()$/;"	f
do_stop	dp8390.c	/^static void do_stop(mp)$/;"	f	file:
do_time	time.c	/^PUBLIC int do_time()$/;"	f
do_times	system.c	/^PRIVATE int do_times(m_ptr)$/;"	f
do_tims	time.c	/^PUBLIC int do_tims()$/;"	f
do_trace	system.c	/^PRIVATE int do_trace(m_ptr)$/;"	f
do_trace	trace.c	/^PUBLIC int do_trace()$/;"	f
do_umap	system.c	/^PRIVATE int do_umap(m_ptr)$/;"	f
do_umount	mount.c	/^PUBLIC int do_umount()$/;"	f
do_unlink	link.c	/^PUBLIC int do_unlink()$/;"	f
do_unpause	pipe.c	/^PUBLIC int do_unpause()$/;"	f
do_utime	time.c	/^PUBLIC int do_utime()$/;"	f
do_vcopy	system.c	/^PRIVATE int do_vcopy(m_ptr)$/;"	f
do_vrdwt	driver.c	/^PUBLIC int do_vrdwt(dp, m_ptr)$/;"	f
do_vread	dp8390.c	/^static void do_vread(mp, vectored)$/;"	f	file:
do_vwrite	dp8390.c	/^static void do_vwrite(mp, from_int, vectored)$/;"	f	file:
do_waitpid	forkexit.c	/^PUBLIC int do_waitpid()$/;"	f
do_write	flushbuf.c	/^do_write(int d, char *buf, int nbytes)$/;"	f	file:
do_write	printer.c	/^PRIVATE void do_write(m_ptr)$/;"	f
do_write	tty.c	/^PRIVATE void do_write(tp, m_ptr)$/;"	f
do_write	write.c	/^PUBLIC int do_write()$/;"	f
do_xit	system.c	/^PRIVATE int do_xit(m_ptr)$/;"	f
doit	boothead.s	/^doit:	movb	ah, 13(bp)	! Code for disk read (2) or write (3)$/;"	l
dolev	test9.c	/^void dolev()$/;"	f
done	_memmove.s	/^done:	mov	eax, 8(ebp)	! Absolutely noone cares about this value$/;"	l
done	_strncmp.s	/^done:	seta	al		! al = (s1 > s2)$/;"	l
done	bootblock.s	/^done:$/;"	l
done	boothead.s	/^done:	xorb	ah, ah		! No error here!$/;"	l
done	memset.s	/^done:	mov	eax, 8(ebp)	! Return some value you have no need for$/;"	l
done_status	printer.c	/^PRIVATE int done_status;	\/* status of last output completion *\/$/;"	v
dot1	path.c	/^PUBLIC char dot1[2] = ".";	\/* used for search_dir to bypass the access *\/$/;"	v
dot2	path.c	/^PUBLIC char dot2[3] = "..";	\/* permissions for . and ..		    *\/$/;"	v
doupdate	update.c	/^void doupdate()$/;"	f
downwards	_memmove.s	/^downwards:$/;"	l
dp8390_stop	dp8390.c	/^void dp8390_stop()$/;"	f
dp8390_task	dp8390.c	/^void dp8390_task()$/;"	f
dp_check_ints	dp8390.c	/^static void dp_check_ints(dep)$/;"	f	file:
dp_conf	dp8390.c	/^dp_conf_t dp_conf[]=	\/* Card addresses *\/$/;"	v
dp_conf	dp8390.c	/^typedef struct dp_conf$/;"	s	file:
dp_conf_t	dp8390.c	/^} dp_conf_t;$/;"	t	typeref:struct:dp_conf	file:
dp_confaddr	dp8390.c	/^static void dp_confaddr(dep)$/;"	f	file:
dp_dump	dp8390.c	/^void dp_dump()$/;"	f
dp_getblock	dp8390.c	/^static void dp_getblock(dep, page, offset, size, dst)$/;"	f	file:
dp_handler	dp8390.c	/^static int dp_handler(irq)$/;"	f	file:
dp_init	dp8390.c	/^static void dp_init(dep)$/;"	f	file:
dp_next_iovec	dp8390.c	/^static void dp_next_iovec(iovp)$/;"	f	file:
dp_nic2user	dp8390.c	/^static void dp_nic2user(dep, nic_addr, iovp, offset, count)$/;"	f	file:
dp_pio16_getblock	dp8390.c	/^static void dp_pio16_getblock(dep, page, offset, size, dst)$/;"	f	file:
dp_pio16_nic2user	dp8390.c	/^static void dp_pio16_nic2user(dep, nic_addr, iovp, offset, count)$/;"	f	file:
dp_pio16_user2nic	dp8390.c	/^static void dp_pio16_user2nic(dep, iovp, offset, nic_addr, count)$/;"	f	file:
dp_pio8_getblock	dp8390.c	/^static void dp_pio8_getblock(dep, page, offset, size, dst)$/;"	f	file:
dp_pio8_nic2user	dp8390.c	/^static void dp_pio8_nic2user(dep, nic_addr, iovp, offset, count)$/;"	f	file:
dp_pio8_user2nic	dp8390.c	/^static void dp_pio8_user2nic(dep, iovp, offset, nic_addr, count)$/;"	f	file:
dp_pkt2user	dp8390.c	/^static int dp_pkt2user(dep, page, length)$/;"	f	file:
dp_rcvhdr	dp8390.h	/^typedef struct dp_rcvhdr$/;"	s
dp_rcvhdr_t	dp8390.h	/^} dp_rcvhdr_t;$/;"	t	typeref:struct:dp_rcvhdr
dp_recv	dp8390.c	/^static void dp_recv(dep)$/;"	f	file:
dp_reinit	dp8390.c	/^static void dp_reinit(dep)$/;"	f	file:
dp_reset	dp8390.c	/^static void dp_reset(dep)$/;"	f	file:
dp_send	dp8390.c	/^static void dp_send(dep)$/;"	f	file:
dp_user2nic	dp8390.c	/^static void dp_user2nic(dep, iovp, offset, nic_addr, count)$/;"	f	file:
dpc_envvar	dp8390.c	/^	char *dpc_envvar;$/;"	m	struct:dp_conf	file:
dpc_irq	dp8390.c	/^	int dpc_irq;$/;"	m	struct:dp_conf	file:
dpc_mem	dp8390.c	/^	phys_bytes dpc_mem;$/;"	m	struct:dp_conf	file:
dpc_port	dp8390.c	/^	port_t dpc_port;$/;"	m	struct:dp_conf	file:
dpc_prot_sel	dp8390.c	/^	segm_t dpc_prot_sel;$/;"	m	struct:dp_conf	file:
dpeth	dp8390.h	/^typedef struct dpeth$/;"	s
dpeth_t	dp8390.h	/^} dpeth_t;$/;"	t	typeref:struct:dpeth
dpeth_tasknr	dp8390.c	/^static int dpeth_tasknr= ANY;$/;"	v	file:
dr_next	dp8390.h	/^	u8_t dr_next;			\/* Pointer to next packet            *\/$/;"	m	struct:dp_rcvhdr
dr_rbch	dp8390.h	/^	u8_t dr_rbch;			\/* Receive Byte Count High           *\/$/;"	m	struct:dp_rcvhdr
dr_rbcl	dp8390.h	/^	u8_t dr_rbcl;			\/* Receive Byte Count Low            *\/$/;"	m	struct:dp_rcvhdr
dr_status	dp8390.h	/^	u8_t dr_status;			\/* Copy of rsr                       *\/$/;"	m	struct:dp_rcvhdr
drain	rs232.c	/^  bool_t drain;			\/* if set drain output and reconfigure line *\/$/;"	m	struct:rs232	file:
driver	driver.h	/^struct driver {$/;"	s
driver_task	driver.c	/^PUBLIC void driver_task(dp)$/;"	f
ds	bootimage.c	/^	u32_t	ds;		\/* Data segment. *\/$/;"	m	struct:process	file:
ds	protect.c	/^  reg_t ds;$/;"	m	struct:tss_s	file:
ds	type.h	/^  u16_t ds;                     \/*  | *\/$/;"	m	struct:stackframe_s
ds_date	misc.c	/^	int ds_date[3];		\/* months, weeks, days *\/$/;"	m	struct:dsttype	file:
ds_ex_number	mpx88.s	/^ds_ex_number:$/;"	l
ds_real	boothead.s	/^ds_real:$/;"	l
ds_sec	misc.c	/^	long ds_sec;		\/* usually 02:00:00 *\/$/;"	m	struct:dsttype	file:
ds_type	misc.c	/^	char ds_type;		\/* Unknown, Julian, Zero-based or M *\/$/;"	m	struct:dsttype	file:
dsdd3	bootblock.s	/^dsdd3:	.data1	0xDF, 0x02, 25, 2,  9, 0x2A, 0xFF, 0x50, 0xF6, 15, 8$/;"	l
dshd3	bootblock.s	/^dshd3:	.data1	0xAF, 0x02, 25, 2, 18, 0x1B, 0xFF, 0x54, 0xF6, 15, 8$/;"	l
dshd5	bootblock.s	/^dshd5:	.data1	0xDF, 0x02, 25, 2, 15, 0x1B, 0xFF, 0x54, 0xF6, 15, 8$/;"	l
dskpars	boot.c	/^char dskpars[DSKPARSIZE]=	\/* 360K floppy disk parameters (for now). *\/$/;"	v
dsp_close	sb16_dsp.c	/^PRIVATE int dsp_close(m_ptr)$/;"	f
dsp_command	sb16_dsp.c	/^PRIVATE int dsp_command(value)$/;"	f
dsp_dma_setup	sb16_dsp.c	/^PRIVATE void dsp_dma_setup(address, count)$/;"	f
dsp_handler	sb16_dsp.c	/^PRIVATE int dsp_handler(irq)$/;"	f
dsp_init	sb16_dsp.c	/^PRIVATE int dsp_init()$/;"	f
dsp_ioctl	sb16_dsp.c	/^PRIVATE int dsp_ioctl(m_ptr)$/;"	f
dsp_open	sb16_dsp.c	/^PRIVATE int dsp_open(m_ptr)$/;"	f
dsp_read	sb16_dsp.c	/^PRIVATE int dsp_read(m_ptr)$/;"	f
dsp_reset	sb16_dsp.c	/^PRIVATE int dsp_reset(void)$/;"	f
dsp_set_bits	sb16_dsp.c	/^static int dsp_set_bits(bits)$/;"	f	file:
dsp_set_sign	sb16_dsp.c	/^static int dsp_set_sign(sign)$/;"	f	file:
dsp_set_size	sb16_dsp.c	/^static int dsp_set_size(size)$/;"	f	file:
dsp_set_speed	sb16_dsp.c	/^static int dsp_set_speed(speed)$/;"	f	file:
dsp_set_stereo	sb16_dsp.c	/^static int dsp_set_stereo(stereo)$/;"	f	file:
dsp_setup	sb16_dsp.c	/^PRIVATE void dsp_setup()$/;"	f
dsp_task	sb16_dsp.c	/^PUBLIC void dsp_task()$/;"	f
dsp_write	sb16_dsp.c	/^PRIVATE int dsp_write(m_ptr)$/;"	f
dstend	misc.c	/^	, dstend = { 'U', { 0, 0, 0 }, 2 * 60 * 60 };$/;"	v	typeref:struct:dsttype	file:
dstflag	misc.c	/^	short	dstflag;$/;"	m	struct:timeb	file:
dststart	misc.c	/^}	dststart = { 'U', { 0, 0, 0 }, 2 * 60 * 60 }$/;"	v	typeref:struct:dsttype	file:
dststr	misc.c	/^static char dststr[TZ_LEN + 1] = "GDT";	\/* string for daylight saving *\/$/;"	v	file:
dsttype	misc.c	/^static struct dsttype {$/;"	s	file:
dummy	type.h	/^  u16_t dummy;			\/* make size multiple of reg_t for system.c *\/$/;"	m	struct:stackframe_s
dummypart	aha_scsi.c	/^	    struct device dummypart;  \/* something for s_prepare to return *\/$/;"	m	struct:scsi::__anon12::__anon13	typeref:struct:scsi::__anon12::__anon13::device	file:
dummypart	aha_scsi.c	357;"	d	file:
dump_core	signal.c	/^PRIVATE void dump_core(rmp)$/;"	f
dump_scsi_cmd	aha_scsi.c	/^PRIVATE void dump_scsi_cmd()$/;"	f
dump_scsi_cmd	aha_scsi.c	468;"	d	file:
dup	_dup.c	/^PUBLIC int dup(fd)$/;"	f
dup	_dup.c	2;"	d	file:
dup2	_dup2.c	/^PUBLIC int dup2(fd, fd2)$/;"	f
dup2	_dup2.c	3;"	d	file:
dup2	crypt.c	10;"	d	file:
dup_inode	inode.c	/^PUBLIC void dup_inode(ip)$/;"	f
dv_base	driver.h	/^  unsigned long	dv_base;$/;"	m	struct:device
dv_size	driver.h	/^  unsigned long dv_size;$/;"	m	struct:device
dvf4	dvf4.c	/^dvf4(s2,s1)$/;"	f
dvf8	dvf8.c	/^dvf8(s2,s1)$/;"	f
dx	protect.c	/^  reg_t dx;$/;"	m	struct:tss_s	file:
dx	type.h	/^  reg_t dx;                     \/*  | *\/$/;"	m	struct:stackframe_s
e	FP_types.h	/^	int	e;$/;"	m	struct:fef4_returns
e	FP_types.h	/^	int	e;$/;"	m	struct:fef8_returns
e	common.c	/^void e(n)$/;"	f
e	t11a.c	/^void e(n)$/;"	f
e	t11b.c	/^void e(n)$/;"	f
e	test11.c	/^void e(n)$/;"	f
e	test14.c	/^void e(n)$/;"	f
e	test16.c	/^void e(n)$/;"	f
e	test17.c	/^void e(string)$/;"	f
e	test18.c	/^void e(string)$/;"	f
e	test19.c	/^void e(n)$/;"	f
e	test2.c	/^void e(n)$/;"	f
e	test20.c	/^void e(n)$/;"	f
e	test21.c	/^void e(n)$/;"	f
e	test22.c	/^void e(n)$/;"	f
e	test23.c	/^void e(n)$/;"	f
e	test24.c	/^void e(n)$/;"	f
e	test25.c	/^void e(n)$/;"	f
e	test26.c	/^void e(n)$/;"	f
e	test27.c	/^void e(n)$/;"	f
e	test28.c	/^void e(n)$/;"	f
e	test29.c	/^void e(n)$/;"	f
e	test3.c	/^void e(n)$/;"	f
e	test30.c	/^void e(n)$/;"	f
e	test31.c	/^void e(n)$/;"	f
e	test32.c	/^void e(n)$/;"	f
e	test33.c	/^void e(n)$/;"	f
e	test34.c	/^void e(n)$/;"	f
e	test35.c	/^void e(n)$/;"	f
e	test36.c	/^void e(n)$/;"	f
e	test37.c	/^void e(n)$/;"	f
e	test38.c	/^void e(n)$/;"	f
e	test39.c	/^void e(n)$/;"	f
e	test40.c	/^void e(n)$/;"	f
e	test5.c	/^void e(n)$/;"	f
e	test6.c	/^void e(n)$/;"	f
e	test7.c	/^void e(n)$/;"	f
e	test8.c	/^void e(n)$/;"	f
eat_path	path.c	/^PUBLIC struct inode *eat_path(path)$/;"	f
echo	setterm.c	/^void echo()$/;"	f
echo	tty.c	/^PRIVATE int echo(tp, ch)$/;"	f
echoit	curspriv.h	/^  bool     echoit;$/;"	m	struct:__anon20
editinput	editline.c	/^editinput()$/;"	f
ef_ethopt	eth.c	/^	nwio_ethopt_t ef_ethopt;$/;"	m	struct:eth_fd	file:
ef_exp_tim	eth.c	/^	time_t ef_exp_tim;$/;"	m	struct:eth_fd	file:
ef_flags	eth.c	/^	int ef_flags;$/;"	m	struct:eth_fd	file:
ef_get_userdata	eth.c	/^	get_userdata_t ef_get_userdata;$/;"	m	struct:eth_fd	file:
ef_pack_stat	eth.c	/^	int ef_pack_stat;$/;"	m	struct:eth_fd	file:
ef_port	eth.c	/^	eth_port_t *ef_port;$/;"	m	struct:eth_fd	file:
ef_put_userdata	eth.c	/^	put_userdata_t ef_put_userdata;$/;"	m	struct:eth_fd	file:
ef_rd_buf	eth.c	/^	acc_t *ef_rd_buf;$/;"	m	struct:eth_fd	file:
ef_rd_tail	eth.c	/^	acc_t *ef_rd_tail;$/;"	m	struct:eth_fd	file:
ef_srfd	eth.c	/^	int ef_srfd;$/;"	m	struct:eth_fd	file:
ef_write_count	eth.c	/^	size_t ef_write_count;$/;"	m	struct:eth_fd	file:
eff_grp_id	param.h	7;"	d
eff_user_id	param.h	8;"	d
ega	glo.h	/^EXTERN int ega;			\/* nonzero if console is EGA *\/$/;"	v
el_weirdo	test3.c	/^char el_weirdo[] = "\\n\\t\\\\\\e@@!!##\\e\\e\\n\\n";$/;"	v
emacs	editline.c	/^emacs(c)$/;"	f
enable_0	klib386.s	/^enable_0:$/;"	l
enable_0	klib88.s	/^enable_0:$/;"	l
enable_8	klib386.s	/^enable_8:$/;"	l
enable_8	klib88.s	/^enable_8:$/;"	l
enable_iop	protect.c	/^PUBLIC void enable_iop(pp)$/;"	f
enable_vectors	bios_wini.c	/^PRIVATE void enable_vectors()$/;"	f
end	bootimage.c	/^	u32_t	end;		\/* End of this process, size = (end - cs). *\/$/;"	m	struct:process	file:
end_line	editline.c	/^end_line()$/;"	f
end_patch_table	klib88.s	/^end_patch_table:		! end of table$/;"	l
endbss	bootblock.s	/^endbss:$/;"	l
endbss	em_end.s	/^endbss:$/;"	l
endbss	extboot.s	/^endbss:$/;"	l
endbss	masterboot.s	/^endbss:$/;"	l
enddata	bootblock.s	/^enddata:$/;"	l
enddata	em_end.s	/^enddata:$/;"	l
enddata	extboot.s	/^enddata:$/;"	l
enddata	masterboot.s	/^enddata:$/;"	l
endgrent	getgrent.c	/^void endgrent(void)$/;"	f
endhostent	gethostent.c	/^endhostent()$/;"	f
endhostent	gethostent.c	28;"	d	file:
endprotoent	getprotoent.c	/^endprotoent()$/;"	f
endpwent	getpwent.c	/^void endpwent(void)$/;"	f
endrom	em_end.s	/^endrom:$/;"	l
endservent	getservent.c	/^endservent()$/;"	f
endtext	bootblock.s	/^endtext:$/;"	l
endtext	em_end.s	/^endtext:$/;"	l
endtext	extboot.s	/^endtext:$/;"	l
endtext	masterboot.s	/^endtext:$/;"	l
endttyent	getttyent.c	/^void endttyent(void)$/;"	f
endwin	endwin.c	/^int endwin()$/;"	f
enqueue_pack	icmp.c	/^PRIVATE void enqueue_pack(icmp_port, reply_ip_hdr)$/;"	f
entry	bootimage.c	/^	u32_t	entry;		\/* Entry point. *\/$/;"	m	struct:process	file:
entry	getgrent.c	/^static struct group entry;		\/* Entry to fill and return. *\/$/;"	v	typeref:struct:group	file:
entry	getpwent.c	/^static struct passwd entry;		\/* Entry to fill and return. *\/$/;"	v	typeref:struct:passwd	file:
entry	getttyent.c	/^static struct ttyent entry;		\/* Entry to fill and return. *\/$/;"	v	typeref:struct:ttyent	file:
env	boot.h	/^EXTERN environment *env;	\/* Lists the environment. *\/$/;"	v
env	edparams.c	/^environment *env;		\/* Lists the environment. *\/$/;"	v
env	test9.c	/^jmp_buf env;$/;"	v
environ	environ.c	/^char **environ = (char **) 0x53535353;$/;"	v
environ	environ.c	/^char **environ = (char **) 0x5353;$/;"	v
environment	boot.h	/^typedef struct environment {$/;"	s
environment	boot.h	/^} environment;$/;"	t	typeref:struct:environment
environment	edparams.c	/^typedef struct environment {$/;"	s	file:
environment	edparams.c	/^} environment;$/;"	t	typeref:struct:environment	file:
envp	test11.c	/^char *envp[3] = {"spring", "summer", 0};$/;"	v
equal	bcmp.s	/^equal:	leave$/;"	l
equal	test15.c	/^void equal(a, b, number)$/;"	f
erasechar	termmisc.c	/^int erasechar()$/;"	f
erki	param.h	9;"	d
err	boot.c	/^int err;		\/* Set on an error. *\/$/;"	v
err	edparams.c	/^int err;		\/* Set on an error. *\/$/;"	v
err	mtab.c	/^err(prog_name, str)$/;"	f
err	ps.c	/^void err(s)$/;"	f
err	test17.c	/^void err(number, scall, name)$/;"	f
err	test18.c	/^void err(number, scall, name)$/;"	f
err_no_retry	floppy.c	110;"	d	file:
errc	aha_scsi.c	/^    byte errc;			\/* Error Code, Error Class, and Valid bit *\/$/;"	m	struct:__anon8	file:
errct	common.c	/^int common_test_nr = -1, errct = 0, subtest;$/;"	v
errct	init.c	/^  int errct;			\/* error count *\/$/;"	m	struct:slotent	file:
errct	t11a.c	/^int errct, subtest=1;$/;"	v
errct	t11b.c	/^int errct, subtest=1;$/;"	v
errct	test1.c	/^int errct;$/;"	v
errct	test10.c	/^int errct;$/;"	v
errct	test11.c	/^int errct, subtest;$/;"	v
errct	test12.c	/^int errct = 0;$/;"	v
errct	test13.c	/^int errct = 0;$/;"	v
errct	test14.c	/^int errct;$/;"	v
errct	test15.c	/^int errct;			\/* count errors *\/$/;"	v
errct	test16.c	/^int errct, subtest, passes;$/;"	v
errct	test17.c	/^int errct;$/;"	v
errct	test18.c	/^int errct;$/;"	v
errct	test19.c	/^int errct, subtest, passes, pipesigs;$/;"	v
errct	test2.c	/^int is, array[4], parsigs, parcum, sigct, cumsig, errct, subtest;$/;"	v
errct	test2.c	/^int iteration, kk = 0, errct = 0;$/;"	v
errct	test20.c	/^int subtest, errct;$/;"	v
errct	test21.c	/^int subtest, errct;$/;"	v
errct	test22.c	/^int errct = 0;			\/* Total error counter. *\/$/;"	v
errct	test23.c	/^int errct;$/;"	v
errct	test24.c	/^int errct = 0;$/;"	v
errct	test25.c	/^int errct = 0;$/;"	v
errct	test26.c	/^int errct = 0;$/;"	v
errct	test27.c	/^int errct = 0;$/;"	v
errct	test28.c	/^int errct = 0;$/;"	v
errct	test29.c	/^int errct = 0;$/;"	v
errct	test3.c	/^int errct, subtest;$/;"	v
errct	test30.c	/^int errct = 0;$/;"	v
errct	test31.c	/^int errct = 0;$/;"	v
errct	test32.c	/^int errct = 0;$/;"	v
errct	test33.c	/^int errct = 0;$/;"	v
errct	test34.c	/^int errct = 0;$/;"	v
errct	test35.c	/^int errct = 0;$/;"	v
errct	test36.c	/^int errct = 0;$/;"	v
errct	test37.c	/^int errct = 0;$/;"	v
errct	test38.c	/^int errct = 0;$/;"	v
errct	test39.c	/^int errct = 0;$/;"	v
errct	test4.c	/^int s, i, fd, nextb, errct = 0;$/;"	v
errct	test40.c	/^int errct = 0;$/;"	v
errct	test5.c	/^int errct;$/;"	v
errct	test6.c	/^int errct;$/;"	v
errct	test7.c	/^int subtest, errct, xfd;$/;"	v
errct	test8.c	/^int iteration, cumsig, subtest, errct = 0, sig1, sig2;$/;"	v
errend	bootblock.s	/^errend:$/;"	l
errexception	mpx386.s	/^errexception:$/;"	l
errexception	mpx88.s	/^errexception:$/;"	l
errno	errno.c	/^int errno = 0;$/;"	v
error	bootblock.s	/^error:$/;"	l
error	extboot.s	/^error:$/;"	l
error	masterboot.s	/^error:$/;"	l
error0	extboot.s	/^error0:	jb	error$/;"	l
error0	masterboot.s	/^error0:	jb	error1			! Not supposed to fail$/;"	l
error1	masterboot.s	/^error1:	jb	error			! No disk?$/;"	l
error_reply	ip_write.c	/^PRIVATE void error_reply (ip_fd, error)$/;"	f
errordump	aha_scsi.c	/^PRIVATE void errordump()$/;"	f
errordump	aha_scsi.c	456;"	d	file:
es	protect.c	/^  reg_t es;$/;"	m	struct:tss_s	file:
es	type.h	/^  u16_t es;                     \/*  | *\/$/;"	m	struct:stackframe_s
esc	keyboard.c	/^PRIVATE int esc;		\/* escape scan code detected? *\/$/;"	v
esdi_winchester_task	esdi_wini.c	/^PUBLIC void esdi_winchester_task()$/;"	f
eseg	klib386.s	/^eseg o16 movs				! copy video words$/;"	l
etc_mtab	mtab.c	/^char *etc_mtab = "\/etc\/mtab";	  \/* name of the \/etc\/mtab file *\/$/;"	v
eth_addrcmp	eth.h	13;"	d
eth_arrive	eth.c	/^PUBLIC void eth_arrive (eth_port, pack)$/;"	f
eth_buffree	eth.c	/^PRIVATE void eth_buffree (priority, reqsize)$/;"	f
eth_cancel	eth.c	/^PUBLIC int eth_cancel(fd, which_operation)$/;"	f
eth_checkopt	eth.c	/^PRIVATE int eth_checkopt (eth_fd)$/;"	f
eth_close	eth.c	/^PUBLIC void eth_close(fd)$/;"	f
eth_fd	eth.c	/^typedef struct eth_fd$/;"	s	file:
eth_fd_t	eth.c	/^} eth_fd_t;$/;"	t	typeref:struct:eth_fd	file:
eth_fd_table	eth.c	/^PRIVATE eth_fd_t eth_fd_table[ETH_FD_NR];$/;"	v
eth_get_stat	mnx_eth.c	/^PUBLIC int eth_get_stat(eth_port, eth_stat)$/;"	f
eth_get_work	eth.c	/^PUBLIC int eth_get_work(eth_port)$/;"	f
eth_ign_proto	dp8390.c	/^static u16_t eth_ign_proto;$/;"	v	file:
eth_init	eth.c	/^PUBLIC void eth_init()$/;"	f
eth_init0	mnx_eth.c	/^PUBLIC void eth_init0()$/;"	f
eth_ioctl	eth.c	/^PUBLIC int eth_ioctl(fd, req)$/;"	f
eth_open	eth.c	/^PUBLIC int eth_open(port, srfd, get_userdata, put_userdata)$/;"	f
eth_port	eth_int.h	/^typedef struct eth_port$/;"	s
eth_port_t	eth_int.h	/^} eth_port_t;$/;"	t	typeref:struct:eth_port
eth_port_table	eth.c	/^PUBLIC eth_port_t eth_port_table[ETH_PORT_NR];$/;"	v
eth_read	eth.c	/^PUBLIC int eth_read (fd, count)$/;"	f
eth_rec	mnx_eth.c	/^PUBLIC void eth_rec(m)$/;"	f
eth_set_rec_conf	mnx_eth.c	/^PUBLIC void eth_set_rec_conf (eth_port, flags)$/;"	f
eth_write	eth.c	/^PUBLIC int eth_write(fd, count)$/;"	f
eth_write_port	mnx_eth.c	/^PUBLIC void eth_write_port(eth_port)$/;"	f
ether_addr	ether.h	/^	  ether_addr;$/;"	t	typeref:union:etheraddr
ether_addr	ethere2a.c	14;"	d	file:
ether_aton	ethera2n.c	/^struct ether_addr *ether_aton(s)$/;"	f
ether_cmp	ether.h	118;"	d
ether_cmp	ether.h	120;"	d
ether_e2a	ethere2a.c	/^ether_e2a (addr, estring)$/;"	f
ether_hostton	etherh2n.c	/^ether_hostton(hostname, e)$/;"	f
ether_line	ether_line.c	/^ether_line(line, eaddr, hostname)$/;"	f
ether_ntoa	ethere2a.c	/^ether_ntoa (addr)$/;"	f
ether_ntohost	ethern2h.c	/^ether_ntohost(hostname, e)$/;"	f
ether_packet	ether.h	/^	    ether_packet;$/;"	t	typeref:struct:etherpacket
ether_vec	ether.h	/^	 ether_vec;$/;"	t	typeref:struct:ethervec
etheraddr	ether.h	/^typedef union etheraddr$/;"	u
etherpacket	ether.h	/^typedef struct etherpacket$/;"	s
ethervec	ether.h	/^typedef struct ethervec$/;"	s
etp_ethaddr	eth_int.h	/^	ether_addr_t etp_ethaddr;$/;"	m	struct:eth_port
etp_flags	eth_int.h	/^	int etp_flags;$/;"	m	struct:eth_port
etp_minor	osdep_eth.h	/^	int etp_minor;$/;"	m	struct:osdep_eth_port
etp_osdep	eth_int.h	/^	osdep_eth_port_t etp_osdep;$/;"	m	struct:eth_port
etp_port	osdep_eth.h	/^	int etp_port;$/;"	m	struct:osdep_eth_port
etp_rd_iovec	osdep_eth.h	/^	iovec_t etp_rd_iovec[RD_IOVEC];$/;"	m	struct:osdep_eth_port
etp_rd_pack	eth_int.h	/^	acc_t *etp_wr_pack, *etp_rd_pack;$/;"	m	struct:eth_port
etp_task	osdep_eth.h	/^	int etp_task;$/;"	m	struct:osdep_eth_port
etp_wr_iovec	osdep_eth.h	/^	iovec_t etp_wr_iovec[IOVEC_NR];$/;"	m	struct:osdep_eth_port
etp_wr_pack	eth_int.h	/^	acc_t *etp_wr_pack, *etp_rd_pack;$/;"	m	struct:eth_port
ex	test5.c	/^void ex()$/;"	f
ex_number	mpx88.s	/^ex_number:			! exception number$/;"	l
exception	exception.c	/^PUBLIC void exception(vec_nr)$/;"	f
exception	mpx386.s	/^exception:$/;"	l
exception	mpx88.s	/^exception:$/;"	l
exception1	mpx386.s	/^exception1:				! Common for all exceptions.$/;"	l
exchange	editline.c	/^exchange()$/;"	f
exchg	extboot.s	/^exchg:	movb	ah, (si)$/;"	l
exchg	masterboot.s	/^exchg:	movb	ah, (si)$/;"	l
exec_bootstrap	boot.c	/^int exec_bootstrap(dev_t dev)$/;"	f
exec_image	bootimage.c	/^void exec_image(char *image, char *params, size_t paramsize)$/;"	f
execl	_exec.c	/^PUBLIC int execl(const char *name, const char *arg, ...)$/;"	f
execl	_exec.c	2;"	d	file:
execl	crypt.c	11;"	d	file:
execle	_exec.c	/^PUBLIC int execle(const char *name, const char *arg, ...)$/;"	f
execle	_exec.c	3;"	d	file:
execlp	execlp.c	/^int execlp(const char *file, const char *arg, ...)$/;"	f
executable	test39.c	/^char executable[1024];$/;"	v
execute	boot.c	/^void execute(void)$/;"	f
execute	edparams.c	/^void execute(void)$/;"	f
execute	init.c	/^int execute(char **cmd)$/;"	f
execv	_exec.c	/^PUBLIC int execv(name, argv)$/;"	f
execv	_exec.c	4;"	d	file:
execve	_exec.c	/^PUBLIC int execve(path, argv, envp)$/;"	f
execve	_exec.c	5;"	d	file:
execvp	execlp.c	/^int execvp(const char *file, char *const argv[])$/;"	f
exit	exit.c	/^exit(int status)$/;"	f
exp	FP_types.h	/^	short	exp;$/;"	m	struct:__anon19
exp	exp.c	/^exp(double x)$/;"	f
exp	ext_fmt.h	/^	short	exp;$/;"	m	struct:EXTEND
expired	boot.c	/^int expired(void)$/;"	f
expired	edparams.c	/^int expired(void)$/;"	f
ext_copy	boothead.s	/^ext_copy:$/;"	l
ext_memsize	glo.h	/^EXTERN unsigned ext_memsize;	\/* initialized by assembler startup code *\/$/;"	v
extbase	extboot.s	/^extbase:	.data4	0$/;"	l
extend	extend.c	/^extend(from,to,size)$/;"	f
extended	extboot.s	/^extended:$/;"	l
extpartition	drvlib.c	/^PRIVATE void extpartition(dp, extdev, extbase)$/;"	f
extra	aha_scsi.c	/^    char extra[20];		\/* Vendor specific *\/$/;"	m	struct:__anon9	file:
extract_image	installboot.c	/^void extract_image(char *image)$/;"	f
extractexec	installboot.c	/^void extractexec(FILE *imagef, char *image, FILE *procf, char *proc,$/;"	f
f	FP_types.h	/^	DOUBLE	f;$/;"	m	struct:fef8_returns
f	FP_types.h	/^	SINGLE	f;$/;"	m	struct:fef4_returns
f	test15.c	/^int f;$/;"	v
f_busy	floppy.c	/^PRIVATE int f_busy;		\/* BSY_IDLE, BSY_IO, BSY_WAKEN *\/$/;"	v
f_cleanup	floppy.c	/^PRIVATE void f_cleanup()$/;"	f
f_collect	doscan.c	/^f_collect(register int c, register FILE *stream, register unsigned int width)$/;"	f	file:
f_count	floppy.c	/^PRIVATE unsigned f_count;	\/* this many bytes to transfer *\/$/;"	v
f_device	floppy.c	/^PRIVATE int f_device;		\/* selected minor device *\/$/;"	v
f_do_open	floppy.c	/^PRIVATE int f_do_open(dp, m_ptr)$/;"	f
f_drive	floppy.c	/^PRIVATE int f_drive;		\/* selected drive *\/$/;"	v
f_dtab	floppy.c	/^PRIVATE struct driver f_dtab = {$/;"	v	typeref:struct:driver
f_dv	floppy.c	/^PRIVATE struct device *f_dv;	\/* device's base and size *\/$/;"	v	typeref:struct:device
f_finish	floppy.c	/^PRIVATE int f_finish()$/;"	f
f_fp	floppy.c	/^} floppy[NR_DRIVES], *f_fp;$/;"	v	typeref:struct:floppy
f_geometry	floppy.c	/^PRIVATE void f_geometry(entry)$/;"	f
f_handler	floppy.c	/^PRIVATE int f_handler(irq)$/;"	f
f_intr_wait	floppy.c	/^PRIVATE int f_intr_wait()$/;"	f
f_must	floppy.c	/^PRIVATE int f_must;		\/* must do part of the next track? *\/$/;"	v
f_name	floppy.c	/^PRIVATE char *f_name()$/;"	f
f_nexttrack	floppy.c	/^PRIVATE unsigned f_nexttrack;	\/* don't do blocks above this *\/$/;"	v
f_opcode	floppy.c	/^PRIVATE int f_opcode;		\/* DEV_READ or DEV_WRITE *\/$/;"	v
f_prepare	floppy.c	/^PRIVATE struct device *f_prepare(device)$/;"	f
f_reset	floppy.c	/^PRIVATE void f_reset()$/;"	f
f_results	floppy.c	/^PRIVATE char f_results[MAX_RESULTS];\/* the controller can give lots of output *\/$/;"	v
f_schedule	floppy.c	/^PRIVATE int f_schedule(proc_nr, iop)$/;"	f
f_sectors	floppy.c	/^PRIVATE int f_sectors;		\/* sectors per track of the floppy *\/$/;"	v
f_timeout	floppy.c	/^PRIVATE void f_timeout()$/;"	f
f_transfer	floppy.c	/^PRIVATE int f_transfer(fp, tp)$/;"	f
fabs	fabs.c	/^fabs(double x)$/;"	f
fail	extboot.s	/^fail:	call	print$/;"	l
fail	nlist.c	13;"	d	file:
fatal	cursesio.c	/^void fatal(s)$/;"	f
fatal	edparams.c	/^void fatal(char *label)$/;"	f
fatal	installboot.c	/^void fatal(char *label)$/;"	f
fclose	fclose.c	/^fclose(FILE *fp)$/;"	f
fcntl	_dup.c	3;"	d	file:
fcntl	_dup2.c	4;"	d	file:
fcntl	_fcntl.c	/^PUBLIC int fcntl(int fd, int cmd, ...)$/;"	f
fcntl	_fcntl.c	2;"	d	file:
fcntl	_opendir.c	7;"	d	file:
fcntl	getgrent.c	8;"	d	file:
fcntl	getpwent.c	8;"	d	file:
fcntl	getttyent.c	7;"	d	file:
fd	param.h	10;"	d
fd	test4.c	/^int s, i, fd, nextb, errct = 0;$/;"	v
fd2	param.h	11;"	d
fd_char	editline.c	/^fd_char()$/;"	f
fd_kill_word	editline.c	/^fd_kill_word()$/;"	f
fd_read	tcp_recv.c	/^PRIVATE void fd_read(tcp_fd)$/;"	f
fd_word	editline.c	/^fd_word()$/;"	f
fd_write	tcp_send.c	/^PRIVATE void fd_write (tcp_fd)$/;"	f
fdc_out	floppy.c	/^PRIVATE void fdc_out(val)$/;"	f
fdc_results	floppy.c	/^PRIVATE int fdc_results()$/;"	f
fdopen	fdopen.c	/^fdopen(fd, mode)$/;"	f
fef4	fef4.c	/^fef4(r,s1)$/;"	f
fef4_returns	FP_types.h	/^struct	fef4_returns {$/;"	s
fef8	fef8.c	/^fef8(r, s1)$/;"	f
fef8_returns	FP_types.h	/^struct	fef8_returns {$/;"	s
feof	feof.c	/^(feof)(FILE *stream)$/;"	f
ferror	ferror.c	/^(ferror)(FILE *stream)$/;"	f
fetch_name	utility.c	/^PUBLIC int fetch_name(path, len, flag)$/;"	f
fflush	fflush.c	/^fflush(FILE *stream)$/;"	f
ffs	ffs.c	/^int ffs(word)$/;"	f
fgetc	fgetc.c	/^fgetc(FILE *stream)$/;"	f
fgetpos	fgetpos.c	/^fgetpos(FILE *stream, fpos_t *pos)$/;"	f
fgets	fgets.c	/^fgets(char *s, register int n, register FILE *stream)$/;"	f
fif4	fif4.c	/^fif4(p,x,y)$/;"	f
fif4_returns	FP_types.h	/^struct fif4_returns {$/;"	s
fif8	fif8.c	/^fif8(p,x,y)$/;"	f
fif8_returns	FP_types.h	/^struct fif8_returns {$/;"	s
file	test17.c	/^char *file[20] = {"f0", "f1", "f2", "f3", "f4", "f5", "f6",$/;"	v
file	test17.c	/^char *file[];$/;"	v
file	test18.c	/^char *file[20] = {"f0", "f1", "f2", "f3", "f4", "f5", "f6",$/;"	v
file	test18.c	/^char *file[];$/;"	v
file_lock	lock.h	/^EXTERN struct file_lock {$/;"	s
file_lock	lock.h	/^} file_lock[NR_LOCKS];$/;"	v	typeref:struct:file_lock
file_vir2sec	bootimage.c	/^u32_t file_vir2sec(u32_t vsec)$/;"	f
fileno	fileno.c	/^(fileno)(FILE *stream)$/;"	f
filp	file.h	/^EXTERN struct filp {$/;"	s
filp	file.h	/^} filp[NR_FILPS];$/;"	v	typeref:struct:filp
filp_count	file.h	/^  int filp_count;		\/* how many file descriptors share this slot?*\/$/;"	m	struct:filp
filp_flags	file.h	/^  int filp_flags;		\/* flags from open and fcntl *\/$/;"	m	struct:filp
filp_ino	file.h	/^  struct inode *filp_ino;	\/* pointer to the inode *\/$/;"	m	struct:filp	typeref:struct:filp::inode
filp_mode	file.h	/^  mode_t filp_mode;		\/* RW bits, telling how file is opened *\/$/;"	m	struct:filp
filp_pos	file.h	/^  off_t filp_pos;		\/* file position *\/$/;"	m	struct:filp
find	masterboot.s	/^find:	cmpb	sysind(si), #0		! Partition type, nonzero when in use$/;"	l
find_ass_ent	ip_read.c	/^PRIVATE ip_ass_t *find_ass_ent (port, id, proto, src, dst)$/;"	f
find_best_conn	tcp.c	/^PRIVATE tcp_conn_t *find_best_conn(ip_hdr, tcp_hdr)$/;"	f
find_cache_ent	arp.c	/^PRIVATE arp_cache_t *find_cache_ent (eth_port, ipaddr, level, new_ent)$/;"	f
find_conn_entry	tcp.c	/^PRIVATE tcp_conn_t *find_conn_entry(locport, locaddr, remport, remaddr)$/;"	f
find_dev	device.c	/^PRIVATE void find_dev(dev)$/;"	f
find_empty_conn	tcp.c	/^PRIVATE tcp_conn_t *find_empty_conn()$/;"	f
find_filp	filedes.c	/^PUBLIC struct filp *find_filp(rip, bits)$/;"	f
find_share	exec.c	/^PUBLIC struct mproc *find_share(mp_ign, ino, dev, ctime)$/;"	f
find_unused_port	tcp.c	/^PRIVATE tcpport_t find_unused_port(fd)$/;"	f
find_unused_port	udp.c	/^PRIVATE udpport_t find_unused_port(fd)$/;"	f
find_word	editline.c	/^find_word()$/;"	f
findactive	masterboot.s	/^findactive:$/;"	l
findproc	trace.c	/^PRIVATE struct mproc *findproc(lpid)$/;"	f
finish	boothead.s	/^finish:	movb	al, ah$/;"	l
first	test15.c	/^void first()$/;"	f
fix	masterboot.s	/^fix:	.data1	0			! If 1-9 then always boot that device$/;"	l
fixed	aha_scsi.c	188;"	d	file:
fixed_routes	ipr.c	/^PRIVATE int fixed_routes;$/;"	v
fixterm	termmisc.c	/^int fixterm()$/;"	f
fl_calibration	floppy.c	/^  char fl_calibration;		\/* CALIBRATED or UNCALIBRATED *\/$/;"	m	struct:floppy	file:
fl_class	floppy.c	/^  char fl_class;		\/* bitmap for possible densities *\/$/;"	m	struct:floppy	file:
fl_curcyl	floppy.c	/^  int fl_curcyl;		\/* current cylinder *\/$/;"	m	struct:floppy	file:
fl_cylinder	floppy.c	/^  int fl_cylinder;		\/* cylinder number addressed *\/$/;"	m	struct:floppy	file:
fl_density	floppy.c	/^  char fl_density;		\/* NO_DENS = ?, 0 = 360K; 1 = 360K\/1.2M; etc.*\/$/;"	m	struct:floppy	file:
fl_geom	floppy.c	/^  struct device fl_geom;	\/* Geometry of the drive *\/$/;"	m	struct:floppy	typeref:struct:floppy::device	file:
fl_hardcyl	floppy.c	/^  int fl_hardcyl;		\/* hardware cylinder, as opposed to: *\/$/;"	m	struct:floppy	file:
fl_head	floppy.c	/^  int fl_head;			\/* head number addressed *\/$/;"	m	struct:floppy	file:
fl_part	floppy.c	/^  struct device fl_part[NR_PARTITIONS];  \/* partition's base & size *\/$/;"	m	struct:floppy	typeref:struct:floppy::device	file:
fl_sector	floppy.c	/^  int fl_sector;		\/* sector addressed *\/$/;"	m	struct:floppy	file:
flags	aha_scsi.c	/^    byte flags;$/;"	m	struct:__anon9	file:
flags	boot.h	/^	char	flags;$/;"	m	struct:environment
flags	edparams.c	/^	char	flags;$/;"	m	struct:environment	file:
flags	mpx386.s	/^flags:$/;"	l
flags	protect.c	/^  reg_t flags;$/;"	m	struct:tss_s	file:
flash	flash.c	/^void flash()$/;"	f
flat_vir2sec	bootimage.c	/^u32_t flat_vir2sec(u32_t vsec)$/;"	f
flip	getprocessor.s	/^flip:$/;"	l
floor	floor.c	/^floor(double x)$/;"	f
floppy	bootblock.s	/^floppy:	mov	DSKBASE*4+0, di	! Load offset of disk parameters$/;"	l
floppy	boothead.s	/^floppy:$/;"	l
floppy	floppy.c	/^PRIVATE struct floppy {		\/* main drive struct, one entry per drive *\/$/;"	s	file:
floppy	floppy.c	/^} floppy[NR_DRIVES], *f_fp;$/;"	v	typeref:struct:floppy
floppy_stop	floppy.c	/^PUBLIC void floppy_stop()$/;"	f
floppy_task	floppy.c	/^PUBLIC void floppy_task()$/;"	f
flush	console.c	/^PRIVATE void flush(cons)$/;"	f
flush	putk.c	/^PRIVATE void flush()$/;"	f
flushall	cache.c	/^PUBLIC void flushall(dev)$/;"	f
fmod	fmod.c	/^fmod(double x, double y)$/;"	f
fmt_param	floppy.c	/^PRIVATE struct disk_parameter_s fmt_param; \/* parameters for format *\/$/;"	v	typeref:struct:disk_parameter_s
fnames	test17.c	/^	  "f14", "f15", "f16", "f17", "f18", "f19"}, *fnames[8] = {"---", "--x", "-w-", "-wx", "r--",$/;"	v
fnames	test17.c	/^char *fnames[];$/;"	v
fnames	test18.c	/^	  "f14", "f15", "f16", "f17", "f18", "f19"}, *fnames[8] = {"---", "--x", "-w-", "-wx", "r--",$/;"	v
fnames	test18.c	/^char *fnames[];$/;"	v
fopen	fopen.c	/^fopen(const char *name, const char *mode)$/;"	f
force_timeout	tty.h	89;"	d
fork	_fork.c	/^PUBLIC pid_t fork()$/;"	f
fork	_fork.c	2;"	d	file:
fork	crypt.c	8;"	d	file:
format	aha_scsi.c	/^    byte format;		\/* Response data format *\/$/;"	m	struct:__anon9	file:
found	strchr.s	/^found:	pop	eax		! Get rid of those flags$/;"	l
four_digits	asctime.c	/^four_digits(register char *pb, int i)$/;"	f	file:
fp	type.h	/^  reg_t fp;			\/* also known as a6 *\/$/;"	m	struct:stackframe_s
fp	type.h	/^  reg_t fp;			\/* bp *\/$/;"	m	struct:stackframe_s
fpN	type.h	/^	struct fpN {$/;"	s	struct:fsave::fpp_model
fpN	type.h	/^	} fpN[8];$/;"	m	struct:fsave::fpp_model	typeref:struct:fsave::fpp_model::fpN
fp_buffer	fproc.h	/^  char *fp_buffer;		\/* place to save buffer if rd\/wr can't finish*\/$/;"	m	struct:fproc
fp_cloexec	fproc.h	/^  long fp_cloexec;		\/* bit map for POSIX Table 6-2 FD_CLOEXEC *\/$/;"	m	struct:fproc
fp_cum_io_partial	fproc.h	/^  int  fp_cum_io_partial;	\/* partial byte count if rd\/wr can't finish *\/$/;"	m	struct:fproc
fp_effgid	fproc.h	/^  gid_t fp_effgid;		\/* effective group id *\/$/;"	m	struct:fproc
fp_effuid	fproc.h	/^  uid_t fp_effuid;		\/* effective user id *\/$/;"	m	struct:fproc
fp_fd	fproc.h	/^  int fp_fd;			\/* place to save fd if rd\/wr can't finish *\/$/;"	m	struct:fproc
fp_filp	fproc.h	/^  struct filp *fp_filp[OPEN_MAX];\/* the file descriptor table *\/$/;"	m	struct:fproc	typeref:struct:fproc::filp
fp_nbytes	fproc.h	/^  int  fp_nbytes;		\/* place to save bytes if rd\/wr can't finish *\/$/;"	m	struct:fproc
fp_pid	fproc.h	/^  pid_t fp_pid;			\/* process id *\/$/;"	m	struct:fproc
fp_realgid	fproc.h	/^  gid_t fp_realgid;		\/* real group id *\/$/;"	m	struct:fproc
fp_realuid	fproc.h	/^  uid_t fp_realuid;		\/* real user id *\/$/;"	m	struct:fproc
fp_revived	fproc.h	/^  char fp_revived;		\/* set to indicate process being revived *\/$/;"	m	struct:fproc
fp_rootdir	fproc.h	/^  struct inode *fp_rootdir;	\/* pointer to current root dir (see chroot) *\/$/;"	m	struct:fproc	typeref:struct:fproc::inode
fp_sesldr	fproc.h	/^  char fp_sesldr;		\/* true if proc is a session leader *\/$/;"	m	struct:fproc
fp_suspended	fproc.h	/^  char fp_suspended;		\/* set to indicate process hanging *\/$/;"	m	struct:fproc
fp_task	fproc.h	/^  char fp_task;			\/* which task is proc suspended on *\/$/;"	m	struct:fproc
fp_tty	fproc.h	/^  dev_t fp_tty;			\/* major\/minor of controlling tty *\/$/;"	m	struct:fproc
fp_umask	fproc.h	/^  mode_t fp_umask;		\/* mask set by umask system call *\/$/;"	m	struct:fproc
fp_workdir	fproc.h	/^  struct inode *fp_workdir;	\/* pointer to working directory's inode *\/$/;"	m	struct:fproc	typeref:struct:fproc::inode
fpart	FP_types.h	/^	DOUBLE fpart;$/;"	m	struct:fif8_returns
fpart	FP_types.h	/^	SINGLE fpart;$/;"	m	struct:fif4_returns
fpathconf	_fpathconf.c	/^PUBLIC long fpathconf(fd, name)$/;"	f
fpathconf	_fpathconf.c	5;"	d	file:
fpcr	type.h	/^	u32_t fpcr;$/;"	m	struct:fsave::fpp_model
fpiar	type.h	/^	u32_t fpiar;$/;"	m	struct:fsave::fpp_model
fpp_model	type.h	/^  struct fpp_model {$/;"	s	struct:fsave
fpp_model	type.h	/^  } fpp_model;$/;"	m	struct:fsave	typeref:struct:fsave::fpp_model
fprintf	fprintf.c	/^fprintf(FILE *stream, const char *format, ...)$/;"	f
fproc	fproc.h	/^EXTERN struct fproc {$/;"	s
fproc	fproc.h	/^} fproc[NR_PROCS];$/;"	v	typeref:struct:fproc
fpsr	type.h	/^	u32_t fpsr;$/;"	m	struct:fsave::fpp_model
fputc	fputc.c	/^fputc(int c, FILE *stream)$/;"	f
fputs	fputs.c	/^fputs(register const char *s, register FILE *stream)$/;"	f
frame	type.h	/^	u8_t frame[212];$/;"	m	struct:fsave::state_frame
frame_size	type.h	/^	u8_t frame_size;$/;"	m	struct:fsave::state_frame
frame_type	type.h	/^	u8_t frame_type;$/;"	m	struct:fsave::state_frame
framing_errors	rs232.c	/^  unsigned framing_errors;	\/* error counts (no reporting yet) *\/$/;"	m	struct:rs232	file:
fread	fread.c	/^fread(void *ptr, size_t size, size_t nmemb, register FILE *stream)$/;"	f
free	malloc.c	/^free(void *ptr)$/;"	f
free_bit	super.c	/^PUBLIC void free_bit(sp, map, bit_returned)$/;"	f
free_inode	inode.c	/^PUBLIC void free_inode(dev, inumb)$/;"	f
free_mem	alloc.c	/^PUBLIC void free_mem(base, clicks)$/;"	f
free_slots	alloc.c	/^PRIVATE struct hole *free_slots;	\/* ptr to list of unused table slots *\/$/;"	v	typeref:struct:hole
free_zone	cache.c	/^PUBLIC void free_zone(dev, numb)$/;"	f
freereq	buf.c	/^PRIVATE bf_freereq_t freereq[CLIENT_NR];$/;"	v
freopen	freopen.c	/^freopen(const char *name, const char *mode, FILE *stream)$/;"	f
fs	protect.c	/^  reg_t fs;$/;"	m	struct:tss_s	file:
fs	type.h	/^  u16_t fs;                     \/*  ^ *\/$/;"	m	struct:stackframe_s
fs_init	main.c	/^PRIVATE void fs_init()$/;"	f
fsave	type.h	/^struct fsave {$/;"	s
fsbuf	rawfs.c	56;"	d	file:
fscanf	fscanf.c	/^fscanf(FILE *stream, const char *format, ...)$/;"	f
fseek	fseek.c	/^fseek(FILE *stream, long int offset, int whence)$/;"	f
fsetpos	fsetpos.c	/^fsetpos(FILE *stream, fpos_t *pos)$/;"	f
fsok	boot.h	/^EXTERN int fsok;	\/* True if the boot device contains an FS. *\/$/;"	v
fstat	_fpathconf.c	4;"	d	file:
fstat	_fstat.c	/^PUBLIC int fstat(fd, buffer)$/;"	f
fstat	_fstat.c	2;"	d	file:
fstat	_opendir.c	8;"	d	file:
fsversion	fsversion.c	/^int fsversion(dev, prog)$/;"	f
ftell	ftell.c	/^long ftell(FILE *stream)$/;"	f
ftrans	floppy.c	/^} ftrans[MAX_SECTORS];$/;"	v	typeref:struct:trans
fttyslot	ttyslot.c	/^int fttyslot(fd)$/;"	f
func	test1.c	/^void func(s)$/;"	f
func1	test5.c	/^void func1(s)$/;"	f
func1	test8.c	/^void func1(sig)$/;"	f
func10	test5.c	/^void func10(s)$/;"	f
func11	test5.c	/^void func11(s)$/;"	f
func2	test8.c	/^void func2(sig)$/;"	f
func8	test5.c	/^void func8(s)$/;"	f
func_code	test7.c	/^int whence = SEEK_SET, func_code = F_SETLK;$/;"	v
func_key	keyboard.c	/^PRIVATE int func_key(scode)$/;"	f
funcalrm	test5.c	/^void funcalrm(s)$/;"	f
fwrite	fwrite.c	/^fwrite(const void *ptr, size_t size, size_t nmemb,$/;"	f
ga_program	console.c	/^PRIVATE void ga_program(seq)$/;"	f
gap	floppy.c	/^PRIVATE char gap[NT] =$/;"	v
garbage	test9.c	/^void garbage()$/;"	f
gate_A20	boothead.s	/^gate_A20:$/;"	l
gate_A20	klib88.s	/^gate_A20:$/;"	l
gatedesc_s	protect.c	/^struct gatedesc_s {$/;"	s	file:
gct	test1.c	/^_VOLATILE int glov, gct;$/;"	v
gdt	protect.c	/^PUBLIC struct segdesc_s gdt[GDT_SIZE];$/;"	v	typeref:struct:segdesc_s
geoboth	boothead.s	/^geoboth:$/;"	l
geodone	boothead.s	/^geodone:$/;"	l
geoerr	boothead.s	/^geoerr:	xor	ax, ax		! Code for failure$/;"	l
get2	get_put.h	30;"	d
get4	get_put.h	33;"	d
get4	get_put.h	39;"	d
get_args	ps.c	/^char *get_args(bufp)$/;"	f
get_block	cache.c	/^PUBLIC struct buf *get_block(dev, block, only_search)$/;"	f
get_block2	cache2.c	/^PUBLIC int get_block2(bp, only_search)$/;"	f
get_boot_parameters	main.c	/^PRIVATE void get_boot_parameters()$/;"	f
get_clickshift	bootimage.c	/^int get_clickshift(u32_t ksec, struct image_header *hdr)$/;"	f
get_eth_data	ip.c	/^PRIVATE acc_t *get_eth_data (fd, offset, count, for_ioctl)$/;"	f
get_fd	filedes.c	/^PUBLIC int get_fd(start, bits, k, fpt)$/;"	f
get_filp	filedes.c	/^PUBLIC struct filp *get_filp(fild)$/;"	f
get_inode	inode.c	/^PUBLIC struct inode *get_inode(dev, numb)$/;"	f
get_link	test21.c	/^int get_link(name)$/;"	f
get_master	boot.c	/^int get_master(char *master, struct part_entry **table, u32_t pos)$/;"	f
get_mode	test17.c	/^int get_mode(name)$/;"	f
get_mode	test18.c	/^int get_mode(name)$/;"	f
get_mtab_entry	mtab.c	/^int get_mtab_entry(special, mounted_on, version, rw_flag)$/;"	f
get_name	path.c	/^PRIVATE char *get_name(old_name, string)$/;"	f
get_new	test17.c	/^void get_new(name)$/;"	f
get_packet	ip_write.c	/^PRIVATE acc_t *get_packet (ip_fd, id)$/;"	f
get_parameters	boot.c	/^void get_parameters(void)$/;"	f
get_parameters	edparams.c	/^void get_parameters(void)$/;"	f
get_part_table	drvlib.c	/^PRIVATE int get_part_table(dp, device, offset, table)$/;"	f
get_route_ent	ipr.c	/^PRIVATE route_t *get_route_ent(dest)$/;"	f
get_sector	bootimage.c	/^char *get_sector(u32_t vsec)$/;"	f
get_segment	bootimage.c	/^int get_segment(u32_t *vsec, long *size, u32_t *addr, u32_t limit)$/;"	f
get_set_input	sb16_mixer.c	/^PRIVATE int get_set_input(m_ptr, flag, channel)$/;"	f
get_set_output	sb16_mixer.c	/^PRIVATE int get_set_output(m_ptr, flag)$/;"	f
get_set_volume	sb16_mixer.c	/^PRIVATE int get_set_volume(m_ptr, flag)$/;"	f
get_super	super.c	/^PUBLIC struct super_block *get_super(dev)$/;"	f
get_times	test16.c	/^void get_times(name, a, c, m)$/;"	f
get_uptime	clock.c	/^PUBLIC clock_t get_uptime()$/;"	f
get_userdata	dp8390.c	/^static void get_userdata(user_proc, user_addr, count, loc_addr)$/;"	f	file:
get_work	main.c	/^PRIVATE void get_work()$/;"	f
getanswer	gethnmadr.c	/^getanswer(answer, anslen, iquery)$/;"	f	file:
getc	boothead.s	/^getc:	cmpb	al, #0x0D	! Carriage return?$/;"	l
getc	getc.c	/^(getc)(FILE *stream)$/;"	f
getch	edparams.c	/^int getch(void)$/;"	f
getchar	getchar.c	/^(getchar)(void)$/;"	f
getcwd	_getcwd.c	/^char *getcwd(char *path, size_t size)$/;"	f
getcwd	_getcwd.c	8;"	d	file:
getdomainname	domainname.c	/^int getdomainname(domain, size)$/;"	f
getdomainname	getdomain.c	/^int getdomainname(char *domain, size_t size)$/;"	f
getegid	_getegid.c	/^PUBLIC gid_t getegid()$/;"	f
getegid	_getegid.c	2;"	d	file:
getenv	getenv.c	/^getenv(const char *name)$/;"	f
geteuid	_geteuid.c	/^PUBLIC uid_t geteuid()$/;"	f
geteuid	_geteuid.c	2;"	d	file:
getgid	_getgid.c	/^PUBLIC gid_t getgid()$/;"	f
getgid	_getgid.c	2;"	d	file:
getgrent	getgrent.c	/^struct group *getgrent(void)$/;"	f
getgrgid	getgrent.c	/^struct group *getgrgid(Gid_t gid)$/;"	f
getgrnam	getgrent.c	/^struct group *getgrnam(const char *name)$/;"	f
getgroups	_getgroups.c	/^PUBLIC int getgroups(gidsetsize, grouplist)$/;"	f
getgroups	_getgroups.c	9;"	d	file:
gethostbyaddr	gethnmadr.c	/^gethostbyaddr(addr, len, type)$/;"	f
gethostbyaddr	gethostent.c	/^gethostbyaddr(addr, len, type)$/;"	f
gethostbyaddr	gethostent.c	31;"	d	file:
gethostbyname	gethnmadr.c	/^gethostbyname(name)$/;"	f
gethostbyname	gethostent.c	/^gethostbyname(name)$/;"	f
gethostbyname	gethostent.c	30;"	d	file:
gethostent	gethostent.c	/^gethostent()$/;"	f
gethostent	gethostent.c	29;"	d	file:
gethostname	gethostname.c	/^int gethostname(char *buf, size_t len)$/;"	f
getids	test34.c	/^void getids(r_uid, r_gid)$/;"	f
getids	test35.c	/^void getids(r_uid, r_gid)$/;"	f
getkey	masterboot.s	/^getkey:	xorb	ah, ah			! Wait for keypress$/;"	l
getline	getgrent.c	/^static int getline(void)$/;"	f	file:
getline	getpwent.c	/^static int getline(void)$/;"	f	file:
getline	getttyent.c	/^static int getline(void)$/;"	f	file:
getlogin	getlogin.c	/^char *getlogin()$/;"	f
getlong	res_comp.c	/^getlong(msgp)$/;"	f
getlong	res_comp.c	41;"	d	file:
getopt	getopt.c	/^getopt(argc, argv, opts)$/;"	f
getpass	getpass.c	/^char *getpass(const char *prompt)$/;"	f
getpgrp	_getpgrp.c	/^PUBLIC pid_t getpgrp()$/;"	f
getpgrp	_getpgrp.c	2;"	d	file:
getpid	_getpid.c	/^PUBLIC pid_t getpid()$/;"	f
getpid	_getpid.c	2;"	d	file:
getpid	_mktemp.c	5;"	d	file:
getppid	_getppid.c	/^PUBLIC pid_t getppid()$/;"	f
getppid	_getppid.c	2;"	d	file:
getprotobynumber	getproto.c	/^getprotobynumber(proto)$/;"	f
getprotoent	getprotoent.c	/^getprotoent()$/;"	f
getpwent	getpwent.c	/^struct passwd *getpwent(void)$/;"	f
getpwnam	getpwent.c	/^struct passwd *getpwnam(const char *name)$/;"	f
getpwuid	getpwent.c	/^struct passwd *getpwuid(Uid_t uid)$/;"	f
gets	gets.c	/^gets(char *s)$/;"	f
getservbyname	getsrvbyname.c	/^getservbyname(name, proto)$/;"	f
getservbyport	getsrvbyport.c	/^getservbyport(port, proto)$/;"	f
getservent	getservent.c	/^getservent()$/;"	f
getshort	gethnmadr.c	67;"	d	file:
getshort	res_comp.c	/^getshort(msgp)$/;"	f
getshort	res_comp.c	40;"	d	file:
gettable	extboot.s	/^gettable:$/;"	l
gettmode	cursesio.c	/^void gettmode()$/;"	f
getttyent	getttyent.c	/^struct ttyent *getttyent(void)$/;"	f
getttynam	getttyent.c	/^struct ttyent *getttynam(const char *name)$/;"	f
gettynames	ps.c	/^int gettynames()$/;"	f
getuid	_getuid.c	/^PUBLIC uid_t getuid()$/;"	f
getuid	_getuid.c	2;"	d	file:
getw	getw.c	/^int getw(stream)$/;"	f
glo_jb	test8.c	/^jmp_buf glo_jb;$/;"	v
glo_vol_set	test8.c	/^sigset_t glo_vol_set;$/;"	v
glov	test1.c	/^_VOLATILE int glov, gct;$/;"	v
gmtime	gmtime.c	/^gmtime(register const time_t *timer)$/;"	f
gnum	doprnt.c	/^gnum(register const char *f, int *ip, va_list *app)$/;"	f	file:
got_bus	boothead.s	/^got_bus:$/;"	l
got_ext	boothead.s	/^got_ext:$/;"	l
got_processor	getprocessor.s	/^got_processor:$/;"	l
got_video	boothead.s	/^got_video:$/;"	l
gotabrt	init.c	/^int gotabrt = 0;		\/* flag, showing signal 6 was received *\/$/;"	v
gothup	init.c	/^int gothup = 0;			\/* flag, showing signal 1 was received *\/$/;"	v
gotoxy	update.c	/^static void gotoxy(row, col)$/;"	f	file:
gp_getaddr	boothead.s	/^gp_getaddr:$/;"	l
gp_ret	boothead.s	/^gp_ret:$/;"	l
granularity	type.h	/^  u8_t granularity;		\/* |G|X|0|A|LIMT| *\/$/;"	m	struct:segdesc_s
grfd	getgrent.c	/^static int grfd= -1;			\/* Filedescriptor to the file. *\/$/;"	v	file:
grfile	getgrent.c	/^static const char *grfile;		\/* Current group file. *\/$/;"	v	file:
grline	getgrent.c	/^static char grline[512];		\/* One line from the group file. *\/$/;"	v	file:
group	param.h	13;"	d
group0	aha_scsi.c	/^PRIVATE void group0()$/;"	f
group1	aha_scsi.c	/^PRIVATE void group1()$/;"	f
grow	malloc.c	/^static int grow(size_t len)$/;"	f	file:
gs	protect.c	/^  reg_t gs;$/;"	m	struct:tss_s	file:
gs	type.h	/^  u16_t gs;                     \/* last item pushed by save *\/$/;"	m	struct:stackframe_s
h2b16	aha_scsi.c	/^PRIVATE void h2b16(b, h)$/;"	f
h2b24	aha_scsi.c	/^PRIVATE void h2b24(b, h)$/;"	f
h2b32	aha_scsi.c	/^PRIVATE void h2b32(b, h)$/;"	f
h_32	FP_types.h	/^	unsigned long	h_32;	\/* higher 32 bits of 64 *\/$/;"	m	struct:__anon17
h_32	adder.h	/^	unsigned long	h_32;	\/* higher 32 bits of 64 *\/$/;"	m	struct:B64
h_32	ext_fmt.h	/^	unsigned long h_32;$/;"	m	struct:mantissa
h_addr_ptrs	gethnmadr.c	/^static char *h_addr_ptrs[MAXADDRS + 1];$/;"	v	file:
h_base	alloc.c	/^  phys_clicks h_base;		\/* where does the hole begin? *\/$/;"	m	struct:hole	file:
h_errno	res_query.c	/^int h_errno;$/;"	v
h_first	editline.c	/^h_first()$/;"	f
h_last	editline.c	/^h_last()$/;"	f
h_len	alloc.c	/^  phys_clicks h_len;		\/* how big is the hole? *\/$/;"	m	struct:hole	file:
h_next	alloc.c	/^  struct hole *h_next;		\/* pointer to next entry on the list *\/$/;"	m	struct:hole	typeref:struct:hole::hole	file:
h_next	editline.c	/^h_next()$/;"	f
h_prev	editline.c	/^h_prev()$/;"	f
h_search	editline.c	/^h_search()$/;"	f
handle_events	tty.c	/^PUBLIC void handle_events(tp)$/;"	f
hang	bootblock.s	/^hang:	jmp	hang$/;"	l
hang	extboot.s	/^hang:	jmp	hang$/;"	l
hang	masterboot.s	/^hang:	jmp	hang$/;"	l
hard	test9.c	/^void hard()$/;"	f
hash2	cache2.c	35;"	d	file:
hasold	options.c	/^static bool hasold = FALSE;	\/* for remembering old cursor type *\/$/;"	v	file:
hastat	aha_scsi.c	/^    byte hastat;		\/* Host Adapter Status *\/$/;"	m	struct:__anon10	file:
hclick_to_physb	const.h	31;"	d
hd_wait	xt_wini.c	/^PRIVATE int hd_wait(bits)$/;"	f
hdmap	wini.c	/^struct hdmap {$/;"	s	file:
hdmap	wini.c	/^} hdmap[] = {$/;"	v	typeref:struct:hdmap
hdr	gethnmadr.c	/^	dns_hdr_t hdr;$/;"	m	union:querybuf	file:
heads	bios_wini.c	/^  unsigned heads;		\/* number of heads *\/$/;"	m	struct:wini	file:
heads	boot.h	/^EXTERN u16_t heads, sectors;	\/* Its number of heads and sectors. *\/$/;"	v
held_head	glo.h	/^EXTERN struct proc *held_head;	\/* head of queue of held-up interrupts *\/$/;"	v	typeref:struct:proc
held_tail	glo.h	/^EXTERN struct proc *held_tail;	\/* tail of queue of held-up interrupts *\/$/;"	v	typeref:struct:proc
help	boot.c	/^void help(void)$/;"	f
help	edparams.c	/^void help(void)$/;"	f
high	type.h	/^		u32_t high;$/;"	m	struct:fsave::fpp_model::fpN
hist_add	editline.c	/^hist_add(p)$/;"	f
hole	alloc.c	/^PRIVATE struct hole {$/;"	s	file:
hole	alloc.c	/^} hole[NR_HOLES];$/;"	v	typeref:struct:hole
hole_head	alloc.c	/^PRIVATE struct hole *hole_head;	\/* pointer to first hole *\/$/;"	v	typeref:struct:hole
host	gethnmadr.c	/^static struct hostent host;$/;"	v	typeref:struct:hostent	file:
host	gethostent.c	/^static struct hostent host;$/;"	v	typeref:struct:hostent	file:
host_addr	gethnmadr.c	/^static struct in_addr host_addr;$/;"	v	typeref:struct:in_addr	file:
host_addrs	gethostent.c	/^static char *host_addrs[2];$/;"	v	file:
host_aliases	gethnmadr.c	/^static char *host_aliases[MAXALIASES];$/;"	v	file:
host_aliases	gethostent.c	/^static char *host_aliases[MAXALIASES];$/;"	v	file:
hostaddr	gethostent.c	/^static u_long hostaddr[(MAXADDRS+sizeof(u_long)-1)\/sizeof(u_long)];$/;"	v	file:
hostalias	res_query.c	/^hostalias(name)$/;"	f
hostalias	res_query.c	42;"	d	file:
hostbuf	gethnmadr.c	/^static char hostbuf[BUFSIZ+1];$/;"	v	file:
hostbuf	gethostent.c	/^static char hostbuf[BUFSIZ+1];$/;"	v	file:
hostf	gethostent.c	/^static FILE *hostf = NULL;$/;"	v	file:
howto	installboot.c	/^enum howto { FS, BOOT };$/;"	g	file:
hwint_master	mpx386.s	/^#define hwint_master(irq)	\\$/;"	d
hwint_master	mpx88.s	/^#define hwint_master(irq)	\\$/;"	d
hwint_slave	mpx386.s	/^#define hwint_slave(irq)	\\$/;"	d
hwint_slave	mpx88.s	/^#define hwint_slave(irq)	\\$/;"	d
hypot	hypot.c	/^hypot(x, y)$/;"	f
i	hypot.c	/^	double r,i;$/;"	m	struct:complex	file:
i	test4.c	/^int s, i, fd, nextb, errct = 0;$/;"	v
i_addr	type.h	/^	u32_t i_addr;$/;"	m	struct:fsave::cpu_state
i_atime	inode.h	/^  time_t i_atime;		\/* time of last access (V2 only) *\/$/;"	m	struct:inode
i_count	inode.h	/^  int i_count;			\/* # times inode used; 0 means slot is free *\/$/;"	m	struct:inode
i_ctime	inode.h	/^  time_t i_ctime;		\/* when was inode itself changed (V2 only)*\/$/;"	m	struct:inode
i_dev	inode.h	/^  dev_t i_dev;			\/* which device is the inode on *\/$/;"	m	struct:inode
i_dirt	inode.h	/^  char i_dirt;			\/* CLEAN or DIRTY *\/$/;"	m	struct:inode
i_format	type.h	/^	u16_t i_format;$/;"	m	struct:fsave::cpu_state
i_gid	inode.h	/^  gid_t i_gid;			\/* group number *\/$/;"	m	struct:inode
i_mode	inode.h	/^  mode_t i_mode;		\/* file type, protection, etc. *\/$/;"	m	struct:inode
i_mount	inode.h	/^  char i_mount;			\/* this bit is set if file mounted on *\/$/;"	m	struct:inode
i_mtime	inode.h	/^  time_t i_mtime;		\/* when was file data last changed *\/$/;"	m	struct:inode
i_ndzones	inode.h	/^  int i_ndzones;		\/* # direct zones (Vx_NR_DZONES) *\/$/;"	m	struct:inode
i_nindirs	inode.h	/^  int i_nindirs;		\/* # indirect zones per indirect block *\/$/;"	m	struct:inode
i_nlinks	inode.h	/^  nlink_t i_nlinks;		\/* how many links to this file *\/$/;"	m	struct:inode
i_num	inode.h	/^  ino_t i_num;			\/* inode number on its (minor) device *\/$/;"	m	struct:inode
i_pipe	inode.h	/^  char i_pipe;			\/* set to I_PIPE if pipe *\/$/;"	m	struct:inode
i_seek	inode.h	/^  char i_seek;			\/* set on LSEEK, cleared on READ\/WRITE *\/$/;"	m	struct:inode
i_size	inode.h	/^  off_t i_size;			\/* current file size in bytes *\/$/;"	m	struct:inode
i_sp	inode.h	/^  struct super_block *i_sp;	\/* pointer to super block for inode's device *\/$/;"	m	struct:inode	typeref:struct:inode::super_block
i_state	type.h	/^	u16_t i_state[4];$/;"	m	struct:fsave::cpu_state
i_uid	inode.h	/^  uid_t i_uid;			\/* user id of the file's owner *\/$/;"	m	struct:inode
i_update	inode.h	/^  char i_update;		\/* the ATIME, CTIME, and MTIME bits are here *\/$/;"	m	struct:inode
i_zone	inode.h	/^  zone_t i_zone[V2_NR_TZONES];	\/* zone numbers for direct, ind, and dbl ind *\/$/;"	m	struct:inode
ia_dstaddr	ip_int.h	/^	ipaddr_t ia_srcaddr, ia_dstaddr;$/;"	m	struct:ip_ass
ia_first_time	ip_int.h	/^	time_t ia_first_time;$/;"	m	struct:ip_ass
ia_frags	ip_int.h	/^	acc_t *ia_frags;$/;"	m	struct:ip_ass
ia_id	ip_int.h	/^	int ia_proto, ia_id;$/;"	m	struct:ip_ass
ia_min_ttl	ip_int.h	/^	int ia_min_ttl;$/;"	m	struct:ip_ass
ia_port	ip_int.h	/^	ip_port_t *ia_port;$/;"	m	struct:ip_ass
ia_proto	ip_int.h	/^	int ia_proto, ia_id;$/;"	m	struct:ip_ass
ia_srcaddr	ip_int.h	/^	ipaddr_t ia_srcaddr, ia_dstaddr;$/;"	m	struct:ip_ass
ibuf	keyboard.c	/^  char ibuf[KB_IN_BYTES];	\/* input buffer *\/$/;"	m	struct:kb_s	file:
ibuf	rs232.c	/^  char ibuf[RS_IBUFSIZE];	\/* input buffer *\/$/;"	m	struct:rs232	file:
icmp_buffree	icmp.c	/^PRIVATE void icmp_buffree(priority, reqsize)$/;"	f
icmp_dont_frag	icmp.c	/^PUBLIC void icmp_dont_frag(pack)$/;"	f
icmp_dst_unreach	icmp.c	/^static void icmp_dst_unreach(icmp_port, ip_pack, ip_hdr_len, ip_hdr, icmp_pack,$/;"	f	file:
icmp_echo_request	icmp.c	/^PRIVATE void icmp_echo_request(icmp_port, ip_data, ip_len, ip_hdr,$/;"	f
icmp_frag_ass_tim	icmp.c	/^PUBLIC void icmp_frag_ass_tim(pack)$/;"	f
icmp_getdata	icmp.c	/^PRIVATE acc_t *icmp_getdata(port, offset, count, for_ioctl)$/;"	f
icmp_getnetmask	icmp.c	/^PUBLIC void icmp_getnetmask(ip_port)$/;"	f
icmp_init	icmp.c	/^PUBLIC void icmp_init()$/;"	f
icmp_main	icmp.c	/^PRIVATE void icmp_main(icmp_port)$/;"	f
icmp_pack_oneCsum	icmp.c	/^PRIVATE u16_t icmp_pack_oneCsum(icmp_pack)$/;"	f
icmp_port	icmp.c	/^typedef struct icmp_port$/;"	s	file:
icmp_port_t	icmp.c	/^} icmp_port_t;$/;"	t	typeref:struct:icmp_port	file:
icmp_port_table	icmp.c	/^PRIVATE  icmp_port_t icmp_port_table[ICMP_PORT_NR];$/;"	v
icmp_putdata	icmp.c	/^PRIVATE int icmp_putdata(port, offset, data, for_ioctl)$/;"	f
icmp_read	icmp.c	/^PRIVATE void icmp_read(icmp_port)$/;"	f
icmp_redirect	icmp.c	/^static void icmp_redirect(icmp_port, ip_hdr, icmp_pack, icmp_len, icmp_hdr)$/;"	f	file:
icmp_router_advertisement	icmp.c	/^static void icmp_router_advertisement(icmp_port, icmp_pack, icmp_len, icmp_hdr)$/;"	f	file:
icmp_time_exceeded	icmp.c	/^static void icmp_time_exceeded(icmp_port, ip_pack, ip_hdr_len, ip_hdr,$/;"	f	file:
icmp_ttl_exceded	icmp.c	/^PUBLIC void icmp_ttl_exceded(pack)$/;"	f
icmp_write	icmp.c	/^PRIVATE void icmp_write(icmp_port)$/;"	f
icount	keyboard.c	/^  int icount;			\/* # codes in buffer *\/$/;"	m	struct:kb_s	file:
icount	rs232.c	/^  int icount;			\/* number of bytes in the input buffer *\/$/;"	m	struct:rs232	file:
icp_flags	icmp.c	/^	int icp_flags;$/;"	m	struct:icmp_port	file:
icp_head_queue	icmp.c	/^	acc_t *icp_head_queue;$/;"	m	struct:icmp_port	file:
icp_ipfd	icmp.c	/^	int icp_ipfd;$/;"	m	struct:icmp_port	file:
icp_ipport	icmp.c	/^	int icp_ipport;$/;"	m	struct:icmp_port	file:
icp_state	icmp.c	/^	int icp_state;$/;"	m	struct:icmp_port	file:
icp_tail_queue	icmp.c	/^	acc_t *icp_tail_queue;$/;"	m	struct:icmp_port	file:
icp_write_pack	icmp.c	/^	acc_t *icp_write_pack;$/;"	m	struct:icmp_port	file:
id_byte	at_wini.c	327;"	d	file:
id_longword	at_wini.c	330;"	d	file:
id_word	at_wini.c	328;"	d	file:
idevready	rs232.c	/^  bool_t idevready;		\/* nonzero if we are ready to receive (RTS) *\/$/;"	m	struct:rs232	file:
idlok	options.c	/^void idlok(win, flag)$/;"	f
idt	protect.c	/^PRIVATE struct gatedesc_s idt[IDT_SIZE];	\/* zero-init so none present *\/$/;"	v	typeref:struct:gatedesc_s
idt_vectors	klib88.s	/^idt_vectors:			! limit and base of real mode interrupt vectors$/;"	l
idt_zero	klib386.s	/^idt_zero:	.data4	0, 0$/;"	l
idt_zero	klib88.s	/^idt_zero:			! zero limit IDT to cause a processor shutdown$/;"	l
if_exp_tim	ip_int.h	/^	time_t if_exp_tim;$/;"	m	struct:ip_fd
if_flags	ip_int.h	/^	int if_flags;$/;"	m	struct:ip_fd
if_get_userdata	ip_int.h	/^	get_userdata_t if_get_userdata;$/;"	m	struct:ip_fd
if_ipopt	ip_int.h	/^	struct nwio_ipopt if_ipopt;$/;"	m	struct:ip_fd	typeref:struct:ip_fd::nwio_ipopt
if_port	ip_int.h	/^	ip_port_t *if_port;$/;"	m	struct:ip_fd
if_put_userdata	ip_int.h	/^	put_userdata_t if_put_userdata;$/;"	m	struct:ip_fd
if_rd_buf	ip_int.h	/^	acc_t *if_rd_buf;$/;"	m	struct:ip_fd
if_rd_count	ip_int.h	/^	size_t if_rd_count;$/;"	m	struct:ip_fd
if_srfd	ip_int.h	/^	int if_srfd;$/;"	m	struct:ip_fd
if_wr_count	ip_int.h	/^	size_t if_wr_count;$/;"	m	struct:ip_fd
if_wr_dstaddr	ip_int.h	/^	ipaddr_t if_wr_dstaddr;$/;"	m	struct:ip_fd
if_wr_port	ip_int.h	/^	ip_port_t *if_wr_port;$/;"	m	struct:ip_fd
ihead	keyboard.c	/^  char *ihead;			\/* next free spot in input buffer *\/$/;"	m	struct:kb_s	file:
ihead	rs232.c	/^  char *ihead;			\/* next free spot in input buffer *\/$/;"	m	struct:rs232	file:
image_header	image.h	/^struct image_header {$/;"	s
image_off	bootimage.c	/^off_t image_off, image_size;$/;"	v
image_size	bootimage.c	/^off_t image_off, image_size;$/;"	v
in_addr	gethnmadr.c	/^struct in_addr$/;"	s	file:
in_int	rs232.c	/^PRIVATE void in_int(rs)$/;"	f
in_process	tty.c	/^PUBLIC int in_process(tp, buf, count)$/;"	f
in_transfer	tty.c	/^PRIVATE void in_transfer(tp)$/;"	f
inb	iolib.s	/^	inb	dx			! input many bytes$/;"	d
inb	iolib.s	/^	inb	dx			! read 1 byte$/;"	d
inb	klib386.s	/^	inb	dx			! read 1 byte$/;"	d
inb_ne	ne2000.h	19;"	d
inb_reg0	dp8390.h	164;"	d
inb_reg1	dp8390.h	166;"	d
inb_we	wdeth.h	87;"	d
inc	boothead.s	/^	inc	dx		! Assume AT$/;"	d
inc	boothead.s	/^	inc	dx		! Assume MCA$/;"	d
inc	set.s	/^	inc	di$/;"	d
incb	bootblock.s	/^	incb	dh		! dh = 1 + max head number (0-origin)$/;"	d
incb	boothead.s	/^	incb	dh		! dh = 1 + max head number (0-origin)$/;"	d
incb	extboot.s	/^	incb	dh		! dh = 1 + max head number (0-origin)$/;"	d
incb	masterboot.s	/^	incb	dh		! dh = 1 + max head number (0-origin)$/;"	d
incb	masterboot.s	/^	incb	dl			! Increment dl for the next drive$/;"	d
index	console.c	/^	unsigned short index;$/;"	m	struct:sequence	file:
index	index.c	/^char *index(s, charwanted)	\/* found char, or NULL if none *\/$/;"	f
index	res_init.c	39;"	d	file:
indir	rawfs.c	/^static char indir[BLOCK_SIZE];		\/* Single indirect block. *\/$/;"	v	file:
inet_addr	inet_addr.c	/^inet_addr(cp)$/;"	f
inet_aton	inet_addr.c	/^inet_aton(cp, addr)$/;"	f
inet_ntoa	inet_ntoa.c	/^inet_ntoa(in)$/;"	f
info	aha_scsi.c	/^    big32 info;			\/* sense info *\/$/;"	m	struct:__anon8	file:
inform	system.c	/^PUBLIC void inform()$/;"	f
inhibited	rs232.c	/^  bool_t inhibited;		\/* output inhibited? (follows tty_inhibited) *\/$/;"	m	struct:rs232	file:
init_array	test17.c	/^void init_array(a)$/;"	f
init_array	test18.c	/^void init_array(a)$/;"	f
init_buffer	driver.c	/^PRIVATE void init_buffer()$/;"	f
init_buffer	sb16_dsp.c	/^PRIVATE void init_buffer()$/;"	f
init_cache	boot.c	/^void init_cache(void) {}$/;"	f
init_cache	boot.c	/^void init_cache(void)$/;"	f
init_cache2	cache2.c	/^PUBLIC void init_cache2(size)$/;"	f
init_clock	clock.c	/^PRIVATE void init_clock()$/;"	f
init_codeseg	protect.c	/^PUBLIC void init_codeseg(segdp, base, size, privilege)$/;"	f
init_dataseg	protect.c	/^PUBLIC void init_dataseg(segdp, base, size, privilege)$/;"	f
init_params	at_wini.c	/^PRIVATE void init_params()$/;"	f
init_params	xt_wini.c	/^PRIVATE void init_params()$/;"	f
init_proc_nr	ps.c	/^int init_proc_nr;$/;"	v
initial_pc	type.h	/^  task_t *initial_pc;$/;"	m	struct:tasktab
initialize	boot.c	/^void initialize(void)$/;"	f
initscr	initscr.c	/^WINDOW *initscr()$/;"	f
inode	inode.h	/^EXTERN struct inode {$/;"	s
inode	inode.h	/^} inode[NR_INODES];$/;"	v	typeref:struct:inode
inodes_per_block	rawfs.c	/^static unsigned inodes_per_block;$/;"	v	file:
inp_buf	doscan.c	/^static char	inp_buf[NUMLEN];$/;"	v	file:
inqdata	aha_scsi.c	/^PRIVATE inquiry_t inqdata;	\/* results of Inquiry command *\/$/;"	v
inquiry_t	aha_scsi.c	/^} inquiry_t;$/;"	t	typeref:struct:__anon9	file:
insert_char	editline.c	/^insert_char(c)$/;"	f
insert_string	editline.c	/^insert_string(p)$/;"	f
install_master	installboot.c	/^void install_master(char *device, char *masterboot, char *fix)$/;"	f
int	trp.s	/^int 32$/;"	l
int13	klib88.s	/^int13:$/;"	l
int_enab_port	rs232.c	/^  port_t int_enab_port;$/;"	m	struct:rs232	file:
int_gate	protect.c	/^PRIVATE void int_gate(vec_nr, base, dpl_type)$/;"	f
int_id_port	rs232.c	/^  port_t int_id_port;$/;"	m	struct:rs232	file:
int_pending	dp8390.c	/^static int int_pending[NR_IRQ_VECTORS];$/;"	v	file:
int_vec	i8259.c	/^PRIVATE vecaddr_t int_vec[] = {$/;"	v
interrupt	boot.c	/^void interrupt(void)$/;"	f
interrupt	edparams.c	/^void interrupt(void)$/;"	f
interrupt	proc.c	/^PUBLIC void interrupt(task)$/;"	f
intr	getpass.c	/^static int intr;$/;"	v	file:
intr_init	i8259.c	/^PUBLIC void intr_init(mine)$/;"	f
inuse	extboot.s	/^inuse:	mov	bx, lowsec+0(di)$/;"	l
inuse	masterboot.s	/^inuse:	mov	bx, lowsec+0(di)$/;"	l
invalidate	cache.c	/^PUBLIC void invalidate(device)$/;"	f
invalidate2	cache2.c	/^PUBLIC void invalidate2(device)$/;"	f
invalidate_cache	boot.c	/^void invalidate_cache(void) {}$/;"	f
invalidate_cache	boot.c	/^void invalidate_cache(void)$/;"	f
inw_ne	ne2000.h	21;"	d
io_testflag	loc_incl.h	8;"	d
iobase	protect.c	/^  u16_t iobase;$/;"	m	struct:tss_s	file:
ioctl	_ioctl.c	/^PUBLIC int ioctl(fd, request, data)$/;"	f
ioctl	_ioctl.c	2;"	d	file:
ioctl	_tcdrain.c	8;"	d	file:
ioctl	_tcflow.c	8;"	d	file:
ioctl	_tcflush.c	5;"	d	file:
ioctl	_tcgetattr.c	2;"	d	file:
ioctl	_tcsendbreak.c	5;"	d	file:
ioctl	_tcsetattr.c	8;"	d	file:
ioctl	asynchio.c	10;"	d	file:
ioctl_disk_info	mcd.c	/^PRIVATE int ioctl_disk_info(m_ptr)$/;"	f
ioctl_play_mss	mcd.c	/^PRIVATE int ioctl_play_mss(m_ptr)$/;"	f
ioctl_play_ti	mcd.c	/^PRIVATE int ioctl_play_ti(m_ptr)$/;"	f
ioctl_read_sub	mcd.c	/^PRIVATE int ioctl_read_sub(m_ptr)$/;"	f
ioctl_read_toc	mcd.c	/^PRIVATE int ioctl_read_toc(m_ptr)$/;"	f
iod_iovec	dp8390.h	/^  iovec_t iod_iovec[IOVEC_NR];$/;"	m	struct:iovec_dat
iod_iovec_addr	dp8390.h	/^  vir_bytes iod_iovec_addr;$/;"	m	struct:iovec_dat
iod_iovec_s	dp8390.h	/^  int iod_iovec_s;$/;"	m	struct:iovec_dat
iod_proc_nr	dp8390.h	/^  int iod_proc_nr;$/;"	m	struct:iovec_dat
ioerr	boothead.s	/^ioerr:	cmpb	ah, #0x80	! Disk timed out?  (Floppy drive empty)$/;"	l
ioflags	param.h	12;"	d
iop	at_wini.c	/^  struct iorequest_s *iop;	\/* belongs to this I\/O request *\/$/;"	m	struct:trans	typeref:struct:trans::iorequest_s	file:
iop	bios_wini.c	/^  struct iorequest_s *iop;	\/* belongs to this I\/O request *\/$/;"	m	struct:trans	typeref:struct:trans::iorequest_s	file:
iop	esdi_wini.c	/^  struct iorequest_s *iop;	\/* belongs to this I\/O request           *\/$/;"	m	struct:trans	typeref:struct:trans::iorequest_s	file:
iov	aha_scsi.c	/^  struct iorequest_s *iov[NR_IOREQS];	\/* affected I\/O requests *\/$/;"	m	struct:request	typeref:struct:request::iorequest_s	file:
iov	ether.h	/^    struct iovec *iov;			\/* ptr to array of iovec *\/$/;"	m	struct:ethervec	typeref:struct:ethervec::iovec
iovcnt	ether.h	/^    unsigned short iovcnt;		\/* number of iovec to use *\/$/;"	m	struct:ethervec
iovec_dat	dp8390.h	/^typedef struct iovec_dat$/;"	s
iovec_dat_t	dp8390.h	/^} iovec_dat_t;$/;"	t	typeref:struct:iovec_dat
ip	protect.c	/^  reg_t ip;$/;"	m	struct:tss_s	file:
ip_ass	ip_int.h	/^typedef struct ip_ass$/;"	s
ip_ass_t	ip_int.h	/^} ip_ass_t;$/;"	t	typeref:struct:ip_ass
ip_ass_table	ip.c	/^PUBLIC ip_ass_t ip_ass_table[IP_ASS_NR];$/;"	v
ip_cancel	ip.c	/^PRIVATE int ip_cancel (fd, which_operation)$/;"	f
ip_checkopt	ip_ioctl.c	/^PRIVATE int ip_checkopt (ip_fd)$/;"	f
ip_chk_hdropt	ip_lib.c	/^PUBLIC int ip_chk_hdropt (opt, optlen)$/;"	f
ip_close	ip.c	/^PRIVATE void ip_close (fd)$/;"	f
ip_dl	ip_int.h	/^	} ip_dl;$/;"	m	struct:ip_port	typeref:union:ip_port::__anon21
ip_dl_type	ip_int.h	/^	int ip_flags, ip_dl_type;$/;"	m	struct:ip_port
ip_eth_arrived	ip_read.c	/^PUBLIC void ip_eth_arrived(ip_port, pack)$/;"	f
ip_eth_main	ip.c	/^PRIVATE void ip_eth_main(ip_port)$/;"	f
ip_fd	ip_int.h	/^typedef struct ip_fd$/;"	s
ip_fd_t	ip_int.h	/^} ip_fd_t;$/;"	t	typeref:struct:ip_fd
ip_fd_table	ip.c	/^PUBLIC ip_fd_t ip_fd_table[IP_FD_NR];$/;"	v
ip_flags	ip_int.h	/^	int ip_flags, ip_dl_type;$/;"	m	struct:ip_port
ip_frag_chk	ip_read.c	/^PRIVATE int ip_frag_chk(pack)$/;"	f
ip_frame_id	ip_int.h	/^	u16_t ip_frame_id;$/;"	m	struct:ip_port
ip_get_netmask	ip_lib.c	/^PUBLIC ipaddr_t ip_get_netmask (hostaddr)$/;"	f
ip_init	ip.c	/^PUBLIC void ip_init()$/;"	f
ip_ioctl	ip_ioctl.c	/^PUBLIC int ip_ioctl (fd, req)$/;"	f
ip_ipaddr	ip_int.h	/^	ipaddr_t ip_ipaddr, ip_netmask;$/;"	m	struct:ip_port
ip_localroute_addr	ip_write.c	/^PRIVATE int ip_localroute_addr (ip_fd)$/;"	f
ip_minor	ip_int.h	/^	int ip_minor;$/;"	m	struct:ip_port
ip_netmask	ip_int.h	/^	ipaddr_t ip_ipaddr, ip_netmask;$/;"	m	struct:ip_port
ip_ok_for_fd	ip_read.c	/^PUBLIC int ip_ok_for_fd (ip_fd, pack)$/;"	f
ip_open	ip.c	/^PUBLIC int ip_open (port, srfd, get_userdata, put_userdata)$/;"	f
ip_packet2user	ip_read.c	/^PUBLIC int ip_packet2user (ip_fd)$/;"	f
ip_panic	inet.h	62;"	d
ip_port	ip_int.h	/^typedef struct ip_port$/;"	s
ip_port_arrive	ip_read.c	/^PUBLIC void ip_port_arrive (ip_port, pack, ip_hdr)$/;"	f
ip_port_t	ip_int.h	/^} ip_port_t;$/;"	t	typeref:struct:ip_port
ip_port_table	ip.c	/^PUBLIC ip_port_t ip_port_table[IP_PORT_NR];$/;"	v
ip_print_frags	ip_lib.c	/^void ip_print_frags(acc)$/;"	f
ip_read	ip_read.c	/^PUBLIC int ip_read (fd, count)$/;"	f
ip_remroute_addr	ip_write.c	/^PRIVATE void ip_remroute_addr(ip_fd, ttl)$/;"	f
ip_split_pack	ip_write.c	/^PRIVATE acc_t *ip_split_pack (ref_last, first_size)$/;"	f
ip_warning	inet.h	71;"	d
ip_write	ip_write.c	/^PUBLIC int ip_write (fd, count)$/;"	f
ipaddr_set	arp.c	/^PRIVATE void ipaddr_set (port)$/;"	f
ipart	FP_types.h	/^	DOUBLE ipart;$/;"	m	struct:fif8_returns
ipart	FP_types.h	/^	SINGLE ipart;$/;"	m	struct:fif4_returns
ipr_add_route	ipr.c	/^PUBLIC route_t *ipr_add_route(dest, netmask, gateway, port, timeout, dist,$/;"	f
ipr_destunrch	ipr.c	/^PUBLIC void ipr_destunrch(dest, netmask, timeout)$/;"	f
ipr_gateway_down	ipr.c	/^PUBLIC void ipr_gateway_down(gateway, timeout)$/;"	f
ipr_get_route	ipr.c	/^int ipr_get_route(ent_no, route_ent)$/;"	f
ipr_init	ipr.c	/^PUBLIC void ipr_init()$/;"	f
ipr_redirect	ipr.c	/^PUBLIC void ipr_redirect(dest, netmask, old_gateway, new_gateway, new_port,$/;"	f
ipr_ttl_exc	ipr.c	/^PUBLIC void ipr_ttl_exc(dest, netmask, timeout)$/;"	f
iproute_frag	ipr.c	/^PUBLIC int iproute_frag(dest, ttl, nexthop, port)$/;"	f
iptr	mtab.c	/^static char *iptr = mtab_in;	  \/* pointer to next line to feed out. *\/$/;"	v	file:
irq	at_wini.c	/^  unsigned irq;			\/* interrupt request line *\/$/;"	m	struct:wini	file:
irq_table	glo.h	/^EXTERN irq_handler_t irq_table[NR_IRQ_VECTORS];$/;"	v
irq_use	glo.h	/^EXTERN int irq_use;		\/* bit map of all in-use irq's *\/$/;"	v
irq_vec	i8259.c	/^PRIVATE vecaddr_t irq_vec[] = {$/;"	v
is	test2.c	/^int is, array[4], parsigs, parcum, sigct, cumsig, errct, subtest;$/;"	v
is25	boothead.s	/^is25:$/;"	l
is_default	boot.c	/^int is_default(environment *e)$/;"	f
is_default	edparams.c	/^int is_default(environment *e)$/;"	f
is_unused_port	tcp.c	/^PRIVATE int is_unused_port(port)$/;"	f
is_unused_port	udp.c	/^PRIVATE int is_unused_port(port)$/;"	f
isalnum	isalnum.c	/^int (isalnum)(int c) {$/;"	f
isalpha	isalpha.c	/^int (isalpha)(int c) {$/;"	f
isascii	isascii.c	/^int (isascii)(int c) {$/;"	f
isatty	_isatty.c	/^PUBLIC int isatty(fd)$/;"	f
isatty	_isatty.c	2;"	d	file:
iscntrl	iscntrl.c	/^int (iscntrl)(int c) {$/;"	f
isconsole	tty.c	73;"	d	file:
isdigit	isdigit.c	/^int (isdigit)(int c) {$/;"	f
isdigit	printk.c	8;"	d	file:
isgraph	isgraph.c	/^int (isgraph)(int c) {$/;"	f
isidlehardware	proc.h	88;"	d
islower	islower.c	/^int (islower)(int c) {$/;"	f
isokprocn	proc.h	89;"	d
isoksrc_dest	proc.h	90;"	d
isoksusern	proc.h	91;"	d
isokusern	proc.h	92;"	d
isoption	installboot.c	/^int isoption(char *option, char *test)$/;"	f
isprint	isprint.c	/^int (isprint)(int c) {$/;"	f
ispunct	ispunct.c	/^int (ispunct)(int c) {$/;"	f
isrxhardware	proc.h	93;"	d
isshadowp	proc.h	104;"	d
isspace	isspace.c	/^int (isspace)(int c) {$/;"	f
issysentn	proc.h	94;"	d
istart	rs232.c	119;"	d	file:
istart	rs232.c	159;"	d	file:
istaskp	proc.h	95;"	d
istop	rs232.c	122;"	d	file:
istop	rs232.c	161;"	d	file:
istty	edparams.c	/^int istty= 1;$/;"	v
isupper	isupper.c	/^int (isupper)(int c) {$/;"	f
isuserp	proc.h	96;"	d
isxdigit	isxdigit.c	/^int (isxdigit)(int c) {$/;"	f
it	test15.c	/^char *it = "<UNSET>";		\/* Routine name for message routines. *\/$/;"	v
itail	keyboard.c	/^  char *itail;			\/* scan code to return to TTY *\/$/;"	m	struct:kb_s	file:
itail	rs232.c	/^  char *itail;			\/* first byte to give to TTY *\/$/;"	m	struct:rs232	file:
iteration	test2.c	/^int iteration, kk = 0, errct = 0;$/;"	v
iteration	test8.c	/^int iteration, cumsig, subtest, errct = 0, sig1, sig2;$/;"	v
itoa	itoa.c	/^char *itoa(n)$/;"	f
jae	trp.s	/^jae 1f$/;"	l
jmp	trp.s	/^jmp .Trp$/;"	l
jmp	trp.s	/^jmp 2f$/;"	l
jz	trp.s	/^jz      2f$/;"	l
jz	trp.s	/^jz 1f$/;"	l
k_atoi	start.c	/^PRIVATE int k_atoi(s)$/;"	f
k_environ	start.c	/^PRIVATE char k_environ[256];	\/* environment strings passed by loader *\/$/;"	v
k_flags	bootimage.c	/^unsigned k_flags;	\/* Not all kernels are created equal. *\/$/;"	v
k_getenv	start.c	/^PUBLIC char *k_getenv(name)$/;"	f
k_reenter	glo.h	/^EXTERN unsigned char k_reenter;	\/* kernel reentry count (entry count less 1)*\/$/;"	v
k_stack	mpx386.s	/^k_stack:$/;"	l
k_stack	mpx88.s	/^k_stack:$/;"	l
k_stktop	mpx386.s	/^k_stktop:			! top of kernel stack$/;"	l
k_stktop	mpx88.s	/^k_stktop:			! top of kernel stack$/;"	l
kb_ack	keyboard.c	/^PRIVATE int kb_ack()$/;"	f
kb_addr	keyboard.c	42;"	d	file:
kb_init	keyboard.c	/^PUBLIC void kb_init(tp)$/;"	f
kb_lines	keyboard.c	/^PRIVATE struct kb_s kb_lines[NR_CONS];$/;"	v	typeref:struct:kb_s
kb_read	keyboard.c	/^PRIVATE void kb_read(tp)$/;"	f
kb_s	keyboard.c	/^struct kb_s {$/;"	s	file:
kb_wait	boothead.s	/^kb_wait:$/;"	l
kb_wait	keyboard.c	/^PRIVATE int kb_wait()$/;"	f
kb_wait	klib88.s	/^kb_wait:$/;"	l
kbd_hw_int	keyboard.c	/^PRIVATE int kbd_hw_int(irq)$/;"	f
kbd_loadmap	keyboard.c	/^PUBLIC int kbd_loadmap(user_phys)$/;"	f
kernel_cs	klib88.s	/^kernel_cs:$/;"	l
kernel_ds	mpx88.s	/^kernel_ds:$/;"	l
key	aha_scsi.c	/^    byte key;			\/* Sense Key *\/$/;"	m	struct:__anon8	file:
key	masterboot.s	/^key:$/;"	l
keypad	options.c	/^void keypad(win, flag)$/;"	f
kill	_kill.c	/^PUBLIC int kill(proc, sig)$/;"	f
kill	_kill.c	2;"	d	file:
kill_line	editline.c	/^kill_line()$/;"	f
killchar	termmisc.c	/^int killchar()$/;"	f
kip_done	klib88.s	/^kip_done:$/;"	l
kip_next	klib88.s	/^kip_next:$/;"	l
kk	test2.c	/^int iteration, kk = 0, errct = 0;$/;"	v
klib_init_prot	klib88.s	/^klib_init_prot:$/;"	l
kmemfd	ps.c	/^int kmemfd, memfd;		\/* file descriptors of [k]mem *\/$/;"	v
l_32	FP_types.h	/^	unsigned long	l_32;	\/* lower  32 bits of 64 *\/$/;"	m	struct:__anon17
l_32	adder.h	/^	unsigned long	l_32;	\/* lower  32 bits of 64 *\/$/;"	m	struct:B64
l_32	ext_fmt.h	/^	unsigned long l_32;$/;"	m	struct:mantissa
labs	labs.c	/^labs(register long l)$/;"	f
last	extboot.s	/^last:	mov	si, di$/;"	l
last	memcmp.s	/^last:	repe$/;"	l
last_argument	editline.c	/^last_argument()$/;"	f
last_dir	path.c	/^PUBLIC struct inode *last_dir(path, string)$/;"	f
last_index	test23.c	/^char *last_index(string, ch)$/;"	f
last_sunday	misc.c	/^last_sunday(register int day, register struct tm *timep)$/;"	f	file:
latest_version	bootimage.c	/^ino_t latest_version(char *version, struct stat *stp)$/;"	f
lba	aha_scsi.c	186;"	d	file:
lcylinders	at_wini.c	/^  unsigned lcylinders;		\/* logical number of cylinders (BIOS) *\/$/;"	m	struct:wini	file:
ldexp	ldexp.c	/^ldexp(double fl, int exp)$/;"	f
ldh	at_wini.c	/^  u8_t	ldh;$/;"	m	struct:command	file:
ldh_init	at_wini.c	34;"	d	file:
ldhpref	at_wini.c	/^  unsigned ldhpref;		\/* top four bytes of the LDH (head) register *\/$/;"	m	struct:wini	file:
ldiv	ldiv.c	/^ldiv(register long numer, register long denom)$/;"	f
ldt	protect.c	/^  reg_t ldt;$/;"	m	struct:tss_s	file:
leaveok	options.c	/^void leaveok(win, flag)$/;"	f
left	editline.c	/^left(Change)$/;"	f
len	aha_scsi.c	/^    byte len;			\/* additional length *\/$/;"	m	struct:__anon8	file:
len	aha_scsi.c	/^    byte len;			\/* length of remaining info *\/$/;"	m	struct:__anon9	file:
level1	test9.c	/^void level1()$/;"	f
level2	test9.c	/^void level2()$/;"	f
lfind	lsearch.c	/^char *lfind(key, base, count, width, keycmp)$/;"	f
lheads	at_wini.c	/^  unsigned lheads;		\/* logical number of heads *\/$/;"	m	struct:wini	file:
limit	protect.c	/^  char limit[sizeof(u16_t)];$/;"	m	struct:desctableptr_s	file:
limit_low	type.h	/^  u16_t limit_low;$/;"	m	struct:segdesc_s
line	getprotoent.c	/^static char line[BUFSIZ+1];$/;"	v	file:
line	getservent.c	/^static char line[BUFSIZ+1];$/;"	v	file:
line_ctl_port	rs232.c	/^  port_t line_ctl_port;$/;"	m	struct:rs232	file:
line_int	rs232.c	/^PRIVATE void line_int(rs)$/;"	f
line_status_port	rs232.c	/^  port_t line_status_port;$/;"	m	struct:rs232	file:
lineptr	getgrent.c	/^static char *lineptr;			\/* Place in the line. *\/$/;"	v	file:
lineptr	getpwent.c	/^static char *lineptr;			\/* Place in the line. *\/$/;"	v	file:
lineptr	getttyent.c	/^static char *lineptr;			\/* Place in the line. *\/$/;"	v	file:
link	_link.c	/^PUBLIC int link(name, name2)$/;"	f
link	_link.c	2;"	d	file:
link_alot	test17.c	/^int link_alot(bigboss)$/;"	f
linkid	aha_scsi.c	/^    byte linkid;		\/* Command Linking Identifier *\/$/;"	m	struct:__anon10	file:
linkptr	aha_scsi.c	/^    big24 linkptr;		\/* Link Pointer: 3 bytes, big endian *\/$/;"	m	struct:__anon10	file:
load	bootblock.s	/^load:$/;"	l
load	extboot.s	/^load:$/;"	l
load	masterboot.s	/^load:$/;"	l
load0	masterboot.s	/^load0:$/;"	l
load_mtab	mtab.c	/^int load_mtab(prog_name)$/;"	f
load_ram	main.c	/^PRIVATE void load_ram()$/;"	f
load_seg	exec.c	/^PRIVATE void load_seg(fd, seg, seg_bytes)$/;"	f
load_super	main.c	/^PRIVATE void load_super(super_dev)$/;"	f
loadboot	bootblock.s	/^loadboot:$/;"	l
loadpart	masterboot.s	/^loadpart:$/;"	l
localeconv	localeconv.c	/^localeconv(void)$/;"	f
localtime	localtime.c	/^localtime(const time_t *timer)$/;"	f
lock_first	lock.h	/^  off_t lock_first;		\/* offset of first byte locked *\/$/;"	m	struct:file_lock
lock_inode	lock.h	/^  struct inode *lock_inode;	\/* pointer to the inode locked *\/$/;"	m	struct:file_lock	typeref:struct:file_lock::inode
lock_last	lock.h	/^  off_t lock_last;		\/* offset of last byte locked *\/$/;"	m	struct:file_lock
lock_mini_send	proc.c	/^PUBLIC int lock_mini_send(caller_ptr, dest, m_ptr)$/;"	f
lock_op	lock.c	/^PUBLIC int lock_op(f, req)$/;"	f
lock_pick_proc	proc.c	/^PUBLIC void lock_pick_proc()$/;"	f
lock_pid	lock.h	/^  pid_t lock_pid;		\/* pid of the process holding the lock *\/$/;"	m	struct:file_lock
lock_ready	proc.c	/^PUBLIC void lock_ready(rp)$/;"	f
lock_revive	lock.c	/^PUBLIC void lock_revive()$/;"	f
lock_sched	proc.c	/^PUBLIC void lock_sched()$/;"	f
lock_type	lock.h	/^  short lock_type;		\/* F_RDLOCK or F_WRLOCK; 0 means unused slot *\/$/;"	m	struct:file_lock
lock_unready	proc.c	/^PUBLIC void lock_unready(rp)$/;"	f
locked	test7.c	/^int locked(b)$/;"	f
log	log.c	/^log(double x)$/;"	f
log10	log10.c	/^log10(double x)$/;"	f
longjerr	_longjerr.c	/^PUBLIC void longjerr()$/;"	f
longjerr	_longjerr.c	2;"	d	file:
longjerr	test8.c	/^void longjerr()$/;"	f
longname	longname.c	/^char *longname()$/;"	f
loop	trp.s	/^loop 1b$/;"	l
lost_ticks	glo.h	/^EXTERN unsigned lost_ticks;	\/* clock ticks counted outside the clock task *\/$/;"	v
low	type.h	/^		u32_t low;$/;"	m	struct:fsave::fpp_model::fpN
low_memsize	glo.h	/^EXTERN unsigned low_memsize;$/;"	v
low_user	ps.c	114;"	d	file:
lowsec	boot.h	/^EXTERN u32_t lowsec;	\/* Offset to the file system on the boot device. *\/$/;"	v
lowsec	bootblock.s	/^	lowsec	   =	     2	! Offset of boot partition within drive$/;"	d
lowsec	extboot.s	/^	lowsec	   =	     8$/;"	d
lowsec	masterboot.s	/^	lowsec	   =	     8$/;"	d
lrand	lrand.c	/^long lrand()$/;"	f
ls	boot.c	/^void ls(char *dir)$/;"	f
ls_fd	param.h	15;"	d
lsearch	lsearch.c	/^char *lsearch(key, base, count, width, keycmp)$/;"	f
lsectors	at_wini.c	/^  unsigned lsectors;		\/* logical number of sectors per track *\/$/;"	m	struct:wini	file:
lseek	_lseek.c	/^PUBLIC off_t lseek(fd, offset, whence)$/;"	f
lseek	_lseek.c	2;"	d	file:
lseek	_seekdir.c	6;"	d	file:
lstatus	rs232.c	/^  unsigned char lstatus;	\/* last line status *\/$/;"	m	struct:rs232	file:
lun	aha_scsi.c	/^    char lun;			\/* SCSI Logical Unit Number *\/$/;"	m	struct:scsi	file:
lunra	aha_scsi.c	206;"	d	file:
m	system.c	/^PRIVATE message m;$/;"	v
m1	FP_types.h	43;"	d
m1	ext_fmt.h	10;"	d
m2	FP_types.h	44;"	d
m2	ext_fmt.h	11;"	d
m_device	memory.c	/^PRIVATE int m_device;		\/* current device *\/$/;"	v
m_do_open	memory.c	/^PRIVATE int m_do_open(dp, m_ptr)$/;"	f
m_dtab	memory.c	/^PRIVATE struct driver m_dtab = {$/;"	v	typeref:struct:driver
m_geom	memory.c	/^PRIVATE struct device m_geom[NR_RAMS];	\/* Base and size of each RAM disk *\/$/;"	v	typeref:struct:device
m_geometry	memory.c	/^PRIVATE void m_geometry(entry)$/;"	f
m_init	memory.c	/^PRIVATE void m_init()$/;"	f
m_ioctl	memory.c	/^PRIVATE int m_ioctl(dp, m_ptr)$/;"	f
m_prepare	memory.c	/^PRIVATE struct device *m_prepare(device)$/;"	f
m_schedule	memory.c	/^PRIVATE int m_schedule(proc_nr, iop)$/;"	f
mailbox	aha_scsi.c	/^PRIVATE mailbox_t mailbox[2];	\/* out and in mailboxes *\/$/;"	v
mailbox_t	aha_scsi.c	/^} mailbox_t;$/;"	t	typeref:struct:__anon2	file:
main	edparams.c	/^void main(int argc, char **argv)$/;"	f
main	genmap.c	/^int main(void)$/;"	f
main	inet.c	/^PUBLIC void main()$/;"	f
main	init.c	/^int main(void)$/;"	f
main	installboot.c	/^int main(int argc, char **argv)$/;"	f
main	main.c	/^PUBLIC void main()$/;"	f
main	ps.c	/^int main(argc, argv)$/;"	f
main	t10a.c	/^int main()$/;"	f
main	t11a.c	/^int main(argc, argv, envp)$/;"	f
main	t11b.c	/^int main(argc, argv)$/;"	f
main	test1.c	/^int main(argc, argv)$/;"	f
main	test10.c	/^int main()$/;"	f
main	test11.c	/^int main(argc, argv)$/;"	f
main	test12.c	/^int main()$/;"	f
main	test13.c	/^int main()$/;"	f
main	test14.c	/^int main()$/;"	f
main	test15.c	/^int main(argc, argv)$/;"	f
main	test16.c	/^int main(argc, argv)$/;"	f
main	test17.c	/^int main(argc, argv)$/;"	f
main	test18.c	/^int main()$/;"	f
main	test19.c	/^int main(argc, argv)$/;"	f
main	test2.c	/^int main(argc, argv)$/;"	f
main	test20.c	/^int main(argc, argv)$/;"	f
main	test21.c	/^int main(argc, argv)$/;"	f
main	test22.c	/^void main(argc, argv)$/;"	f
main	test23.c	/^void main(argc, argv)$/;"	f
main	test24.c	/^void main(argc, argv)$/;"	f
main	test25.c	/^void main(argc, argv)$/;"	f
main	test26.c	/^void main(argc, argv)$/;"	f
main	test27.c	/^void main(argc, argv)$/;"	f
main	test28.c	/^void main(argc, argv)$/;"	f
main	test29.c	/^void main(argc, argv)$/;"	f
main	test3.c	/^int main(argc, argv)$/;"	f
main	test30.c	/^void main(argc, argv)$/;"	f
main	test31.c	/^void main(argc, argv)$/;"	f
main	test32.c	/^void main(argc, argv)$/;"	f
main	test33.c	/^void main(argc, argv)$/;"	f
main	test34.c	/^void main(argc, argv)$/;"	f
main	test35.c	/^void main(argc, argv)$/;"	f
main	test36.c	/^void main(argc, argv)$/;"	f
main	test37.c	/^void main(argc, argv)$/;"	f
main	test38.c	/^void main(argc, argv)$/;"	f
main	test39.c	/^void main(argc, argv)$/;"	f
main	test4.c	/^int main()$/;"	f
main	test40.c	/^void main(argc, argv)$/;"	f
main	test5.c	/^int main(argc, argv)$/;"	f
main	test6.c	/^int main(argc, argv)$/;"	f
main	test7.c	/^int main(argc, argv)$/;"	f
main	test8.c	/^int main(argc, argv)$/;"	f
main	test9.c	/^int main(argc, argv)$/;"	f
main	testit.c	/^main(ac, av)$/;"	f
majdev	ps.c	88;"	d	file:
major	device.c	/^PRIVATE major, minor, task;$/;"	v
major_to	tcp_send.c	/^PRIVATE void major_to(conn, timer)$/;"	f
makeColor	ÏÂÔØËµÃ÷.htm	/^function makeColor()$/;"	f
make_and_fill_dirs	test17.c	/^void make_and_fill_dirs()$/;"	f
make_and_fill_dirs	test18.c	/^void make_and_fill_dirs()$/;"	f
make_bootable	installboot.c	/^void make_bootable(enum howto how, char *device, char *bootblock,$/;"	f
make_break	keyboard.c	/^PRIVATE unsigned make_break(scode)$/;"	f
make_image	installboot.c	/^void make_image(char *image, char **procv)$/;"	f
make_pack	tcp_send.c	/^PRIVATE acc_t *make_pack(tcp_conn)$/;"	f
make_repl_ip	icmp.c	/^PRIVATE acc_t *make_repl_ip(ip_hdr, ip_len)$/;"	f
makelongnames	test23.c	/^void makelongnames()$/;"	f
makelongnames	test24.c	/^void makelongnames()$/;"	f
makelongnames	test25.c	/^void makelongnames()$/;"	f
makelongnames	test26.c	/^void makelongnames()$/;"	f
makelongnames	test27.c	/^void makelongnames()$/;"	f
makelongnames	test28.c	/^void makelongnames()$/;"	f
makelongnames	test30.c	/^void makelongnames()$/;"	f
makelongnames	test31.c	/^void makelongnames()$/;"	f
makelongnames	test32.c	/^void makelongnames()$/;"	f
makelongnames	test33.c	/^void makelongnames()$/;"	f
makelongnames	test34.c	/^void makelongnames()$/;"	f
makelongnames	test35.c	/^void makelongnames()$/;"	f
makelongnames	test36.c	/^void makelongnames()$/;"	f
makelongnames	test39.c	/^void makelongnames()$/;"	f
makenew	newwin.c	/^static WINDOW *makenew(num_lines, num_columns, begy, begx)$/;"	f	file:
making_image	installboot.c	/^int making_image= 0;$/;"	v
malloc	malloc.c	/^malloc(size_t size)$/;"	f
mantissa	FP_types.h	/^	B64	mantissa;$/;"	m	struct:__anon19
mantissa	ext_fmt.h	/^	struct mantissa mantissa;$/;"	m	struct:EXTEND	typeref:struct:EXTEND::mantissa
mantissa	ext_fmt.h	/^struct mantissa {$/;"	s
map_dmp	dmp.c	/^PUBLIC void map_dmp()$/;"	f
map_key	keyboard.c	/^PRIVATE unsigned map_key(scode)$/;"	f
map_key0	keyboard.c	85;"	d	file:
master	masterboot.s	/^master:$/;"	l
max	curspriv.h	16;"	d
max_count	at_wini.c	/^  unsigned max_count;		\/* max request for this drive *\/$/;"	m	struct:wini	file:
max_d	ext_comp.c	/^static struct EXTEND max_d;$/;"	v	typeref:struct:EXTEND	file:
max_hole	alloc.c	/^PUBLIC phys_clicks max_hole()$/;"	f
max_major	table.c	/^PUBLIC int max_major = sizeof(dmap)\/sizeof(struct dmap);$/;"	v
mb	cursesio.c	/^char *mb;			\/* start of blink *\/$/;"	v
mblen	mblen.c	/^mblen(const char *s, size_t n)$/;"	f
mbstowcs	mbstowcs.c	/^mbstowcs(register wchar_t *pwcs, register const char *s, size_t n)$/;"	f
mbtowc	mbtowc.c	/^mbtowc(wchar_t *pwc, register const char *s, size_t n)$/;"	f
mc	clock.c	/^PRIVATE message mc;		\/* message buffer for both input and output *\/$/;"	v
mcd_avail	mcd.c	/^PRIVATE int mcd_avail;			\/* Set if Mitsumi device exists *\/$/;"	v
mcd_close	mcd.c	/^PRIVATE int mcd_close(dp, m_ptr)$/;"	f
mcd_count	mcd.c	/^PRIVATE unsigned mcd_count;		\/* Number of bytes to transfer *\/$/;"	v
mcd_data_ready	mcd.c	/^PRIVATE int mcd_data_ready(delay)$/;"	f
mcd_dtab	mcd.c	/^PRIVATE struct driver mcd_dtab = $/;"	v	typeref:struct:driver
mcd_dv	mcd.c	/^PRIVATE struct device *mcd_dv;		\/* Active partition *\/$/;"	v	typeref:struct:device
mcd_eject	mcd.c	/^PRIVATE int mcd_eject()$/;"	f
mcd_finish	mcd.c	/^PRIVATE int mcd_finish()$/;"	f
mcd_geometry	mcd.c	/^PRIVATE void mcd_geometry(entry)$/;"	f
mcd_get_disk_info	mcd.c	/^PRIVATE int mcd_get_disk_info()$/;"	f
mcd_get_reply	mcd.c	/^PRIVATE int mcd_get_reply(reply, delay)$/;"	f
mcd_get_status	mcd.c	/^PRIVATE int mcd_get_status(f)$/;"	f
mcd_init	mcd.c	/^PRIVATE int mcd_init()$/;"	f
mcd_io_base	mcd.c	/^PRIVATE int mcd_io_base;		\/* I\/O base register *\/$/;"	v
mcd_ioctl	mcd.c	/^PRIVATE int mcd_ioctl(dp, m_ptr)$/;"	f
mcd_irq	mcd.c	/^PRIVATE int mcd_irq;			\/* Interrupt request line *\/$/;"	v
mcd_name	mcd.c	/^PRIVATE char *mcd_name()$/;"	f
mcd_nextpos	mcd.c	/^PRIVATE unsigned long mcd_nextpos;	\/* Next consecutive position on disk *\/$/;"	v
mcd_open	mcd.c	/^PRIVATE int mcd_open(dp, m_ptr)$/;"	f
mcd_open_ct	mcd.c	/^PRIVATE int mcd_open_ct;		\/* in-use count *\/$/;"	v
mcd_part	mcd.c	/^PRIVATE struct device mcd_part[DEV_PER_DRIVE];$/;"	v	typeref:struct:device
mcd_pause	mcd.c	/^PRIVATE int mcd_pause()$/;"	f
mcd_play_mss	mcd.c	/^PRIVATE int mcd_play_mss(mss)$/;"	f
mcd_play_tracks	mcd.c	/^PRIVATE int mcd_play_tracks(tracks)$/;"	f
mcd_prepare	mcd.c	/^PRIVATE struct device *mcd_prepare(device)$/;"	f
mcd_read_q_channel	mcd.c	/^PRIVATE int mcd_read_q_channel(qc)$/;"	f
mcd_read_toc	mcd.c	/^PRIVATE int mcd_read_toc()$/;"	f
mcd_ready	mcd.c	/^PRIVATE int mcd_ready(delay)$/;"	f
mcd_resume	mcd.c	/^PRIVATE int mcd_resume()$/;"	f
mcd_schedule	mcd.c	/^PRIVATE int mcd_schedule(proc_nr, iop)$/;"	f
mcd_send_command	mcd.c	/^PRIVATE int mcd_send_command(command)$/;"	f
mcd_set_mode	mcd.c	/^PRIVATE int mcd_set_mode(mode)$/;"	f
mcd_stop	mcd.c	/^PRIVATE int mcd_stop()$/;"	f
mcd_subpart	mcd.c	/^PRIVATE struct device mcd_subpart[SUB_PER_DRIVE];$/;"	v	typeref:struct:device
mcd_task	mcd.c	/^PUBLIC void mcd_task()$/;"	f
mcd_tasknr	mcd.c	/^PRIVATE int mcd_tasknr = ANY;$/;"	v
mcd_tp	mcd.c	/^PRIVATE struct trans *mcd_tp;		\/* Pointer to add transfer requests *\/$/;"	v	typeref:struct:trans
mcd_trans	mcd.c	/^} mcd_trans[NR_IOREQS];$/;"	v	typeref:struct:trans
md	cursesio.c	/^char *md;			\/* start of bold *\/$/;"	v
me	cursesio.c	/^char *me;			\/* revert to normal *\/$/;"	v
mem	glo.h	/^EXTERN struct memory mem[NR_MEMS];	\/* base and size of chunks of memory *\/$/;"	v	typeref:struct:memory
mem_dmp	dmp.c	/^PRIVATE void mem_dmp(adr, len)$/;"	f
mem_init	alloc.c	/^PUBLIC void mem_init(total, free)$/;"	f
mem_task	memory.c	/^PUBLIC void mem_task()$/;"	f
members	getgrent.c	/^static char *members[64];		\/* Group members with the entry. *\/$/;"	v	file:
memccpy	memccpy.c	/^void *memccpy(dst, src, ucharstop, size)$/;"	f
memchr	memchr.c	/^memchr(const void *s, register int c, register size_t n)$/;"	f
memcmp	memcmp.c	/^memcmp(const void *s1, const void *s2, size_t n)$/;"	f
memcpy	memcpy.c	/^memcpy(void *s1, const void *s2, register size_t n)$/;"	f
memcspn	memcspn.c	/^memcspn(const char *string, size_t strlen, const char *notin, size_t notinlen)$/;"	f
memfd	ps.c	/^int kmemfd, memfd;		\/* file descriptors of [k]mem *\/$/;"	v
memmove	memmove.c	/^memmove(void *s1, const void *s2, register size_t n)$/;"	f
memory	type.h	/^struct memory {$/;"	s
memset	memset.c	/^memset(void *s, register int c, register size_t n)$/;"	f
menu	boot.c	/^void menu(void)$/;"	f
menu	edparams.c	/^void menu(void)$/;"	f
menufun	boot.c	/^enum whatfun { NOFUN, SELECT, DEFFUN, USERFUN } menufun(environment *e)$/;"	f
menufun	edparams.c	/^enum whatfun { NOFUN, SELECT, DEFFUN, USERFUN } menufun(environment *e)$/;"	f
merge	alloc.c	/^PRIVATE void merge(hp)$/;"	f
merge_frags	ip_read.c	/^PRIVATE acc_t *merge_frags (first, second)$/;"	f
merge_packs	tcp_recv.c	/^PRIVATE acc_t *merge_packs(first, next)$/;"	f
mess	pipe.c	/^PRIVATE message mess;$/;"	v
mess_reply	dp8390.c	/^static void mess_reply(req, reply_mess)$/;"	f	file:
meta	editline.c	/^meta()$/;"	f
meta	options.c	/^void meta(win, flag)$/;"	f
mid	type.h	/^		u32_t mid;$/;"	m	struct:fsave::fpp_model::fpN
migrate	boot.c	/^void migrate(void)$/;"	f
migrate	extboot.s	/^migrate:$/;"	l
migrate	masterboot.s	/^migrate:$/;"	l
milli_delay	clock.c	/^PUBLIC void milli_delay(millisec)$/;"	f
milli_elapsed	clock.c	/^PUBLIC unsigned milli_elapsed(msp)$/;"	f
milli_since	boot.c	/^u32_t milli_since(u32_t base)$/;"	f
milli_since	edparams.c	/^u32_t milli_since(u32_t base)$/;"	f
milli_start	clock.c	/^PUBLIC void milli_start(msp)$/;"	f
milli_state	type.h	/^struct milli_state {$/;"	s
milli_time	boot.c	/^u32_t milli_time(void)$/;"	f
milli_time	edparams.c	/^u32_t milli_time(void)$/;"	f
millitm	misc.c	/^	unsigned short millitm;$/;"	m	struct:timeb	file:
min	curspriv.h	17;"	d
mindev	ps.c	87;"	d	file:
mini_rec	proc.c	/^PRIVATE int mini_rec(caller_ptr, src, m_ptr)$/;"	f
mini_send	proc.c	/^PRIVATE int mini_send(caller_ptr, dest, m_ptr)$/;"	f
minix386	boothead.s	/^minix386:$/;"	l
minix86	boothead.s	/^minix86:$/;"	l
minor	device.c	/^PRIVATE major, minor, task;$/;"	v
minor_1a	boot.c	886;"	d	file:
minor_to	tcp_send.c	/^PRIVATE void minor_to(conn, timer)$/;"	f
mixer_avail	sb16_mixer.c	/^PRIVATE int mixer_avail = 0;	\/* Mixer exists? *\/$/;"	v
mixer_close	sb16_mixer.c	/^PRIVATE int mixer_close(m_ptr)$/;"	f
mixer_get	sb16_mixer.c	/^PRIVATE int mixer_get(reg)$/;"	f
mixer_init	sb16_mixer.c	/^PRIVATE int mixer_init()$/;"	f
mixer_ioctl	sb16_mixer.c	/^PRIVATE int mixer_ioctl(m_ptr)$/;"	f
mixer_open	sb16_mixer.c	/^PRIVATE int mixer_open(m_ptr)$/;"	f
mixer_set	sb16_mixer.c	/^PUBLIC int mixer_set(reg, data)$/;"	f
mixer_task	sb16_mixer.c	/^PUBLIC void mixer_task()$/;"	f
mk_mode	param.h	16;"	d
mk_set	editline.c	/^mk_set()$/;"	f
mkdir	_mkdir.c	/^PUBLIC int mkdir(name, mode)$/;"	f
mkdir	_mkdir.c	2;"	d	file:
mkfifo	_mkfifo.c	/^PUBLIC int mkfifo(name, mode)$/;"	f
mkfifo	_mkfifo.c	2;"	d	file:
mkfiles	test10.c	/^void mkfiles()$/;"	f
mknod	_mkfifo.c	3;"	d	file:
mknod	_mknod.c	/^PUBLIC int mknod(name, mode, dev)$/;"	f
mknod	_mknod.c	2;"	d	file:
mktemp	_mktemp.c	/^PUBLIC char *mktemp(template)$/;"	f
mktemp	_mktemp.c	6;"	d	file:
mktime	mktime.c	/^mktime(register struct tm *timep)$/;"	f
mlf4	mlf4.c	/^mlf4(s2,s1)$/;"	f
mlf8	mlf8.c	/^mlf8(s2,s1)$/;"	f
mm_exit	forkexit.c	/^PUBLIC void mm_exit(rmp, exit_status)$/;"	f
mode	param.h	17;"	d
mode	test22.c	/^int mode(arg)$/;"	f
mode_map	open.c	/^PRIVATE char mode_map[] = {R_BIT, W_BIT, R_BIT|W_BIT, 0};$/;"	v
modem_ctl_port	rs232.c	/^  port_t modem_ctl_port;$/;"	m	struct:rs232	file:
modem_int	rs232.c	/^PRIVATE void modem_int(rs)$/;"	f
modem_status_port	rs232.c	/^  port_t modem_status_port;$/;"	m	struct:rs232	file:
mon_return	glo.h	/^EXTERN int mon_return;		\/* true if return to the monitor possible *\/$/;"	v
mon_sp	glo.h	/^EXTERN reg_t mon_ss, mon_sp;	\/* monitor stack *\/$/;"	v
mon_ss	glo.h	/^EXTERN reg_t mon_ss, mon_sp;	\/* monitor stack *\/$/;"	v
monitor	boot.c	/^void monitor(void)$/;"	f
monitor	edparams.c	/^void monitor(void)$/;"	f
more	boothead.s	/^more:	mov	ax, 8(bp)$/;"	l
motor_goal	floppy.c	/^PRIVATE int motor_goal;		\/* bitmap of desired motor status *\/$/;"	v
motor_status	floppy.c	/^PRIVATE int motor_status;	\/* bitmap of current motor status *\/$/;"	v
mount	_mount.c	/^PUBLIC int mount(special, name, rwflag)$/;"	f
mount	_mount.c	2;"	d	file:
mounted	super.c	/^PUBLIC int mounted(rip)$/;"	f
mov	trp.s	/^mov .M+10,bx$/;"	l
mov	trp.s	/^mov .M+2,#4$/;"	l
mov	trp.s	/^mov .M+4,bx$/;"	l
mov	trp.s	/^mov .M+6,bx$/;"	l
mov	trp.s	/^mov ax,#.M$/;"	l
mov	trp.s	/^mov ax,#1$/;"	l
mov	trp.s	/^mov ax,#17$/;"	l
mov	trp.s	/^mov ax,#18$/;"	l
mov	trp.s	/^mov ax,#2$/;"	l
mov	trp.s	/^mov ax,#20$/;"	l
mov	trp.s	/^mov ax,#6$/;"	l
mov	trp.s	/^mov bp,sp$/;"	l
mov	trp.s	/^mov bx,#.M$/;"	l
mov	trp.s	/^mov bx,#.Mtable$/;"	l
mov	trp.s	/^mov bx,#.Mtrp+14$/;"	l
mov	trp.s	/^mov bx,#22$/;"	l
mov	trp.s	/^mov bx,(bx)$/;"	l
mov	trp.s	/^mov bx,4(bp)$/;"	l
mov	trp.s	/^mov bx,6(bp)$/;"	l
mov	trp.s	/^mov bx,8(bp)$/;"	l
mov	trp.s	/^mov cx,#3$/;"	l
mov	trp.s	/^mov cx,#6$/;"	l
mov	trp.s	/^mov dx,#.Mcase$/;"	l
mov	trp.s	/^mov dx,#.Mdivz$/;"	l
mov	trp.s	/^mov dx,#.Mheap$/;"	l
mov	trp.s	/^mov dx,#.Milin$/;"	l
mov	trp.s	/^mov dx,#.Mnofp$/;"	l
mov	trp.s	/^mov dx,#.Mrang$/;"	l
mov	trp.s	/^mov dx,#.Mset$/;"	l
mov	trp.s	/^mov dx,#.Mtrp$/;"	l
mov	trp.s	/^mov dx,ax$/;"	l
mov	trp.s	/^mov dx,bx$/;"	l
mov	trp.s	/^mov sp,bp$/;"	l
movb	trp.s	/^movb (bx),dl$/;"	l
move_to_char	editline.c	/^move_to_char()$/;"	f
mp_catch	mproc.h	/^  sigset_t mp_catch;		\/* 1 means catch the signal, 0 means don't *\/$/;"	m	struct:mproc
mp_ctime	mproc.h	/^  time_t mp_ctime;		\/* inode changed time *\/$/;"	m	struct:mproc
mp_dev	mproc.h	/^  dev_t mp_dev;			\/* device number of file system *\/$/;"	m	struct:mproc
mp_effgid	mproc.h	/^  gid_t mp_effgid;		\/* process' effective gid *\/$/;"	m	struct:mproc
mp_effuid	mproc.h	/^  uid_t mp_effuid;		\/* process' effective uid *\/$/;"	m	struct:mproc
mp_exitstatus	mproc.h	/^  char mp_exitstatus;		\/* storage for status when process exits *\/$/;"	m	struct:mproc
mp_flags	mproc.h	/^  unsigned mp_flags;		\/* flag bits *\/$/;"	m	struct:mproc
mp_func	mproc.h	/^  sighandler_t mp_func;		\/* all sigs vectored to a single user fcn *\/$/;"	m	struct:mproc
mp_ignore	mproc.h	/^  sigset_t mp_ignore;		\/* 1 means ignore the signal, 0 means don't *\/$/;"	m	struct:mproc
mp_ino	mproc.h	/^  ino_t mp_ino;			\/* inode number of file *\/$/;"	m	struct:mproc
mp_parent	mproc.h	/^  int mp_parent;		\/* index of parent process *\/$/;"	m	struct:mproc
mp_pid	mproc.h	/^  pid_t mp_pid;			\/* process id *\/$/;"	m	struct:mproc
mp_procargs	mproc.h	/^  vir_bytes mp_procargs;        \/* ptr to proc's initial stack arguments *\/$/;"	m	struct:mproc
mp_procgrp	mproc.h	/^  pid_t mp_procgrp;		\/* pid of process group (used for signals) *\/$/;"	m	struct:mproc
mp_realgid	mproc.h	/^  gid_t mp_realgid;		\/* process' real gid *\/$/;"	m	struct:mproc
mp_realuid	mproc.h	/^  uid_t mp_realuid;		\/* process' real uid *\/$/;"	m	struct:mproc
mp_seg	mproc.h	/^  struct mem_map mp_seg[NR_SEGS];\/* points to text, data, stack *\/$/;"	m	struct:mproc	typeref:struct:mproc::mem_map
mp_sigact	mproc.h	/^  struct sigaction mp_sigact[_NSIG + 1]; \/* as in sigaction(2) *\/$/;"	m	struct:mproc	typeref:struct:mproc::sigaction
mp_sigmask	mproc.h	/^  sigset_t mp_sigmask;		\/* signals to be blocked *\/$/;"	m	struct:mproc
mp_sigmask2	mproc.h	/^  sigset_t mp_sigmask2;		\/* saved copy of mp_sigmask *\/$/;"	m	struct:mproc
mp_sigpending	mproc.h	/^  sigset_t mp_sigpending;	\/* signals being blocked *\/$/;"	m	struct:mproc
mp_sigreturn	mproc.h	/^  vir_bytes mp_sigreturn; 	\/* address of C library __sigreturn function *\/$/;"	m	struct:mproc
mp_sigstatus	mproc.h	/^  char mp_sigstatus;		\/* storage for signal # for killed procs *\/$/;"	m	struct:mproc
mp_wpid	mproc.h	/^  pid_t mp_wpid;		\/* pid this process is waiting for *\/$/;"	m	struct:mproc
mproc	mproc.h	/^EXTERN struct mproc {$/;"	s
mproc	mproc.h	/^} mproc[NR_PROCS];$/;"	v	typeref:struct:mproc
mq	mq.h	/^typedef struct mq$/;"	s
mq_free	mq.c	/^void mq_free(mq)$/;"	f
mq_freelist	mq.c	/^PRIVATE mq_t *mq_freelist;$/;"	v
mq_get	mq.c	/^mq_t *mq_get()$/;"	f
mq_init	mq.c	/^void mq_init()$/;"	f
mq_list	mq.c	/^PRIVATE mq_t mq_list[MQ_SIZE];$/;"	v
mq_mess	mq.h	/^	message mq_mess;$/;"	m	struct:mq
mq_next	mq.h	/^	struct mq *mq_next;$/;"	m	struct:mq	typeref:struct:mq::mq
mq_t	mq.h	/^} mq_t;$/;"	t	typeref:struct:mq
mr	cursesio.c	/^char *mr;			\/* start of reverse *\/$/;"	v
mss2block	mcd.c	/^PRIVATE long mss2block(u8_t *mss)$/;"	f
msw	klib88.s	/^msw:				! saved real mode machine status word$/;"	l
mtab_in	mtab.c	/^static char mtab_in[BUF_SIZE+1];  \/* holds \/etc\/mtab when it is read in *\/$/;"	v	file:
mtab_out	mtab.c	/^static char mtab_out[BUF_SIZE+1]; \/* buf to build \/etc\/mtab for output later *\/$/;"	v	file:
mtr_setup	floppy.c	/^PRIVATE char mtr_setup[NT] =$/;"	v
mul_ext	ext_comp.c	/^mul_ext(struct EXTEND *e1, struct EXTEND *e2, struct EXTEND *e3)$/;"	f	file:
mul_ext	mul_ext.c	/^mul_ext(e1,e2)$/;"	f
mulb	bootblock.s	/^	mulb	dh		! dh = heads, ax = heads * sectors$/;"	d
mulb	boothead.s	/^	mulb	dh		! ax = heads * sectors$/;"	d
mulb	extboot.s	/^	mulb	dh		! dh = heads, ax = heads * sectors$/;"	d
mulb	masterboot.s	/^	mulb	dh		! dh = heads, ax = heads * sectors$/;"	d
mvc_blank	klib386.s	/^mvc_blank:$/;"	l
mvc_blank	klib88.s	/^mvc_blank:$/;"	l
mvc_copy	klib386.s	/^mvc_copy:$/;"	l
mvc_copy	klib88.s	/^mvc_copy:$/;"	l
mvc_done	klib386.s	/^mvc_done:$/;"	l
mvc_done	klib88.s	/^mvc_done:$/;"	l
mvc_loop	klib386.s	/^mvc_loop:$/;"	l
mvc_loop	klib88.s	/^mvc_loop:$/;"	l
mvc_test	klib386.s	/^mvc_test:$/;"	l
mvc_test	klib88.s	/^mvc_test:$/;"	l
mvcur	mvcursor.c	/^int mvcur(oldy, oldx, newy, newx)$/;"	f
mvinch	charpick.c	/^int mvinch(y, x)$/;"	f
mvprintw	prntscan.c	/^int mvprintw(int y, int x, const char *fmt, ...)$/;"	f
mvscanw	prntscan.c	/^int mvscanw(int y, int x, const char *fmt, ...)$/;"	f
mvwin	winmove.c	/^int mvwin(win, begy, begx)$/;"	f
mvwinch	charpick.c	/^int mvwinch(win, y, x)$/;"	f
mvwprintw	prntscan.c	/^int mvwprintw(WINDOW *win, int y, int x, const char *fmt, ...)$/;"	f
mvwscanw	prntscan.c	/^int mvwscanw(WINDOW *win, int y, int x, const char *fmt, ...)$/;"	f
my_getcwd	test23.c	/^char *my_getcwd(buf, size)$/;"	f
n_procs	bootimage.c	/^int n_procs;			\/* Number of processes. *\/$/;"	v
n_ttyinfo	ps.c	/^size_t n_ttyinfo;		\/* Number of tty info slots *\/$/;"	v
name	boot.c	/^	char name[6];$/;"	m	struct:biosdev	file:
name	boot.h	/^	char	*name;		\/* name = value *\/$/;"	m	struct:environment
name	bootimage.c	/^	char	name[IM_NAME_MAX + 1]; \/* Nice to have a name for the thing. *\/$/;"	m	struct:process	file:
name	edparams.c	/^	char	*name;$/;"	m	struct:environment	file:
name	image.h	/^	char		name[IM_NAME_MAX + 1];	\/* Null terminated. *\/$/;"	m	struct:image_header
name	param.h	20;"	d
name	test10.c	/^char *name[] = {"t10a", "t10b", "t10c", "t10d", "t10e", "t10f", "t10g", $/;"	v
name	test14.c	/^char name[20] = {"TMP14."};$/;"	v
name	type.h	/^  char name[8];$/;"	m	struct:tasktab
name	wini.c	/^  char		*name;$/;"	m	struct:hdmap	file:
name1	param.h	21;"	d
name1_length	param.h	24;"	d
name2	param.h	22;"	d
name2_length	param.h	25;"	d
name2dev	boot.c	/^dev_t name2dev(char *name)$/;"	f
name_length	param.h	23;"	d
name_to_dev	mount.c	/^PRIVATE dev_t name_to_dev(path)$/;"	f
nblocks	aha_scsi.c	187;"	d	file:
nbytes	param.h	26;"	d
ne_init	ne2000.c	/^static void ne_init(dep)$/;"	f	file:
ne_probe	ne2000.c	/^int ne_probe(dep)$/;"	f
ne_stop	ne2000.c	/^static void ne_stop(dep)$/;"	f	file:
need_eof	aha_scsi.c	/^	    char need_eof;	\/* need to write an eof mark *\/$/;"	m	struct:scsi::__anon12::__anon13	file:
need_eof	aha_scsi.c	354;"	d	file:
need_reset	floppy.c	/^PRIVATE int need_reset;		\/* set to 1 when controller must be reset *\/$/;"	v
neg	dvi4.s	/^	neg     di$/;"	d
neg	dvi4.s	/^	neg     dx$/;"	d
neg	rmi4.s	/^	neg     di$/;"	d
neg	rmi4.s	/^	neg     dx$/;"	d
net_broad	ip_read.c	/^PRIVATE int net_broad (hostaddr, netaddr, netmask)$/;"	f
net_open	device.c	/^PUBLIC void net_open(task_nr, mess_ptr)$/;"	f
netbroad_dst	ip_write.c	/^PRIVATE ipaddr_t netbroad_dst;$/;"	v
netbroad_flags	ip_write.c	/^PRIVATE unsigned int netbroad_flags= NF_EMPTY;$/;"	v
netbroad_netmask	ip_write.c	/^PRIVATE ipaddr_t netbroad_netmask;$/;"	v
netbroad_pack	ip_write.c	/^PRIVATE acc_t *netbroad_pack;$/;"	v
netbroad_port	ip_write.c	/^PRIVATE ip_port_t *netbroad_port;$/;"	v
new_block	write.c	/^PUBLIC struct buf *new_block(rip, position)$/;"	f
new_icopy	fslib.c	/^PUBLIC void new_icopy(rip, dip, direction, norm)$/;"	f
new_icopy	inode.c	/^PRIVATE void new_icopy(rip, dip, direction, norm)$/;"	f
new_mem	exec.c	/^PRIVATE int new_mem(sh_mp, text_bytes, data_bytes,bss_bytes,stk_bytes,tot_bytes)$/;"	f
new_node	open.c	/^PRIVATE struct inode *new_node(path, bits, z0)$/;"	f
new_processor	getprocessor.s	/^new_processor:			! see if high bits are set in saved GDT$/;"	l
newattr	update.c	/^static void newattr(ch)$/;"	f	file:
newline	waddch.c	/^static short newline(win, lin)$/;"	f	file:
newwin	newwin.c	/^WINDOW *newwin(num_lines, num_columns, begy, begx)$/;"	f
next	boot.c	/^	struct token	*next;	\/* Next in a command chain. *\/$/;"	m	struct:token	typeref:struct:token::token	file:
next	boot.h	/^	struct environment *next;$/;"	m	struct:environment	typeref:struct:environment::environment
next	bootblock.s	/^next:	add	di, #DSKPARSIZE	! Next set of parameters$/;"	l
next	edparams.c	/^	struct environment *next;$/;"	m	struct:environment	typeref:struct:environment::environment	file:
next	edparams.c	/^	struct token	*next;	\/* Next in a command chain. *\/$/;"	m	struct:token	typeref:struct:token::token	file:
next	extboot.s	/^next:	add	si, #PENTRYSIZE$/;"	l
next	itoa.c	/^PRIVATE int next;$/;"	v
next	rand.c	/^static unsigned long int next = 1;$/;"	v	file:
next	strchr.s	/^next:	shl	edx, 1		! Chunks become bigger each time$/;"	l
next_alarm	clock.c	/^PRIVATE clock_t next_alarm;	\/* probable time of next alarm *\/$/;"	v
next_hist	editline.c	/^next_hist()$/;"	f
next_pid	forkexit.c	/^PRIVATE pid_t next_pid = INIT_PID+1;	\/* next pid to be assigned *\/$/;"	v
nextb	test4.c	/^int s, i, fd, nextb, errct = 0;$/;"	v
nextdisk	masterboot.s	/^nextdisk:$/;"	l
nexthd	masterboot.s	/^nexthd:	call	load0			! Read the hard disk bootstrap$/;"	l
nextpart	masterboot.s	/^nextpart:$/;"	l
ngf4	ngf4.c	/^ngf4(f)$/;"	f
ngf8	ngf8.c	/^ngf8(f)$/;"	f
nil	_closedir.c	4;"	d	file:
nil	_getcwd.c	5;"	d	file:
nil	_opendir.c	4;"	d	file:
nil	_readdir.c	4;"	d	file:
nil	_rewinddir.c	4;"	d	file:
nil	_seekdir.c	4;"	d	file:
nil	asynchio.c	8;"	d	file:
nil	boot.c	13;"	d	file:
nil	bootimage.c	4;"	d	file:
nil	crypt.c	6;"	d	file:
nil	edparams.c	5;"	d	file:
nil	getdomain.c	4;"	d	file:
nil	getgrent.c	6;"	d	file:
nil	getpwent.c	6;"	d	file:
nil	getttyent.c	4;"	d	file:
nil	installboot.c	6;"	d	file:
nil	printk.c	4;"	d	file:
nil	rawfs.c	5;"	d	file:
nil	telldir.c	4;"	d	file:
nl	setterm.c	/^void nl()$/;"	f
nlcr	test17.c	/^void nlcr()$/;"	f
nlcr	test18.c	/^void nlcr()$/;"	f
nlist	nlist.c	/^int nlist(file, nl)$/;"	f
no0	_strncat.s	/^no0:	sub	edx, ecx	! Number of bytes in s2$/;"	l
no0	_strnlen.s	/^no0:	mov	eax, edx$/;"	l
no_addr	res_send.c	/^static struct sockaddr no_addr;$/;"	v	typeref:struct:sockaddr	file:
no_dc	boothead.s	/^no_dc:	movb	ah, #0x12	! Get information about the EGA$/;"	l
no_dev	device.c	/^PUBLIC void no_dev(task_nr, m_ptr)$/;"	f
no_ega	boothead.s	/^no_ega:	int	0x11		! Get bit pattern for equipment$/;"	l
no_ext	boothead.s	/^no_ext:	xor	ax, ax		! Error, no extended memory$/;"	l
no_name	driver.c	/^PUBLIC char *no_name()$/;"	f
no_sys	utility.c	/^PUBLIC int no_sys()$/;"	f
noactive	masterboot.s	/^noactive:	.ascii	"None active\\r\\n\\0"$/;"	l
noalt	masterboot.s	/^noalt:$/;"	l
noboot	extboot.s	/^noboot:		.ascii	"Not bootable \\0"$/;"	l
noboot	masterboot.s	/^noboot:		.ascii	"Not bootable \\0"$/;"	l
nocbreak	setterm.c	/^void nocbreak()$/;"	f
nocr	boothead.s	/^nocr:	xorb	ah, ah		! ax = al$/;"	l
nodelay	options.c	/^void nodelay(win, flag)$/;"	f
noecho	setterm.c	/^void noecho()$/;"	f
nofork	test4.c	/^void nofork()$/;"	f
nohd	boothead.s	/^nohd:	cmpb	12(bp), #0	! count equals zero?$/;"	l
nomem	boothead.s	/^nomem:	.ascii	"\\nOut of%s\\0"$/;"	l
nonl	setterm.c	/^void nonl()$/;"	f
nonzero	setjmp.s	/^nonzero:$/;"	l
nonzero1	setjmp.s	/^nonzero1:$/;"	l
nop_cleanup	driver.c	/^PUBLIC void nop_cleanup()$/;"	f
nop_finish	driver.c	/^PUBLIC int nop_finish()$/;"	f
noraw	setterm.c	/^void noraw()$/;"	f
noret	mpx386.s	/^noret:	mov	(_mon_sp), esp	! save stack pointer for later return$/;"	l
noret	mpx88.s	/^noret:	mov	_mon_ss, ss	! save stack location for later return$/;"	l
noret386	boothead.s	/^noret386:$/;"	l
noret86	boothead.s	/^noret86:$/;"	l
nosig	extboot.s	/^nosig:	call	print$/;"	l
nosig	masterboot.s	/^nosig:	call	print$/;"	l
nosigstate	setjmp.s	/^nosigstate:$/;"	l
nosw	mpx88.s	/^nosw:$/;"	l
not	dvi4.s	/^	not     di$/;"	d
not_provided_option	test36.c	/^int not_provided_option(option)$/;"	f
notext	extboot.s	/^notext:	cmpb	sysind(si), #0$/;"	l
notfound	extboot.s	/^notfound:	.ascii	"Logical not found \\0"$/;"	l
nr_blocks	floppy.c	/^PRIVATE int nr_blocks[NT] =$/;"	v
nr_buf2	cache2.c	/^PRIVATE unsigned nr_buf2;		\/* actual cache size *\/$/;"	v
nr_cons	console.c	/^PRIVATE int nr_cons= 1;		\/* actual number of consoles *\/$/;"	v
nr_drives	bios_wini.c	/^PRIVATE int nr_drives = MAX_DRIVES;	\/* Number of drives *\/$/;"	v
nr_drives	esdi_wini.c	/^PRIVATE int nr_drives;		\/* actual number of physical disk drive  *\/$/;"	v
nr_drives	xt_wini.c	/^PRIVATE int nr_drives;			\/* Number of drives *\/$/;"	v
nr_dzones	rawfs.c	/^static unsigned nr_dzones;	\/* Fill these in after reading superblock. *\/$/;"	v	file:
nr_indirects	rawfs.c	/^static unsigned nr_indirects;$/;"	v	file:
nr_procs	ps.c	/^int nr_tasks, nr_procs;$/;"	v
nr_sectors	floppy.c	/^PRIVATE char nr_sectors[NT] =$/;"	v
nr_tasks	ps.c	/^int nr_tasks, nr_procs;$/;"	v
nrm_ext	nrm_ext.c	/^nrm_ext(e1)$/;"	f
ntstr	misc.c	/^static char ntstr[TZ_LEN + 1] = "GMT";	\/* string for normal time *\/$/;"	v	file:
nulch	boothead.s	/^nulch:	ret$/;"	l
null	boot.c	/^char null[]= "";	\/* This kludge saves lots of memory. *\/$/;"	v
null	edparams.c	/^char null[]= "";	\/* This kludge saves lots of memory. *\/$/;"	v
num_off	keyboard.c	/^PRIVATE int num_off;		\/* 1 = normal position, 0 = depressed *\/$/;"	v
numap	system.c	/^PUBLIC phys_bytes numap(proc_nr, vir_addr, bytes)$/;"	f
numeric	boot.c	/^int numeric(char *s)$/;"	f
numeric	edparams.c	/^int numeric(char *s)$/;"	f
numlock	keyboard.c	/^PRIVATE int numlock;		\/* number lock key state *\/$/;"	v
numpad_map	keyboard.c	/^PRIVATE char numpad_map[] =$/;"	v
numprefix	boot.c	/^int numprefix(char *s, char **ps)$/;"	f
nw_init	inet.c	/^PRIVATE void nw_init()$/;"	f
o32	boothead.s	/^	o32	    =	  0x66	! This assembler doesn't know 386 extensions$/;"	d
o32	getprocessor.s	/^	o32 = 0x66		! 32 bit operand size prefix$/;"	d
o_collect	doscan.c	/^o_collect(register int c, register FILE *stream, char type,$/;"	f	file:
o_print	doprnt.c	/^o_print(va_list *ap, int flags, char *s, char c, int precision, int is_signed)$/;"	f	file:
obuf	printer.c	/^PRIVATE char obuf[128];		\/* output buffer *\/$/;"	v
obuf	pty.c	/^  char		obuf[128];	\/* buffer for bytes going to the pty reader *\/$/;"	m	struct:pty	file:
obuf	rs232.c	/^  char obuf[RS_OBUFSIZE];	\/* output buffer *\/$/;"	m	struct:rs232	file:
ocount	pty.c	/^  int		ocount;		\/* # characters in the buffer *\/$/;"	m	struct:pty	file:
ocount	rs232.c	/^  int ocount;			\/* number of bytes in the output buffer *\/$/;"	m	struct:rs232	file:
off_to_k	ps.c	102;"	d	file:
offset	boot.h	/^	u16_t	offset;$/;"	m	struct:vector
offset	extboot.s	/^offset:		.data4	0$/;"	l
offset	param.h	27;"	d
offset_high	protect.c	/^  u16_t offset_high;$/;"	m	struct:gatedesc_s	file:
offset_low	protect.c	/^  u16_t offset_low;$/;"	m	struct:gatedesc_s	file:
ohead	pty.c	/^  char		*ohead, *otail;	\/* head and tail of the circular buffer *\/$/;"	m	struct:pty	file:
ohead	rs232.c	/^  char *ohead;			\/* next free spot in output buffer *\/$/;"	m	struct:rs232	file:
ok	extboot.s	/^ok:	cmp	LOADOFF+MAGIC, #0xAA55$/;"	l
ok	masterboot.s	/^ok:	cmp	LOADOFF+MAGIC, #0xAA55$/;"	l
ok_for_me	eth.c	/^PRIVATE int ok_for_me (eth_fd, pack)$/;"	f
ok_for_port	ip_read.c	/^PRIVATE int ok_for_port (ip_port, ipaddr, ref_broad_all)$/;"	f
old_icopy	fslib.c	/^PUBLIC void old_icopy(rip, dip, direction, norm)$/;"	f
old_icopy	inode.c	/^PRIVATE void old_icopy(rip, dip, direction, norm)$/;"	f
oldmode	options.c	/^static int oldmode;$/;"	v	file:
oleft	printer.c	/^PRIVATE int oleft;		\/* bytes of output left in obuf *\/$/;"	v
onabrt	init.c	/^void onabrt(int sig)$/;"	f
one	em_fp8087.s	/^one:$/;"	l
one	fp8087.s	/^one:$/;"	l
one	test15.c	/^char one[50];$/;"	v
oneC_sum	oneC_sum.c	/^u16_t oneC_sum(U16_t prev, void *data, size_t size)$/;"	f
onetoken	boot.c	/^char *onetoken(char **aline, int arg)$/;"	f
onetoken	edparams.c	/^char *onetoken(char **aline, int arg)$/;"	f
onhup	init.c	/^void onhup(int sig)$/;"	f
onterm	init.c	/^void onterm(int sig)$/;"	f
opcode	aha_scsi.c	/^    byte opcode;		\/* Operation Code *\/$/;"	m	struct:__anon10	file:
open	_open.c	/^PUBLIC int open(const char *name, int flags, ...)$/;"	f
open	_open.c	2;"	d	file:
open	_opendir.c	9;"	d	file:
open	_pathconf.c	5;"	d	file:
open	_uname.c	9;"	d	file:
open	getgrent.c	7;"	d	file:
open	getpass.c	4;"	d	file:
open	getpwent.c	7;"	d	file:
open	getttyent.c	5;"	d	file:
open_alot	test17.c	/^int open_alot()$/;"	f
open_alot	test18.c	/^int open_alot()$/;"	f
open_ct	aha_scsi.c	/^    unsigned open_ct;		\/* number of processes using the device *\/$/;"	m	struct:scsi	file:
open_ct	at_wini.c	/^  unsigned open_ct;		\/* in-use count *\/$/;"	m	struct:wini	file:
open_ct	bios_wini.c	/^  unsigned open_ct;		\/* in-use count *\/$/;"	m	struct:wini	file:
open_ct	esdi_wini.c	/^  unsigned open_ct;			\/* in-use count			 *\/$/;"	m	struct:wini	file:
open_mode	aha_scsi.c	/^	    char open_mode;	\/* open for reading or writing? *\/$/;"	m	struct:scsi::__anon12::__anon13	file:
open_mode	aha_scsi.c	352;"	d	file:
opending	printer.c	/^PRIVATE int opending;		\/* nonzero while expected printing not done *\/$/;"	v
opendir	_getcwd.c	9;"	d	file:
opendir	_opendir.c	/^DIR *opendir(const char *name)$/;"	f
opendir	_opendir.c	10;"	d	file:
operation	asynchio.c	/^static ssize_t operation(int op, asynchio_t *asyn, int fd, int req,$/;"	f	file:
optarg	getopt.c	/^char    *optarg;$/;"	v
opterr	getopt.c	/^int     opterr = 1;$/;"	v
optind	getopt.c	/^int     optind = 1;$/;"	v
optopt	getopt.c	/^int	optopt;$/;"	v
optr	mtab.c	/^static char *optr = mtab_out;	  \/* pointer to place where next line goes *\/$/;"	v	file:
optr	printer.c	/^PRIVATE char *optr;		\/* ptr to next char in obuf to print *\/$/;"	v
order	extboot.s	/^order:	mov	si, di$/;"	l
order	masterboot.s	/^order:	mov	si, di$/;"	l
orig_count	printer.c	/^PRIVATE int orig_count;		\/* original byte count *\/$/;"	v
osdep_eth_port	osdep_eth.h	/^typedef struct osdep_eth_port$/;"	s
osdep_eth_port_t	osdep_eth.h	/^} osdep_eth_port_t;$/;"	t	typeref:struct:osdep_eth_port
ostate	rs232.c	/^  unsigned char ostate;		\/* combination of flags: *\/$/;"	m	struct:rs232	file:
otail	pty.c	/^  char		*ohead, *otail;	\/* head and tail of the circular buffer *\/$/;"	m	struct:pty	file:
otail	rs232.c	/^  char *otail;			\/* next char to output *\/$/;"	m	struct:rs232	file:
out_char	console.c	/^PRIVATE void out_char(cons, c)$/;"	f
out_int	rs232.c	/^PRIVATE void out_int(rs)$/;"	f
out_process	tty.c	/^PUBLIC void out_process(tp, bstart, bpos, bend, icount, ocount)$/;"	f
outb	boothead.s	/^	outb	dx		! Kill the motors$/;"	d
outb	iolib.s	/^	outb	dx			! output 1 byte$/;"	d
outb	iolib.s	/^	outb	dx			! output many bytes$/;"	d
outb	klib386.s	/^	outb	dx			! output 1 byte$/;"	d
outb_ne	ne2000.h	20;"	d
outb_reg0	dp8390.h	165;"	d
outb_reg1	dp8390.h	167;"	d
outb_we	wdeth.h	88;"	d
outc	cursesio.c	/^void outc(c)$/;"	f
outw_ne	ne2000.h	22;"	d
over	extboot.s	/^over:$/;"	l
over	masterboot.s	/^over:$/;"	l
over_call_unhold	mpx386.s	/^over_call_unhold:$/;"	l
over_call_unhold	mpx88.s	/^over_call_unhold:$/;"	l
over_flags	mpx386.s	/^over_flags:$/;"	l
over_kernel_ds	mpx88.s	/^over_kernel_ds:$/;"	l
overlay	overlay.c	/^void overlay(win1, win2)$/;"	f
override	masterboot.s	/^override:$/;"	l
overrun_errors	rs232.c	/^  unsigned overrun_errors;$/;"	m	struct:rs232	file:
overwrite	overlay.c	/^void overwrite(win1, win2)$/;"	f
owner	param.h	28;"	d
oxoff	rs232.c	/^  unsigned char oxoff;		\/* char to stop output *\/$/;"	m	struct:rs232	file:
p1_exception	mpx88.s	/^p1_exception:			! Common for all exceptions.$/;"	l
p1_restart	mpx88.s	/^p1_restart:$/;"	l
p2r286	klib88.s	/^p2r286:$/;"	l
p2r386	klib88.s	/^p2r386:$/;"	l
p_alarm	proc.h	/^  clock_t p_alarm;		\/* time of next alarm in ticks, or 0 *\/$/;"	m	struct:proc
p_bios13	klib88.s	/^p_bios13:$/;"	l
p_callerq	proc.h	/^  struct proc *p_callerq;	\/* head of list of procs wishing to send *\/$/;"	m	struct:proc	typeref:struct:proc::proc
p_cp_mess	klib88.s	/^p_cp_mess:$/;"	l
p_crp	proc.h	/^  char *p_crp;			\/* mmu table pointer (really struct _rpr *) *\/$/;"	m	struct:proc
p_cs_desc	boothead.s	/^p_cs_desc:$/;"	l
p_dmp	dmp.c	/^PUBLIC void p_dmp()$/;"	f
p_dpl_type	protect.c	/^  u8_t p_dpl_type;		\/* |P|DL|0|TYPE| *\/$/;"	m	struct:gatedesc_s	file:
p_ds_desc	boothead.s	/^p_ds_desc:$/;"	l
p_es_desc	boothead.s	/^p_es_desc:$/;"	l
p_exception	mpx88.s	/^p_exception:$/;"	l
p_flags	proc.h	/^  int p_flags;			\/* P_SLOT_FREE, SENDING, RECEIVING, etc. *\/$/;"	m	struct:proc
p_fsave	proc.h	/^  struct fsave p_fsave;		\/* FPP state frame and registers *\/$/;"	m	struct:proc	typeref:struct:proc::fsave
p_gdt	boothead.s	/^p_gdt:$/;"	l
p_gdt_desc	boothead.s	/^p_gdt_desc:$/;"	l
p_getfrom	proc.h	/^  int p_getfrom;		\/* from whom does process want to receive? *\/$/;"	m	struct:proc
p_idt_desc	boothead.s	/^p_idt_desc:$/;"	l
p_int_blocked	proc.h	/^  int p_int_blocked;		\/* nonzero if int msg blocked by busy task *\/$/;"	m	struct:proc
p_int_held	proc.h	/^  int p_int_held;		\/* nonzero if int msg held by busy syscall *\/$/;"	m	struct:proc
p_ldt	proc.h	/^  struct segdesc_s p_ldt[2];	\/* local descriptors for code and data *\/$/;"	m	struct:proc	typeref:struct:proc::segdesc_s
p_ldt_sel	proc.h	/^  reg_t p_ldt_sel;		\/* selector in gdt giving ldt base and limit*\/$/;"	m	struct:proc
p_level0	klib88.s	/^p_level0:$/;"	l
p_map	proc.h	/^  struct mem_map p_map[NR_SEGS];\/* memory map *\/$/;"	m	struct:proc	typeref:struct:proc::mem_map
p_mcs_desc	boothead.s	/^p_mcs_desc:$/;"	l
p_messbuf	proc.h	/^  message *p_messbuf;		\/* pointer to message buffer *\/$/;"	m	struct:proc
p_name	proc.h	/^  char p_name[16];		\/* name of the process *\/$/;"	m	struct:proc
p_nextheld	proc.h	/^  struct proc *p_nextheld;	\/* next in chain of held-up int processes *\/$/;"	m	struct:proc	typeref:struct:proc::proc
p_nextready	proc.h	/^  struct proc *p_nextready;	\/* pointer to next ready process *\/$/;"	m	struct:proc	typeref:struct:proc::proc
p_nflips	proc.h	/^  int p_nflips;			\/* statistics *\/$/;"	m	struct:proc
p_nr	proc.h	/^  int p_nr;			\/* number of this process (for fast access) *\/$/;"	m	struct:proc
p_null_desc	boothead.s	/^p_null_desc:$/;"	l
p_over_call_unhold	mpx88.s	/^p_over_call_unhold:$/;"	l
p_pendcount	proc.h	/^  unsigned p_pendcount;		\/* count of pending and unfinished signals *\/$/;"	m	struct:proc
p_pending	proc.h	/^  sigset_t p_pending;		\/* bit map for pending signals *\/$/;"	m	struct:proc
p_phys_copy	klib88.s	/^p_phys_copy:$/;"	l
p_physio	proc.h	/^  char p_physio;		\/* cannot be (un)shadowed now if set *\/$/;"	m	struct:proc
p_pid	proc.h	/^  pid_t p_pid;			\/* process id passed in from MM *\/$/;"	m	struct:proc
p_portio_setup	klib88.s	/^p_portio_setup:$/;"	l
p_reg	proc.h	/^  struct stackframe_s p_reg;	\/* process' registers saved in stack frame *\/$/;"	m	struct:proc	typeref:struct:proc::stackframe_s
p_reset	klib88.s	/^p_reset:$/;"	l
p_restart	mpx88.s	/^p_restart:$/;"	l
p_rs_addr	rs232.c	/^PRIVATE rs232_t *p_rs_addr[NR_RS_LINES];$/;"	v
p_save	mpx88.s	/^p_save:$/;"	l
p_sendlink	proc.h	/^  struct proc *p_sendlink;	\/* link to next proc wishing to send *\/$/;"	m	struct:proc	typeref:struct:proc::proc
p_sendto	proc.h	/^  int p_sendto;$/;"	m	struct:proc
p_shadow	proc.h	/^  phys_clicks p_shadow;		\/* set if shadowed process image *\/$/;"	m	struct:proc
p_splow	proc.h	/^  reg_t p_splow;		\/* lowest observed stack value *\/$/;"	m	struct:proc
p_ss_desc	boothead.s	/^p_ss_desc:$/;"	l
p_stguard	proc.h	/^  reg_t *p_stguard;		\/* stack guard word *\/$/;"	m	struct:proc
p_trap	proc.h	/^  int p_trap;			\/* trap type (only low byte) *\/$/;"	m	struct:proc
pack_oneCsum	udp.c	/^PRIVATE u16_t pack_oneCsum(pack)$/;"	f
packet2user	eth.c	/^PRIVATE int packet2user (eth_fd)$/;"	f
pad	protect.c	/^  u8_t pad;			\/* |000|XXXXX| ig & trpg, |XXXXXXXX| task g *\/$/;"	m	struct:gatedesc_s	file:
pad	rs232.c	/^  unsigned char pad;		\/* ensure alignment for 16-bit ints *\/$/;"	m	struct:rs232	file:
padimage	installboot.c	/^void padimage(char *image, FILE *imagef, int n)$/;"	f
panic	utility.c	/^PUBLIC void panic(format, num)$/;"	f
panicking	utility.c	/^PRIVATE int panicking;		\/* inhibits recursive panics during sync *\/$/;"	v
parameters	bootblock.s	/^parameters:$/;"	l
params2params	bootimage.c	/^char *params2params(size_t *size)$/;"	f
parcum	test2.c	/^int is, array[4], parsigs, parcum, sigct, cumsig, errct, subtest;$/;"	v
parent	param.h	29;"	d
parent	test1.c	/^void parent()$/;"	f
parent	test5.c	/^void parent(childpid)$/;"	f
parent1	test1.c	/^void parent1(childpid)$/;"	f
parity_errors	rs232.c	/^  unsigned parity_errors;$/;"	m	struct:rs232	file:
parseDate	misc.c	/^parseDate(register char *buf, register const char *p, struct dsttype *dstinfo)$/;"	f	file:
parseRule	misc.c	/^parseRule(register char *buf, register const char *p)$/;"	f	file:
parseTZ	misc.c	/^parseTZ(const char *p)$/;"	f	file:
parseTime	misc.c	/^parseTime(register long *tm, const char *p, register struct dsttype *dst)$/;"	f	file:
parseZoneName	misc.c	/^parseZoneName(register char *buf, register const char *p)$/;"	f	file:
parse_escape	console.c	/^PRIVATE void parse_escape(cons, c)$/;"	f
parsigs	test2.c	/^int is, array[4], parsigs, parcum, sigct, cumsig, errct, subtest;$/;"	v
parsigs	test5.c	/^_VOLATILE int childsigs, parsigs, alarms;$/;"	v
part	aha_scsi.c	/^	    struct device part[DEV_PER_DRIVE];    \/* primaries: sd[0-4] *\/$/;"	m	struct:scsi::__anon12::__anon14	typeref:struct:scsi::__anon12::__anon14::device	file:
part	aha_scsi.c	358;"	d	file:
part	at_wini.c	/^  struct device part[DEV_PER_DRIVE];    \/* primary partitions: hd[0-4] *\/$/;"	m	struct:wini	typeref:struct:wini::device	file:
part	bios_wini.c	/^  struct device part[DEV_PER_DRIVE];    \/* primary partitions: hd[0-4] *\/$/;"	m	struct:wini	typeref:struct:wini::device	file:
part	esdi_wini.c	/^  struct device part[DEV_PER_DRIVE];	\/* primary partitions: hd[0-4]   *\/$/;"	m	struct:wini	typeref:struct:wini::device	file:
partition	drvlib.c	/^PUBLIC void partition(dp, device, style)$/;"	f
passes	test16.c	/^int errct, subtest, passes;$/;"	v
passes	test19.c	/^int errct, subtest, passes, pipesigs;$/;"	v
passwd_file	test11.c	/^char *passwd_file = "\/etc\/passwd";$/;"	v
pat0	ne2000.c	/^u8_t	pat0[]= { 0x00, 0x00, 0x00, 0x00 };$/;"	v
pat1	ne2000.c	/^u8_t	pat1[]= { 0xFF, 0xFF, 0xFF, 0xFF };$/;"	v
pat2	ne2000.c	/^u8_t	pat2[]= { 0xA5, 0x5A, 0x69, 0x96 };$/;"	v
pat3	ne2000.c	/^u8_t	pat3[]= { 0x96, 0x69, 0x5A, 0xA5 };$/;"	v
patch_ptr	exec.c	/^PRIVATE void patch_ptr(stack, base)$/;"	f
patch_sizes	bootimage.c	/^void patch_sizes(void)$/;"	f
patch_table	klib88.s	/^patch_table:			! pairs (old function, new function)$/;"	l
path	ttyname.c	/^PRIVATE char path[sizeof(base) + 1 + NAME_MAX];	\/* extra 1 for '\/' *\/$/;"	v
pathconf	_pathconf.c	/^PUBLIC long pathconf(path, name)$/;"	f
pathconf	_pathconf.c	6;"	d	file:
pathname	param.h	30;"	d
pause	_pause.c	/^PUBLIC int pause()$/;"	f
pause	_pause.c	2;"	d	file:
pc	type.h	/^  reg_t pc;			\/*  ^  last item pushed by interrupt *\/$/;"	m	struct:stackframe_s
pc	type.h	/^  reg_t pc;$/;"	m	struct:stackframe_s
pc_at	glo.h	/^EXTERN int pc_at;		\/* PC-AT compatible hardware interface *\/$/;"	v
pc_bigcount	klib88.s	/^pc_bigcount:$/;"	l
pc_even	klib88.s	/^pc_even:$/;"	l
pc_loop	klib88.s	/^pc_loop:$/;"	l
pc_more	klib88.s	/^pc_more:$/;"	l
pc_small	klib386.s	/^pc_small:$/;"	l
pc_upcount	klib88.s	/^pc_upcount:$/;"	l
pclose	popen.c	/^pclose(stream)$/;"	f
pcylinders	at_wini.c	/^  unsigned pcylinders;		\/* physical number of cylinders (translated) *\/$/;"	m	struct:wini	file:
peek	peekpoke.c	/^int peek(segment, offset)$/;"	f
pending_ticks	clock.c	/^PRIVATE clock_t pending_ticks;	\/* ticks seen by low level only *\/$/;"	v
perror	perror.c	/^perror(const char *s)$/;"	f
perror	testit.c	/^perror(s)$/;"	f
pheads	at_wini.c	/^  unsigned pheads;		\/* physical number of heads *\/$/;"	m	struct:wini	file:
phys	at_wini.c	/^  phys_bytes phys;		\/* user physical address *\/$/;"	m	struct:trans	file:
phys	bios_wini.c	/^  phys_bytes phys;		\/* user physical address *\/$/;"	m	struct:trans	file:
phys	esdi_wini.c	/^  phys_bytes phys;		\/* user physical address                 *\/$/;"	m	struct:trans	file:
physb_to_hclick	const.h	32;"	d
pick_proc	proc.c	/^PRIVATE void pick_proc()$/;"	f
pid	init.c	/^  pid_t pid;			\/* pid of login process for this tty line *\/$/;"	m	struct:slotent	file:
pid	param.h	31;"	d
pid0	test4.c	/^pid_t pid0, pid1, pid2, pid3;$/;"	v
pid1	test4.c	/^pid_t pid0, pid1, pid2, pid3;$/;"	v
pid2	test4.c	/^pid_t pid0, pid1, pid2, pid3;$/;"	v
pid3	test4.c	/^pid_t pid0, pid1, pid2, pid3;$/;"	v
pids	popen.c	/^static int pids[OPEN_MAX];$/;"	v	file:
pipe	_pipe.c	/^PUBLIC int pipe(fild)$/;"	f
pipe	_pipe.c	2;"	d	file:
pipe	crypt.c	7;"	d	file:
pipe_check	pipe.c	/^PUBLIC int pipe_check(rip, rw_flag, oflags, bytes, position, canwrite)$/;"	f
pipe_open	open.c	/^PRIVATE int pipe_open(rip, bits, oflags)$/;"	f
pipecatcher	test19.c	/^void pipecatcher(s)$/;"	f
pipesigs	test19.c	/^int errct, subtest, passes, pipesigs;$/;"	v
pktbuf	ether.h	/^    char *pktbuf;$/;"	m	struct:etherpacket
pktlen	ether.h	/^    unsigned short pktlen;		\/* length of pktbuf ONLY *\/$/;"	m	struct:etherpacket
plenty	boothead.s	/^plenty:	pop	ax		! Return old break (0 for brk)$/;"	l
poke	peekpoke.c	/^int poke(segment, offset, value)$/;"	f
pop	adi.s	/^	pop     dx$/;"	d
pop	bcopy.s	/^	pop	dx		! Pop return address and arguments$/;"	d
pop	boothead.s	/^	pop	di$/;"	d
pop	boothead.s	/^	pop	ds		! Restore ds$/;"	d
pop	boothead.s	/^	pop	ds$/;"	d
pop	cii.s	/^	pop     dx$/;"	d
pop	cmi4.s	/^	pop     dx$/;"	d
pop	cms.s	/^	pop	di$/;"	d
pop	cmu4.s	/^	pop     dx$/;"	d
pop	cuu.s	/^	pop     dx$/;"	d
pop	dvi4.s	/^	pop	di$/;"	d
pop	dvi4.s	/^	pop     di              ! di=sign of result,ax= result$/;"	d
pop	dvu4.s	/^	pop	di$/;"	d
pop	error.s	/^	pop  di$/;"	d
pop	error.s	/^	pop  dx$/;"	d
pop	exg.s	/^	pop	di$/;"	d
pop	extboot.s	/^	pop	di$/;"	d
pop	extboot.s	/^	pop	dx		! Restore drive code in dl$/;"	d
pop	getprocessor.s	/^	pop	dx		! Get it again$/;"	d
pop	getprocessor.s	/^	pop	dx		! dx:ax = eflags$/;"	d
pop	iaar.s	/^	pop     dx$/;"	d
pop	ilar.s	/^	pop     dx$/;"	d
pop	klib386.s	/^	pop	ds$/;"	d
pop	klib88.s	/^	pop	di		! restore C registers$/;"	d
pop	klib88.s	/^	pop	di		! restore di$/;"	d
pop	klib88.s	/^	pop	di$/;"	d
pop	klib88.s	/^	pop	ds		! restore ds$/;"	d
pop	klib88.s	/^	pop	ds		! segment$/;"	d
pop	klib88.s	/^	pop	ds		! update the descriptors$/;"	d
pop	klib88.s	/^	pop	ds$/;"	d
pop	klib88.s	/^	pop	dx		! port$/;"	d
pop	klib88.s	/^	pop	dx		! return adr$/;"	d
pop	klib88.s	/^	pop	dx$/;"	d
pop	klib88.s	/^	pop di			! restore di$/;"	d
pop	klib88.s	/^	pop ds			! restore ds$/;"	d
pop	lar2.s	/^	pop	dx		! base address$/;"	d
pop	lar2.s	/^	pop	dx		! saved si$/;"	d
pop	masterboot.s	/^	pop	di$/;"	d
pop	masterboot.s	/^	pop	dx		! Restore drive code in dl$/;"	d
pop	mli4.s	/^	pop	dx$/;"	d
pop	mpx88.s	/^	pop	di$/;"	d
pop	mpx88.s	/^	pop	ds$/;"	d
pop	mpx88.s	/^	pop	dx$/;"	d
pop	return.s	/^	pop	di$/;"	d
pop	rmi4.s	/^	pop	di$/;"	d
pop	rmu4.s	/^	pop	di$/;"	d
pop	sar2.s	/^	pop	dx		! base address$/;"	d
pop	sar2.s	/^	pop	dx$/;"	d
pop	sbi.s	/^	pop     dx$/;"	d
pop	set.s	/^	pop	di$/;"	d
pop	trp.s	/^pop     ax$/;"	l
pop	trp.s	/^pop bp$/;"	l
popen	popen.c	/^popen(command, type)$/;"	f
poptoken	boot.c	/^char *poptoken(void)$/;"	f
poptoken	edparams.c	/^char *poptoken(void)$/;"	f
port	console.c	/^	unsigned char port;$/;"	m	struct:sequence	file:
port_base	printer.c	/^PRIVATE int port_base;		\/* I\/O port for printer *\/$/;"	v
port_t	type.h	/^typedef unsigned port_t;$/;"	t
portio_setup	klib88.s	/^portio_setup:$/;"	l
pos	aha_scsi.c	/^  unsigned long pos;		\/* first byte on the device to transfer *\/$/;"	m	struct:request	file:
poscur	cursesio.c	/^void poscur(r, c)$/;"	f
pow	pow.c	/^pow(double x, double y)$/;"	f
ppc_large	klib88.s	/^ppc_large:$/;"	l
ppc_next	klib88.s	/^ppc_next:$/;"	l
pproc_addr	proc.h	/^EXTERN struct proc *pproc_addr[NR_TASKS + NR_PROCS];$/;"	v	typeref:struct:proc
pr_handler	printer.c	/^PRIVATE int pr_handler(irq)$/;"	f
pr_restart	printer.c	/^PUBLIC void pr_restart()$/;"	f
pr_start	printer.c	/^PRIVATE void pr_start()$/;"	f
prdone	extboot.s	/^prdone:	ret$/;"	l
prdone	masterboot.s	/^prdone:	ret$/;"	l
precomp	at_wini.c	/^  u8_t	precomp;	\/* REG_PRECOMP, etc. *\/$/;"	m	struct:command	file:
precomp	at_wini.c	/^  unsigned precomp;		\/* write precompensation cylinder \/ 4 *\/$/;"	m	struct:wini	file:
pretty_image	bootimage.c	/^void pretty_image(char *image)$/;"	f
prev_count	type.h	/^  unsigned prev_count;		\/* previous clock value *\/$/;"	m	struct:milli_state
prev_hist	editline.c	/^prev_hist()$/;"	f
prev_ptr	clock.c	/^PRIVATE struct proc *prev_ptr;	\/* last user process run by clock task *\/$/;"	v	typeref:struct:proc
primary	boot.c	/^	int device, primary, secondary;$/;"	m	struct:biosdev	file:
print	bootblock.s	/^print:	lodsb			! al = *si++ is char to be printed$/;"	l
print	extboot.s	/^print:	pop	si			! return address$/;"	l
print	masterboot.s	/^print:	pop	si			! return address$/;"	l
printW	dp8390.c	61;"	d	file:
print_arp_cache	arp.c	/^PRIVATE void print_arp_cache()$/;"	f
print_buf	putk.c	/^PRIVATE char print_buf[BUF_SIZE];	\/* output is buffered here *\/$/;"	v
print_init	printer.c	/^PRIVATE void print_init()$/;"	f
printc	em_print.s	/^printc:$/;"	l
printd	em_print.s	/^printd:$/;"	l
printer_task	printer.c	/^PUBLIC void printer_task()$/;"	f
printf	boot.c	41;"	d	file:
printf	bootimage.c	26;"	d	file:
printf	const.h	144;"	d
printf	printf.c	/^printf(const char *format, ...)$/;"	f
printf	ps.c	76;"	d	file:
printf	ps.c	81;"	d	file:
printk	printk.c	/^void printk(fmt) char *fmt;$/;"	f
prints	em_print.s	/^prints:$/;"	l
printscanbuf	prntscan.c	/^static char printscanbuf[513];	\/* buffer used during I\/O *\/$/;"	v	file:
printw	prntscan.c	/^int printw(const char *fmt, ...)$/;"	f
prnext	extboot.s	/^prnext:	lodsb				! al = *si++ is char to be printed$/;"	l
prnext	masterboot.s	/^prnext:	lodsb				! al = *si++ is char to be printed$/;"	l
pro	param.h	32;"	d
proc	proc.h	/^EXTERN struct proc proc[NR_TASKS + NR_PROCS];	\/* process table *\/$/;"	v	typeref:struct:proc
proc	proc.h	/^struct proc {$/;"	s
proc_addr	proc.h	97;"	d
proc_name	dmp.c	/^PRIVATE char *proc_name(proc_nr)$/;"	f
proc_nr	printer.c	/^PRIVATE int proc_nr;		\/* user requesting the printing *\/$/;"	v
proc_number	proc.h	99;"	d
proc_ptr	glo.h	/^EXTERN struct proc *proc_ptr;	\/* pointer to currently running process *\/$/;"	v	typeref:struct:proc
proc_size	bootimage.c	/^u32_t proc_size(struct image_header *hdr)$/;"	f
proc_vir2phys	proc.h	100;"	d
process	bootimage.c	/^struct process {$/;"	s	file:
process	bootimage.c	/^} process[PROCESS_MAX];$/;"	v	typeref:struct:process
process	image.h	/^	struct exec	process;$/;"	m	struct:image_header	typeref:struct:image_header::exec
process_advanced_data	tcp_recv.c	/^PRIVATE void process_advanced_data(tcp_conn, tcp_hdr, tcp_hdr_len,$/;"	f
process_arp_req	arp.c	/^PRIVATE void process_arp_req (port, data)$/;"	f
process_data	icmp.c	/^PRIVATE void process_data(icmp_port, data)$/;"	f
process_data	tcp_recv.c	/^PRIVATE void process_data(tcp_conn, tcp_hdr, tcp_hdr_len, tcp_data,$/;"	f
process_inc_fragm	tcp.c	/^PRIVATE void process_inc_fragm(tcp_port, data)$/;"	f
process_inc_fragm	udp.c	/^PRIVATE void process_inc_fragm(udp_port, pack)$/;"	f
process_req_q	sr.c	/^PRIVATE void process_req_q(mq, tail, tail_ptr)$/;"	f
processor	glo.h	/^EXTERN unsigned int processor;	\/* 86, 186, 286, 386, ... *\/$/;"	v
product	aha_scsi.c	/^    char product[16];		\/* Product name *\/$/;"	m	struct:__anon9	file:
prog	test10.c	/^long prog[300];$/;"	v
prot2real	boothead.s	/^prot2real:$/;"	l
prot2real	klib88.s	/^prot2real:$/;"	l
prot_init	protect.c	/^PUBLIC void prot_init()$/;"	f
protected_mode	glo.h	/^EXTERN int protected_mode;	\/* nonzero if running in Intel protected mode*\/$/;"	v
protected_mode	glo.h	45;"	d
proto	getprotoent.c	/^static struct protoent proto;$/;"	v	typeref:struct:protoent	file:
proto_aliases	getprotoent.c	/^static char *proto_aliases[MAXALIASES];$/;"	v	file:
protof	getprotoent.c	/^static FILE *protof = NULL;$/;"	v	file:
provided_option	test36.c	/^int provided_option(option, minimum)$/;"	f
prrecv	ps.c	/^char *prrecv(bufp)$/;"	f
ps_args	ps.c	/^  char *ps_args;		\/* concatenated argument string *\/$/;"	m	struct:pstat	file:
ps_data	ps.c	/^  phys_bytes ps_data;		\/* physical data offset *\/$/;"	m	struct:pstat	file:
ps_dev	ps.c	/^  dev_t ps_dev;			\/* major\/minor of controlling tty *\/$/;"	m	struct:pstat	file:
ps_dsize	ps.c	/^  vir_bytes ps_dsize;		\/* data size (in bytes) *\/$/;"	m	struct:pstat	file:
ps_euid	ps.c	/^  uid_t ps_euid;		\/* effective uid *\/$/;"	m	struct:pstat	file:
ps_flags	ps.c	/^  int ps_flags;			\/* kernel flags *\/$/;"	m	struct:pstat	file:
ps_fproc	ps.c	/^struct fproc *ps_fproc;$/;"	v	typeref:struct:fproc
ps_ftask	ps.c	/^  int ps_ftask;			\/* (possibly pseudo) fs suspend task *\/$/;"	m	struct:pstat	file:
ps_mca	glo.h	/^EXTERN int ps_mca;		\/* PS\/2 with Micro Channel *\/$/;"	v
ps_mflags	ps.c	/^  int ps_mflags;		\/* mm flags *\/$/;"	m	struct:pstat	file:
ps_mproc	ps.c	/^struct mproc *ps_mproc;$/;"	v	typeref:struct:mproc
ps_pgrp	ps.c	/^  int ps_pgrp;			\/* process group id *\/$/;"	m	struct:pstat	file:
ps_pid	ps.c	/^  pid_t ps_pid;			\/* process id *\/$/;"	m	struct:pstat	file:
ps_ppid	ps.c	/^  pid_t ps_ppid;		\/* parent process id *\/$/;"	m	struct:pstat	file:
ps_proc	ps.c	/^struct proc *ps_proc;$/;"	v	typeref:struct:proc
ps_procargs	ps.c	/^  vir_bytes ps_procargs;	\/* initial stack frame from MM *\/$/;"	m	struct:pstat	file:
ps_recv	ps.c	/^  int ps_recv;			\/* process number to receive from *\/$/;"	m	struct:pstat	file:
ps_ruid	ps.c	/^  uid_t ps_ruid;		\/* real uid *\/$/;"	m	struct:pstat	file:
ps_ssize	ps.c	/^  vir_bytes ps_ssize;		\/* stack size (in bytes) *\/$/;"	m	struct:pstat	file:
ps_stack	ps.c	/^  phys_bytes ps_stack;		\/* physical stack offset *\/$/;"	m	struct:pstat	file:
ps_state	ps.c	/^  char ps_state;		\/* process state *\/$/;"	m	struct:pstat	file:
ps_stime	ps.c	/^  time_t ps_stime;		\/* accumulated system time *\/$/;"	m	struct:pstat	file:
ps_text	ps.c	/^  phys_bytes ps_text;		\/* physical text offset *\/$/;"	m	struct:pstat	file:
ps_tsize	ps.c	/^  vir_bytes ps_tsize;		\/* text size (in bytes) *\/$/;"	m	struct:pstat	file:
ps_utime	ps.c	/^  time_t ps_utime;		\/* accumulated user time *\/$/;"	m	struct:pstat	file:
ps_vdata	ps.c	/^  phys_bytes ps_vdata;		\/* virtual data offset *\/$/;"	m	struct:pstat	file:
ps_vstack	ps.c	/^  phys_bytes ps_vstack;		\/* virtual stack offset *\/$/;"	m	struct:pstat	file:
ps_vtext	ps.c	/^  phys_bytes ps_vtext;		\/* virtual text offset *\/$/;"	m	struct:pstat	file:
psectors	at_wini.c	/^  unsigned psectors;		\/* physical number of sectors per track *\/$/;"	m	struct:wini	file:
psize	test10.c	/^int psize;$/;"	v
pstat	ps.c	/^int pstat(p_nr, bufp)$/;"	f
pstat	ps.c	/^struct pstat {			\/* structure filled by pstat() *\/$/;"	s	file:
psw	type.h	/^  reg_t psw;                    \/*  | *\/$/;"	m	struct:stackframe_s
psw	type.h	/^  u16_t psw;$/;"	m	struct:stackframe_s
ptr2acc_data	buf.h	146;"	d
ptrace	_ptrace.c	/^PUBLIC long ptrace(req, pid, addr, data)$/;"	f
ptrace	_ptrace.c	2;"	d	file:
ptrint	malloc.c	18;"	d	file:
ptrint	malloc.c	20;"	d	file:
pty	pty.c	/^typedef struct pty {$/;"	s	file:
pty_close	pty.c	/^PRIVATE void pty_close(tp)$/;"	f
pty_echo	pty.c	/^PRIVATE void pty_echo(tp, c)$/;"	f
pty_finish	pty.c	/^PRIVATE void pty_finish(pp)$/;"	f
pty_icancel	pty.c	/^PRIVATE void pty_icancel(tp)$/;"	f
pty_init	pty.c	/^PUBLIC void pty_init(tp)$/;"	f
pty_init	tty.c	87;"	d	file:
pty_ocancel	pty.c	/^PRIVATE void pty_ocancel(tp)$/;"	f
pty_read	pty.c	/^PRIVATE void pty_read(tp)$/;"	f
pty_start	pty.c	/^PRIVATE void pty_start(pp)$/;"	f
pty_t	pty.c	/^} pty_t;$/;"	t	typeref:struct:pty	file:
pty_table	pty.c	/^PRIVATE pty_t pty_table[NR_PTYS];	\/* PTY bookkeeping *\/$/;"	v
pty_write	pty.c	/^PRIVATE void pty_write(tp)$/;"	f
push	adi.s	/^	push    dx$/;"	d
push	bcopy.s	/^	push	dx		! Arguments reversed$/;"	d
push	bootblock.s	/^	push	dx		! Boot device in dl will be device(bp)$/;"	d
push	boothead.s	/^	push	di		! Save C variable registers$/;"	d
push	boothead.s	/^	push	di		! Save registers used by BIOS calls$/;"	d
push	boothead.s	/^	push	ds$/;"	d
push	boothead.s	/^	push	dx		! Kernel code segment$/;"	d
push	cii.s	/^	push    dx$/;"	d
push	cms.s	/^	push	di$/;"	d
push	cuu.s	/^	push    dx$/;"	d
push	dvi4.s	/^	push	di$/;"	d
push	dvi4.s	/^	push    dx              ! sign of y$/;"	d
push	dvu4.s	/^	push	di$/;"	d
push	error.s	/^	push di$/;"	d
push	error.s	/^	push dx$/;"	d
push	exg.s	/^	push	di$/;"	d
push	extboot.s	/^	push	di		! Next call destroys es and di$/;"	d
push	getprocessor.s	/^	push	dx$/;"	d
push	klib386.s	/^	push	ds$/;"	d
push	klib88.s	/^	push	di			! save C variable registers$/;"	d
push	klib88.s	/^	push	di		! save C variable registers$/;"	d
push	klib88.s	/^	push	di		! save di$/;"	d
push	klib88.s	/^	push	di$/;"	d
push	klib88.s	/^	push	ds		! save ds$/;"	d
push	klib88.s	/^	push	ds$/;"	d
push	klib88.s	/^	push di			! save di$/;"	d
push	klib88.s	/^	push ds			! save ds$/;"	d
push	masterboot.s	/^	push	di		! Next call destroys es and di$/;"	d
push	mli4.s	/^	push	dx$/;"	d
push	modf.s	/^	push	dx$/;"	d
push	mpx88.s	/^	push	di$/;"	d
push	mpx88.s	/^	push	ds		! save ds$/;"	d
push	mpx88.s	/^	push	ds$/;"	d
push	mpx88.s	/^	push	dx$/;"	d
push	rmi4.s	/^	push	di$/;"	d
push	rmu4.s	/^	push	di$/;"	d
push	sar2.s	/^	push	dx$/;"	d
push	set.s	/^	push	di$/;"	d
push	trp.s	/^push    ax$/;"	l
push	trp.s	/^push ax$/;"	l
push	trp.s	/^push bp$/;"	l
push	trp.s	/^push bx$/;"	l
push	trp.s	/^push dx$/;"	d
push_current_stack	mpx88.s	/^push_current_stack:$/;"	l
put	test17.c	/^void put(nr)$/;"	f
put	test18.c	/^void put(nr)$/;"	f
put2	get_put.h	23;"	d
put2	get_put.h	27;"	d
put4	get_put.h	34;"	d
put4	get_put.h	40;"	d
put_block	cache.c	/^PUBLIC void put_block(bp, block_type)$/;"	f
put_block2	cache2.c	/^PUBLIC void put_block2(bp)$/;"	f
put_eth_data	ip.c	/^PRIVATE int put_eth_data (port, offset, data, for_ioctl)$/;"	f
put_file_in_dir	test17.c	/^void put_file_in_dir(dirname, mode)$/;"	f
put_file_in_dir	test18.c	/^void put_file_in_dir(dirname, mode)$/;"	f
put_inode	inode.c	/^PUBLIC void put_inode(rip)$/;"	f
put_irq_handler	i8259.c	/^PUBLIC void put_irq_handler(irq, handler)$/;"	f
put_mtab_entry	mtab.c	/^int put_mtab_entry(special, mounted_on, version, rw_flag)$/;"	f
put_userdata	dp8390.c	/^static void put_userdata(user_proc, user_addr, count, loc_addr)$/;"	f	file:
putc	boothead.s	/^putc:	movb	ah, #0x0E	! Print character in teletype mode$/;"	l
putc	putc.c	/^(putc)(int c, FILE *stream)$/;"	f
putch_msg	putk.c	/^PRIVATE message putch_msg;	\/* used for message to TTY task *\/$/;"	v
putchar	putchar.c	/^(putchar)(int c)$/;"	f
putenv	putenv.c	/^putenv(name)$/;"	f
putk	console.c	/^PUBLIC void putk(c)$/;"	f
putk	putk.c	/^PUBLIC void putk(c)$/;"	f
putlong	res_comp.c	/^putlong(l, msgp)$/;"	f
putlong	res_comp.c	43;"	d	file:
putlong	res_mkquery.c	43;"	d	file:
puts	puts.c	/^puts(register const char *s)$/;"	f
putshort	res_comp.c	/^putshort(s, msgp)$/;"	f
putshort	res_comp.c	42;"	d	file:
putshort	res_mkquery.c	42;"	d	file:
putw	putw.c	/^putw(w, stream)$/;"	f
pwfd	getpwent.c	/^static int pwfd= -1;			\/* Filedescriptor to the file. *\/$/;"	v	file:
pwfile	getpwent.c	/^static const char *pwfile;		\/* Current password file. *\/$/;"	v	file:
pwline	getpwent.c	/^static char pwline[256];		\/* One line from the password file. *\/$/;"	v	file:
q3exchange	qsort.c	/^q3exchange(register char *p, register char *q, register char *r,$/;"	f	file:
qbuf	itoa.c	/^PRIVATE char qbuf[8];$/;"	v
qcompar	qsort.c	/^static	int (*qcompar)(const char *, const char *);$/;"	v	file:
qexchange	qsort.c	/^qexchange(register char *p, register char *q,$/;"	f	file:
qsort	qsort.c	/^qsort(void *base, size_t nel, size_t width,$/;"	f
qsort1	qsort.c	/^qsort1(char *a1, char *a2, register size_t width)$/;"	f	file:
querybuf	gethnmadr.c	/^typedef union querybuf$/;"	u	file:
querybuf_t	gethnmadr.c	/^} querybuf_t;$/;"	t	typeref:union:querybuf	file:
quit	boothead.s	/^quit:	mov	ax, #any_key$/;"	l
quit	common.c	/^void quit()$/;"	f
quit	test1.c	/^void quit()$/;"	f
quit	test10.c	/^void quit()$/;"	f
quit	test12.c	/^void quit()$/;"	f
quit	test13.c	/^void quit()$/;"	f
quit	test14.c	/^void quit()$/;"	f
quit	test15.c	/^void quit()$/;"	f
quit	test16.c	/^void quit()$/;"	f
quit	test17.c	/^void quit()$/;"	f
quit	test18.c	/^void quit()$/;"	f
quit	test19.c	/^void quit()$/;"	f
quit	test2.c	/^void quit()$/;"	f
quit	test20.c	/^void quit()$/;"	f
quit	test21.c	/^void quit()$/;"	f
quit	test22.c	/^void quit()$/;"	f
quit	test23.c	/^void quit()$/;"	f
quit	test24.c	/^void quit()$/;"	f
quit	test25.c	/^void quit()$/;"	f
quit	test26.c	/^void quit()$/;"	f
quit	test27.c	/^void quit()$/;"	f
quit	test28.c	/^void quit()$/;"	f
quit	test29.c	/^void quit()$/;"	f
quit	test3.c	/^void quit()$/;"	f
quit	test30.c	/^void quit()$/;"	f
quit	test31.c	/^void quit()$/;"	f
quit	test32.c	/^void quit()$/;"	f
quit	test33.c	/^void quit()$/;"	f
quit	test34.c	/^void quit()$/;"	f
quit	test35.c	/^void quit()$/;"	f
quit	test36.c	/^void quit()$/;"	f
quit	test37.c	/^void quit()$/;"	f
quit	test38.c	/^void quit()$/;"	f
quit	test39.c	/^void quit()$/;"	f
quit	test4.c	/^void quit()$/;"	f
quit	test40.c	/^void quit()$/;"	f
quit	test5.c	/^void quit()$/;"	f
quit	test6.c	/^void quit()$/;"	f
quit	test7.c	/^void quit()$/;"	f
quit	test8.c	/^void quit()$/;"	f
quote	editline.c	/^quote()$/;"	f
r	hypot.c	/^	double r,i;$/;"	m	struct:complex	file:
r_big_ten_powers	ext_comp.c	/^static struct EXTEND r_big_ten_powers[] = { \/* representation of 10 ** -(28*i) *\/$/;"	v	typeref:struct:EXTEND	file:
r_lookup	rawfs.c	/^ino_t r_lookup(Ino_t cwd, char *path)$/;"	f
r_readdir	rawfs.c	/^ino_t r_readdir(char *name)$/;"	f
r_stat	rawfs.c	/^void r_stat(Ino_t inum, struct stat *stp)$/;"	f
r_super	rawfs.c	/^off_t r_super(void)$/;"	f
r_ten_powers	ext_comp.c	/^static struct EXTEND r_ten_powers[] = { \/* representation of 10 ** -i *\/$/;"	v	typeref:struct:EXTEND	file:
r_vir2abs	rawfs.c	/^off_t r_vir2abs(off_t virblk)$/;"	f
rahead	read.c	/^PUBLIC struct buf *rahead(rip, baseblock, position, bytes_ahead)$/;"	f
raise	raise.c	/^raise(int sig)$/;"	f
rand	rand.c	/^int rand(void)$/;"	f
rarp46_t	arp.c	/^} arp46_t, rarp46_t;$/;"	t	typeref:struct:arp46	file:
rarp_func	ip.c	/^PRIVATE void rarp_func (port, ipaddr)$/;"	f
rarp_read_setup	arp.c	/^PRIVATE void rarp_read_setup (port)$/;"	f
rarp_req	arp.c	/^PUBLIC int rarp_req(eth_port, ref, func)$/;"	f
rarp_timeout	arp.c	/^PRIVATE void rarp_timeout (fd, timer)$/;"	f
rate	floppy.c	/^PRIVATE char rate[NT] =$/;"	v
raw	setterm.c	/^void raw()$/;"	f
raw_clear	bootimage.c	/^void raw_clear(u32_t addr, u32_t count)$/;"	f
raw_install	installboot.c	/^int raw_install(char *file, off_t *start, off_t *len)$/;"	f
rawdev	installboot.c	/^char *rawdev;	\/* Name of device. *\/$/;"	v
rawecho	tty.c	/^PRIVATE void rawecho(tp, ch)$/;"	f
rawfd	installboot.c	/^int rawfd;	\/* File descriptor to open device. *\/$/;"	v
rawmode	curspriv.h	/^  bool     rawmode;$/;"	m	struct:__anon20
rcmd	rcmd.c	/^int rcmd(ahost, rport, locuser, remuser, cmd, fd2p)$/;"	f
rcmd	rcmd.c	/^rcmd(ahost, rport, locuser, remuser, cmd, fd2p)$/;"	f
rd_indir	read.c	/^PUBLIC zone_t rd_indir(bp, index)$/;"	f
rd_only	param.h	33;"	d
rdcaller	pty.c	/^  char		rdcaller;	\/* process making the call (usually FS) *\/$/;"	m	struct:pty	file:
rdcum	pty.c	/^  int		rdcum;		\/* # bytes written so far *\/$/;"	m	struct:pty	file:
rderr	bootblock.s	/^rderr:	.ascii	"Read error "$/;"	l
rdleft	pty.c	/^  int		rdleft;		\/* # bytes yet to be read *\/$/;"	m	struct:pty	file:
rdproc	pty.c	/^  char		rdproc;		\/* process that wants to read from the pty *\/$/;"	m	struct:pty	file:
rdrepcode	pty.c	/^  char		rdrepcode;	\/* reply code, TASK_REPLY or REVIVE *\/$/;"	m	struct:pty	file:
rdvir	pty.c	/^  vir_bytes	rdvir;		\/* virtual address in readers address space *\/$/;"	m	struct:pty	file:
rdy_head	proc.h	/^EXTERN struct proc *rdy_head[NQ];	\/* pointers to ready list headers *\/$/;"	v	typeref:struct:proc
rdy_tail	proc.h	/^EXTERN struct proc *rdy_tail[NQ];	\/* pointers to ready list tails *\/$/;"	v	typeref:struct:proc
read	_read.c	/^PUBLIC ssize_t read(fd, buffer, nbytes)$/;"	f
read	_read.c	2;"	d	file:
read	_readdir.c	6;"	d	file:
read	_uname.c	10;"	d	file:
read	asynchio.c	11;"	d	file:
read	bootblock.s	/^read:	push	ax		! Save al = sectors to read$/;"	l
read	crypt.c	12;"	d	file:
read	getgrent.c	9;"	d	file:
read	getpass.c	10;"	d	file:
read	getpwent.c	9;"	d	file:
read	getttyent.c	8;"	d	file:
read_ahead	read.c	/^PUBLIC void read_ahead()$/;"	f
read_ecc	xt_wini.c	/^PRIVATE int read_ecc()$/;"	f
read_header	exec.c	/^PRIVATE int read_header(fd, ft, text_bytes, data_bytes, bss_bytes, $/;"	f
read_header	installboot.c	/^void read_header(int talk, char *proc, FILE *procf, struct image_header *ihdr)$/;"	f
read_id	floppy.c	/^PRIVATE int read_id(fp)$/;"	f
read_int	mnx_eth.c	/^PRIVATE void read_int(eth_port, count)$/;"	f
read_ip_packets	tcp.c	/^PRIVATE void read_ip_packets(tcp_port)$/;"	f
read_ip_packets	udp.c	/^PRIVATE void read_ip_packets(udp_port)$/;"	f
read_map	read.c	/^PUBLIC block_t read_map(rip, position)$/;"	f
read_more	test18.c	/^void read_more(filedes, a)$/;"	f
read_standards	test18.c	/^void read_standards(filedes, a)$/;"	f
read_super	super.c	/^PUBLIC int read_super(sp)$/;"	f
read_write	read.c	/^PUBLIC int read_write(rw_flag)$/;"	f
readblock	boot.c	/^void readblock(off_t blk, char *buf)$/;"	f
readblock	installboot.c	/^void readblock(off_t blk, char *buf)$/;"	f
readdir	_getcwd.c	10;"	d	file:
readdir	_readdir.c	/^struct dirent *readdir(DIR *dp)$/;"	f
readdir	_readdir.c	7;"	d	file:
readdir	_seekdir.c	7;"	d	file:
readerr	boot.c	/^void readerr(off_t sec, int err)	{ rwerr("Read", sec, err); }$/;"	f
readerr	extboot.s	/^readerr:	.ascii	"Read error \\0"$/;"	l
readerr	masterboot.s	/^readerr:	.ascii	"Read error \\0"$/;"	l
readline	boot.c	/^char *readline(void)$/;"	f
readline	editline.c	/^readline(prompt)$/;"	f
readline	edparams.c	/^char *readline(void)$/;"	f
ready	proc.c	/^PRIVATE void ready(rp)$/;"	f
real	klib88.s	/^real:$/;"	l
real2prot	boothead.s	/^real2prot:$/;"	l
real2prot	klib88.s	/^real2prot:$/;"	l
real_grp_id	param.h	14;"	d
real_user_id	param.h	34;"	d
realloc	malloc.c	/^realloc(void *oldp, size_t size)$/;"	f
realtime	clock.c	/^PRIVATE clock_t realtime;	\/* real time clock *\/$/;"	v
reassemble	ip_read.c	/^PRIVATE acc_t *reassemble (port, pack, pack_hdr)$/;"	f
reboot	_reboot.c	/^int reboot(int how, ...)$/;"	f
reboot	_reboot.c	7;"	d	file:
reboot	boothead.s	/^reboot:	call	restore_video$/;"	l
reboot_code	boot.h	/^EXTERN u32_t reboot_code; \/* Program returned by a rebooting Minix. *\/$/;"	v
reboot_code	glo.h	/^EXTERN phys_bytes reboot_code;	\/* program for the boot monitor *\/$/;"	v
recalibrate	floppy.c	/^PRIVATE int recalibrate(fp)$/;"	f
recover	_getcwd.c	/^static int recover(char *p)$/;"	f	file:
recv_port	rs232.c	/^  port_t recv_port;$/;"	m	struct:rs232	file:
redisplay	editline.c	/^redisplay()$/;"	f
reg	regexp.c	/^PRIVATE char *reg(paren, flagp)$/;"	f
reg_dmp	dmp.c	/^PUBLIC void reg_dmp(rp)$/;"	f
reg_t	type.h	/^typedef u32_t reg_t;		\/* machine register *\/$/;"	t
reg_t	type.h	/^typedef unsigned reg_t;		\/* machine register *\/$/;"	t
regatom	regexp.c	/^PRIVATE char *regatom(flagp)$/;"	f
regbol	regexp.c	/^PRIVATE char *regbol;		\/* Beginning of input, for ^ check. *\/$/;"	v
regbranch	regexp.c	/^PRIVATE char *regbranch(flagp)$/;"	f
regc	regexp.c	/^PRIVATE void regc(b)$/;"	f
regcode	regexp.c	/^PRIVATE char *regcode;		\/* Code-emit pointer; &regdummy = don't. *\/$/;"	v
regcomp	regexp.c	/^regexp *regcomp(exp)$/;"	f
regdummy	regexp.c	/^PRIVATE char regdummy;$/;"	v
regdump	regexp.c	/^void regdump(r)$/;"	f
regendp	regexp.c	/^PRIVATE char **regendp;		\/* Ditto for endp. *\/$/;"	v
regexec	regexp.c	/^int regexec(prog, string, bolflag)$/;"	f
reginput	regexp.c	/^PRIVATE char *reginput;		\/* String-input pointer. *\/$/;"	v
reginsert	regexp.c	/^PRIVATE void reginsert(op, opnd)$/;"	f
regmatch	regexp.c	/^PRIVATE int regmatch(prog)	\/* 0 failure, 1 success *\/ $/;"	f
regnarrate	regexp.c	/^int regnarrate = 0;$/;"	v
regnext	regexp.c	/^PRIVATE char *regnext(p)$/;"	f
regnode	regexp.c	/^PRIVATE char *regnode(op)$/;"	f
regnpar	regexp.c	/^PRIVATE int regnpar;		\/* () count. *\/$/;"	v
regoptail	regexp.c	/^PRIVATE void regoptail(p, val)$/;"	f
regparse	regexp.c	/^PRIVATE char *regparse;		\/* Input-scan pointer. *\/$/;"	v
regpiece	regexp.c	/^PRIVATE char *regpiece(flagp)$/;"	f
regprop	regexp.c	/^PRIVATE char *regprop(op)$/;"	f
regrepeat	regexp.c	/^PRIVATE int regrepeat(p)$/;"	f
regsize	regexp.c	/^PRIVATE long regsize;		\/* Code size. *\/$/;"	v
regstartp	regexp.c	/^PRIVATE char **regstartp;	\/* Pointer to startp array. *\/$/;"	v
regsub	regsub.c	/^void regsub(prog, source, dest)$/;"	f
regtail	regexp.c	/^PRIVATE void regtail(p, val)$/;"	f
regtry	regexp.c	/^PRIVATE int regtry(prog, string)   \/* 0 failure, 1 success *\/$/;"	f
release	pipe.c	/^PUBLIC void release(ip, call_nr, count)$/;"	f
relocate	exec.c	/^PRIVATE int relocate(fd, buf)$/;"	f
rem_part	boot.h	/^EXTERN vector rem_part;		\/* Boot partition table entry. *\/$/;"	v
remote_code	boot.c	/^void remote_code(void)$/;"	f
remove	remove.c	/^remove(const char *filename) {$/;"	f
remove_dir	link.c	/^PRIVATE int remove_dir(rldirp, rip, dir_name)$/;"	f
rename	_rename.c	/^PUBLIC int rename(name, name2)$/;"	f
rename	_rename.c	2;"	d	file:
repl_queue	sr.c	/^PRIVATE mq_t *repl_queue, *repl_queue_tail;$/;"	v
repl_queue_tail	sr.c	/^PRIVATE mq_t *repl_queue, *repl_queue_tail;$/;"	v
reply	dp8390.c	/^static void reply(dep, err, may_block)$/;"	f	file:
reply	main.c	/^PUBLIC void reply(whom, result)$/;"	f
reply	printer.c	/^PRIVATE void reply(code, replyee, process, status)$/;"	f
reply_i1	param.h	48;"	d
reply_i2	param.h	49;"	d
reply_l1	param.h	47;"	d
reply_t1	param.h	50;"	d
reply_t2	param.h	51;"	d
reply_t3	param.h	52;"	d
reply_t4	param.h	53;"	d
reply_t5	param.h	54;"	d
reply_thr_get	eth.c	/^PRIVATE void reply_thr_get (eth_fd, result, for_ioctl)$/;"	f
reply_thr_get	ip_ioctl.c	/^PRIVATE void reply_thr_get(ip_fd, reply, for_ioctl)$/;"	f
reply_thr_get	tcp.c	/^PRIVATE void reply_thr_get(tcp_fd, reply, for_ioctl)$/;"	f
reply_thr_get	udp.c	/^PRIVATE void reply_thr_get(udp_fd, reply, for_ioctl)$/;"	f
reply_thr_put	eth.c	/^PRIVATE void reply_thr_put (eth_fd, result, for_ioctl)$/;"	f
reply_thr_put	tcp.c	/^PRIVATE int reply_thr_put(tcp_fd, reply, for_ioctl)$/;"	f
reply_thr_put	udp.c	/^PRIVATE int reply_thr_put(udp_fd, reply, for_ioctl)$/;"	f
reply_type	param.h	46;"	d
report	edparams.c	/^void report(char *label)$/;"	f
report	init.c	/^void report(fd, label)$/;"	f
report	installboot.c	/^void report(char *label)$/;"	f
reposition	editline.c	/^reposition()$/;"	f
reprint	tty.c	/^PRIVATE void reprint(tp)$/;"	f
request	aha_scsi.c	/^PRIVATE request_t request;$/;"	v
request	aha_scsi.c	/^typedef struct request {$/;"	s	file:
request	param.h	35;"	d
request_t	aha_scsi.c	/^} request_t;$/;"	t	typeref:struct:request	file:
res_init	res_init.c	/^res_init()$/;"	f
res_mkquery	res_mkquery.c	/^res_mkquery(op, dname, class, type, data, datalen, newrr, buf, buflen)$/;"	f
res_query	res_query.c	/^res_query(name, class, type, answer, anslen)$/;"	f
res_querydomain	res_query.c	/^res_querydomain(name, domain, class, type, answer, anslen)$/;"	f
res_search	res_query.c	/^res_search(name, class, type, answer, anslen)$/;"	f
res_send	res_send.c	/^res_send(buf, buflen, answer, anslen)$/;"	f
reserved	aha_scsi.c	/^	byte reserved;$/;"	m	struct:__anon6::__anon7	file:
reserved	aha_scsi.c	/^    byte reserved[2];		\/* reserved, set to 0 *\/$/;"	m	struct:__anon10	file:
reserved	aha_scsi.c	/^    byte reserved[2];$/;"	m	struct:__anon9	file:
reserved	protect.c	/^  u16_t reserved;$/;"	m	struct:gatedesc_s	file:
reserved	type.h	/^	u16_t reserved;$/;"	m	struct:fsave::state_frame
reserved	type.h	/^  u16_t reserved;$/;"	m	struct:segdesc_s
resetterm	termmisc.c	/^int resetterm()$/;"	f
restart1	mpx386.s	/^restart1:$/;"	l
restart1	mpx88.s	/^restart1:$/;"	l
restart_fd_write	ip_write.c	/^PRIVATE void restart_fd_write(ip_fd)$/;"	f
restart_netbroad_fd	ip_write.c	/^PRIVATE void restart_netbroad_fd(ip_fd)$/;"	f
restart_netbroadcast	ip_write.c	/^PRIVATE void restart_netbroadcast()$/;"	f
restart_write_fd	eth.c	/^PRIVATE void restart_write_fd(eth_fd)$/;"	f
restart_write_fd	udp.c	/^PRIVATE void restart_write_fd(udp_fd)$/;"	f
restore_video	boothead.s	/^restore_video:			! To restore the video mode on exit$/;"	l
ret	trp.s	/^ret$/;"	l
ret386	boothead.s	/^ret386:$/;"	l
ret86	boothead.s	/^ret86:$/;"	l
ret_val	popen.c	68;"	d	file:
ret_val	popen.c	70;"	d	file:
retadr	type.h	/^  reg_t retadr;			\/* return address for assembly code save() *\/$/;"	m	struct:stackframe_s
retreg	type.h	/^  reg_t retreg;			\/* ax and above are all pushed by save *\/$/;"	m	struct:stackframe_s
retreg	type.h	/^  reg_t retreg;			\/* d0 *\/$/;"	m	struct:stackframe_s
retry	aha_scsi.c	/^  unsigned retry;		\/* number of tries allowed if retryable *\/$/;"	m	struct:request	file:
retry	extboot.s	/^retry:	push	dx		! Save drive code$/;"	l
retry	masterboot.s	/^retry:	push	dx		! Save drive code$/;"	l
return	boothead.s	/^return:$/;"	l
return	klib386.s	/^return:$/;"	l
revision	aha_scsi.c	/^    char revision[4];		\/* Revision level *\/$/;"	m	struct:__anon9	file:
revive	pipe.c	/^PUBLIC void revive(proc_nr, bytes)$/;"	f
rewind	rewind.c	/^rewind(FILE *stream)$/;"	f
rewinddir	_getcwd.c	11;"	d	file:
rewinddir	_rewinddir.c	/^void rewinddir(DIR *dp)$/;"	f
rewinddir	_rewinddir.c	6;"	d	file:
rewrite_mtab	mtab.c	/^int rewrite_mtab(prog_name)$/;"	f
right	editline.c	/^right(Change)$/;"	f
rindex	rindex.c	/^char *rindex(s, charwanted)	\/* found char, or NULL if none *\/$/;"	f
ring_bell	editline.c	/^ring_bell()$/;"	f
rl_add_slash	sysos9.c	/^rl_add_slash(path, p)$/;"	f
rl_add_slash	sysunix.c	/^rl_add_slash(path, p)$/;"	f
rl_complete	complete.c	/^rl_complete(pathname, unique)$/;"	f
rl_eof	editline.c	/^int		rl_eof;$/;"	v
rl_erase	editline.c	/^int		rl_erase;$/;"	v
rl_initialize	editline.c	/^rl_initialize()$/;"	f
rl_intr	editline.c	/^int		rl_intr;$/;"	v
rl_kill	editline.c	/^int		rl_kill;$/;"	v
rl_list_possib	complete.c	/^rl_list_possib(pathname, avp)$/;"	f
rl_meta_chars	editline.c	/^int		rl_meta_chars = 0;$/;"	v
rl_quit	editline.c	/^int		rl_quit;$/;"	v
rl_reset_terminal	editline.c	/^rl_reset_terminal(p)$/;"	f
rl_ttyset	sysos9.c	/^rl_ttyset(Reset)$/;"	f
rl_ttyset	sysunix.c	/^rl_ttyset(Reset)$/;"	f
rm_lru	cache.c	/^PRIVATE void rm_lru(bp)$/;"	f
rm_rf_dir	common.c	/^void rm_rf_dir(test_nr)$/;"	f
rm_rf_ppdir	common.c	/^void rm_rf_ppdir(test_nr)$/;"	f
rmdir	_rmdir.c	/^PUBLIC int rmdir(name)$/;"	f
rmdir	_rmdir.c	2;"	d	file:
rmfiles	test10.c	/^void rmfiles()$/;"	f
rounded	putenv.c	11;"	d	file:
route	ipr.h	/^typedef struct route$/;"	s
route_t	ipr.h	/^} route_t;$/;"	t	typeref:struct:route
route_table	ipr.c	/^PRIVATE route_t route_table[ROUTE_NR];$/;"	v
rq	aha_scsi.c	400;"	d	file:
rresvport	rcmd.c	/^rresvport(alport)$/;"	f
rs232	rs232.c	/^typedef struct rs232 {$/;"	s	file:
rs232_1handler	rs232.c	/^PRIVATE int rs232_1handler(irq)$/;"	f
rs232_2handler	rs232.c	/^PRIVATE int rs232_2handler(irq)$/;"	f
rs232_t	rs232.c	/^} rs232_t;$/;"	t	typeref:struct:rs232	file:
rs_addr	rs232.c	237;"	d	file:
rs_break	rs232.c	/^PRIVATE void rs_break(tp)$/;"	f
rs_config	rs232.c	/^PRIVATE void rs_config(rs)$/;"	f
rs_echo	rs232.c	/^PRIVATE void rs_echo(tp, c)$/;"	f
rs_icancel	rs232.c	/^PRIVATE void rs_icancel(tp)$/;"	f
rs_init	rs232.c	/^PUBLIC void rs_init(tp)$/;"	f
rs_init	tty.c	84;"	d	file:
rs_ioctl	rs232.c	/^PRIVATE void rs_ioctl(tp)$/;"	f
rs_lines	rs232.c	/^PUBLIC rs232_t rs_lines[NR_RS_LINES];$/;"	v
rs_ocancel	rs232.c	/^PRIVATE void rs_ocancel(tp)$/;"	f
rs_ostart	rs232.c	/^PRIVATE void rs_ostart(rs)$/;"	f
rs_read	rs232.c	/^PRIVATE void rs_read(tp)$/;"	f
rs_write	rs232.c	/^PRIVATE void rs_write(tp)$/;"	f
rt_dest	ipr.h	/^	ipaddr_t rt_dest;$/;"	m	struct:route
rt_dist	ipr.h	/^	int rt_dist;$/;"	m	struct:route
rt_exp_tim	ipr.h	/^	time_t rt_exp_tim;$/;"	m	struct:route
rt_flags	ipr.h	/^	int rt_flags;$/;"	m	struct:route
rt_gateway	ipr.h	/^	ipaddr_t rt_gateway;$/;"	m	struct:route
rt_netmask	ipr.h	/^	ipaddr_t rt_netmask;$/;"	m	struct:route
rt_port	ipr.h	/^	int rt_port;$/;"	m	struct:route
rt_pref	ipr.h	/^	i32_t rt_pref;$/;"	m	struct:route
rt_timestamp	ipr.h	/^	time_t rt_timestamp;$/;"	m	struct:route
runsize	boot.h	/^EXTERN u32_t runsize;		\/* Size of this program. *\/$/;"	v
ruserok	rcmd.c	/^ruserok(rhost, superuser, ruser, luser)$/;"	f
rw_block	cache.c	/^PUBLIC void rw_block(bp, rw_flag)$/;"	f
rw_chunk	read.c	/^PRIVATE int rw_chunk(rip, position, off, chunk, left, rw_flag, buff, seg, usr)$/;"	f
rw_inode	inode.c	/^PUBLIC void rw_inode(rip, rw_flag)$/;"	f
rw_scattered	cache.c	/^PUBLIC void rw_scattered(dev, bufq, bufqsize, rw_flag)$/;"	f
rwerr	boot.c	/^void rwerr(char *rw, off_t sec, int err)$/;"	f
rwsec	boothead.s	/^rwsec:	push	di$/;"	l
s	res_send.c	/^static int s = -1;	\/* socket used for communications *\/$/;"	v	file:
s	test4.c	/^int s, i, fd, nextb, errct = 0;$/;"	v
s2s	tty.c	/^PRIVATE struct s2s {$/;"	s	file:
s_addr	gethnmadr.c	/^	ipaddr_t s_addr;$/;"	m	struct:in_addr	file:
s_buf_blk	aha_scsi.c	/^PRIVATE unsigned long s_buf_blk;\/* disk block currently in tmp_buf *\/$/;"	v
s_dev	super.h	/^  dev_t s_dev;			\/* whose super block is this? *\/$/;"	m	struct:super_block
s_do_close	aha_scsi.c	/^PRIVATE int s_do_close(dp, m_ptr)$/;"	f
s_do_ioctl	aha_scsi.c	/^PRIVATE int s_do_ioctl(dp, m_ptr)$/;"	f
s_do_open	aha_scsi.c	/^PRIVATE int s_do_open(dp, m_ptr)$/;"	f
s_dtab	aha_scsi.c	/^PRIVATE struct driver s_dtab = {$/;"	v	typeref:struct:driver
s_dv	aha_scsi.c	/^PRIVATE struct device *s_dv;	\/* active partition *\/$/;"	v	typeref:struct:device
s_finish	aha_scsi.c	/^PRIVATE int s_finish()$/;"	f
s_firstdatazone	super.h	/^  zone1_t s_firstdatazone;	\/* number of first data zone *\/$/;"	m	struct:super_block
s_geometry	aha_scsi.c	/^PRIVATE void s_geometry(entry)$/;"	f
s_handler	aha_scsi.c	/^PRIVATE int s_handler(irq)$/;"	f
s_imap_blocks	super.h	/^  short s_imap_blocks;		\/* # of blocks used by inode bit map *\/$/;"	m	struct:super_block
s_imount	super.h	/^  struct inode *s_imount;	\/* inode mounted on *\/$/;"	m	struct:super_block	typeref:struct:super_block::inode
s_inodes_per_block	super.h	/^  unsigned s_inodes_per_block;	\/* precalculated from magic number *\/$/;"	m	struct:super_block
s_isearch	super.h	/^  bit_t s_isearch;		\/* inodes below this bit number are in use *\/$/;"	m	struct:super_block
s_isup	super.h	/^  struct inode *s_isup;		\/* inode for root dir of mounted file sys *\/$/;"	m	struct:super_block	typeref:struct:super_block::inode
s_log_zone_size	super.h	/^  short s_log_zone_size;	\/* log2 of blocks\/zone *\/$/;"	m	struct:super_block
s_magic	super.h	/^  short s_magic;		\/* magic number to recognize super-blocks *\/$/;"	m	struct:super_block
s_max_size	super.h	/^  off_t s_max_size;		\/* maximum file size on this device *\/$/;"	m	struct:super_block
s_must	aha_scsi.c	/^PRIVATE int s_must;		\/* must finish the current request? *\/$/;"	v
s_name	aha_scsi.c	/^PRIVATE char *s_name()$/;"	f
s_native	super.h	/^  int s_native;			\/* set to 1 iff not byte swapped file system *\/$/;"	m	struct:super_block
s_ndzones	super.h	/^  int s_ndzones;		\/* # direct zones in an inode *\/$/;"	m	struct:super_block
s_nextpos	aha_scsi.c	/^PRIVATE unsigned long s_nextpos;\/* next byte on the device to transfer *\/$/;"	v
s_nindirs	super.h	/^  int s_nindirs;		\/* # indirect zones per indirect block *\/$/;"	m	struct:super_block
s_ninodes	super.h	/^  ino_t s_ninodes;		\/* # usable inodes on the minor device *\/$/;"	m	struct:super_block
s_nzones	super.h	/^  zone1_t  s_nzones;		\/* total device size, including bit maps etc *\/$/;"	m	struct:super_block
s_opcode	aha_scsi.c	/^PRIVATE int s_opcode;		\/* DEV_READ or DEV_WRITE *\/$/;"	v
s_pad	super.h	/^  short s_pad;			\/* try to avoid compiler-dependent padding *\/$/;"	m	struct:super_block
s_prepare	aha_scsi.c	/^PRIVATE struct device *s_prepare(device)$/;"	f
s_prnt	strftime.c	/^s_prnt(char *s, size_t maxsize, const char *str, int width)$/;"	f	file:
s_rd_only	super.h	/^  int s_rd_only;		\/* set to 1 iff file sys mounted read only *\/$/;"	m	struct:super_block
s_rdcdrom	aha_scsi.c	/^PRIVATE int s_rdcdrom(proc_nr, iop, pos, nbytes, user_phys)$/;"	f
s_schedule	aha_scsi.c	/^PRIVATE int s_schedule(proc_nr, iop)$/;"	f
s_sp	aha_scsi.c	/^PRIVATE struct scsi *s_sp;	\/* active SCSI device struct *\/$/;"	v	typeref:struct:scsi
s_type	aha_scsi.c	/^PRIVATE int s_type;		\/* sd, rst, nrst? *\/$/;"	v
s_version	super.h	/^  int s_version;		\/* file system version, zero means bad magic *\/$/;"	m	struct:super_block
s_zmap_blocks	super.h	/^  short s_zmap_blocks;		\/* # of blocks used by zone bit map *\/$/;"	m	struct:super_block
s_zones	super.h	/^  zone_t s_zones;		\/* number of zones (replaces s_nzones in V2) *\/$/;"	m	struct:super_block
s_zsearch	super.h	/^  bit_t s_zsearch;		\/* all zones below this bit number are in use*\/$/;"	m	struct:super_block
sal	trp.s	/^sal dx,#1$/;"	l
sar	trp.s	/^sar dx,#1$/;"	l
save	mpx386.s	/^save:$/;"	l
save	mpx88.s	/^save:				! save the machine state in the proc table.$/;"	l
save_parameters	boot.c	/^void save_parameters(void)$/;"	f
save_parameters	edparams.c	/^void save_parameters(void)$/;"	f
save_sp	klib88.s	/^save_sp:			! place to put sp when switching to real mode$/;"	l
save_yank	editline.c	/^save_yank(begin, i)$/;"	f
saveoldterm	termmisc.c	/^int saveoldterm()$/;"	f
saveterm	termmisc.c	/^int saveterm()$/;"	f
savetty	termmisc.c	/^int savetty()$/;"	f
sbf4	sbf4.c	/^sbf4(s2,s1)$/;"	f
sbf8	sbf8.c	/^sbf8(s2,s1)$/;"	f
sbrk	_brk.c	/^PUBLIC char *sbrk(incr)$/;"	f
sbrk	_brk.c	3;"	d	file:
sbrk	_exec.c	6;"	d	file:
sbrk	boothead.s	/^sbrk:	push	ax		! save it as future return value$/;"	l
sbyte	memset.s	/^sbyte:	rep$/;"	l
scan_colon	getpwent.c	/^static char *scan_colon(void)$/;"	f	file:
scan_keyboard	keyboard.c	/^PRIVATE int scan_keyboard()$/;"	f
scan_punct	getgrent.c	/^static char *scan_punct(int punct)$/;"	f	file:
scan_quoted	getttyent.c	/^static char **scan_quoted(void)$/;"	f	file:
scan_white	getttyent.c	/^static char *scan_white(int quoted)$/;"	f	file:
scanf	scanf.c	/^scanf(const char *format, ...)$/;"	f
scanw	prntscan.c	/^int scanw(const char *fmt, ...)$/;"	f
sccsid	gethnmadr.c	/^static char sccsid[] = "@(#)gethostnamadr.c	6.41 (Berkeley) 6\/1\/90";$/;"	v	file:
sccsid	gethostent.c	/^static char sccsid[] = "@(#)gethostnamadr.c	6.41 (Berkeley) 6\/1\/90";$/;"	v	file:
sccsid	getproto.c	/^static char sccsid[] = "@(#)getproto.c	5.6 (Berkeley) 6\/1\/90";$/;"	v	file:
sccsid	getprotoent.c	/^static char sccsid[] = "@(#)getprotoent.c	5.7 (Berkeley) 6\/1\/90";$/;"	v	file:
sccsid	getservent.c	/^static char sccsid[] = "@(#)getservent.c	5.8 (Berkeley) 6\/1\/90";$/;"	v	file:
sccsid	getsrvbyname.c	/^static char sccsid[] = "@(#)getservbyname.c	5.6 (Berkeley) 6\/1\/90";$/;"	v	file:
sccsid	getsrvbyport.c	/^static char sccsid[] = "@(#)getservbyport.c	5.6 (Berkeley) 6\/1\/90";$/;"	v	file:
sccsid	inet_addr.c	/^static char sccsid[] = "@(#)inet_addr.c	5.8 (Berkeley) 6\/23\/90";$/;"	v	file:
sccsid	inet_ntoa.c	/^static char sccsid[] = "@(#)inet_ntoa.c	5.5 (Berkeley) 6\/1\/90";$/;"	v	file:
sccsid	rcmd.c	/^static char sccsid[] = "@(#)rcmd.c	5.22 (Berkeley) 6\/1\/90";$/;"	v	file:
sccsid	res_comp.c	/^static char sccsid[] = "@(#)res_comp.c	6.18 (Berkeley) 6\/27\/90";$/;"	v	file:
sccsid	res_init.c	/^static char sccsid[] = "@(#)res_init.c	6.14 (Berkeley) 6\/27\/90";$/;"	v	file:
sccsid	res_mkquery.c	/^static char sccsid[] = "@(#)res_mkquery.c	6.12 (Berkeley) 6\/1\/90";$/;"	v	file:
sccsid	res_query.c	/^static char sccsid[] = "@(#)res_query.c	5.7 (Berkeley) 6\/1\/90";$/;"	v	file:
sccsid	res_send.c	/^static char sccsid[] = "@(#)res_send.c	6.27 (Berkeley) 2\/24\/91";$/;"	v	file:
sccsid	yyerror.c	/^static char sccsid[] = "@(#)yyerror.c	5.2 (Berkeley) 5\/15\/90";$/;"	v	file:
sched	proc.c	/^PRIVATE void sched()$/;"	f
sched_ticks	clock.c	/^PRIVATE int sched_ticks = SCHED_RATE;	\/* counter: when 0, call scheduler *\/$/;"	v
schedule	boot.c	/^void schedule(long msec, char *cmd)$/;"	f
schedule	edparams.c	/^void schedule(long msec, char *cmd)$/;"	f
scr_init	console.c	/^PUBLIC void scr_init(tp)$/;"	f
scr_lines	console.c	74;"	d	file:
scr_size	console.c	75;"	d	file:
scr_width	console.c	73;"	d	file:
scratch	rawfs.c	51;"	d	file:
scroll	winscrol.c	/^void scroll(win)$/;"	f
scroll_screen	console.c	/^PRIVATE void scroll_screen(cons, dir)$/;"	f
scrollok	options.c	/^void scrollok(win, flag)$/;"	f
scsi	aha_scsi.c	/^PRIVATE struct scsi {	\/* Per-device table *\/$/;"	s	file:
scsi	aha_scsi.c	/^} scsi[MAX_DEVICES];$/;"	v	typeref:struct:scsi
scsi_ansiver	aha_scsi.c	254;"	d	file:
scsi_command	aha_scsi.c	/^PRIVATE int scsi_command(data, len)$/;"	f
scsi_devstr	aha_scsi.c	/^PRIVATE char *scsi_devstr[SCSI_DEVMAX+1] = {$/;"	v
scsi_ecmaver	aha_scsi.c	253;"	d	file:
scsi_inquiry	aha_scsi.c	/^PRIVATE int scsi_inquiry()$/;"	f
scsi_isover	aha_scsi.c	252;"	d	file:
scsi_ndisk	aha_scsi.c	/^PRIVATE int scsi_ndisk()$/;"	f
scsi_ntape	aha_scsi.c	/^PRIVATE int scsi_ntape()$/;"	f
scsi_op	aha_scsi.c	185;"	d	file:
scsi_probe	aha_scsi.c	/^PRIVATE int scsi_probe()$/;"	f
scsi_rmb	aha_scsi.c	250;"	d	file:
scsi_sense	aha_scsi.c	/^PRIVATE int scsi_sense()$/;"	f
scsi_simple	aha_scsi.c	/^PRIVATE int scsi_simple(opcode, count)$/;"	f
scsi_sync	aha_scsi.c	259;"	d	file:
sdesc	protect.c	/^PRIVATE void sdesc(segdp, base, size)$/;"	f
se	cursesio.c	/^char *se;			\/* end standout capability *\/$/;"	v
search	extboot.s	/^search:$/;"	l
search_dir	path.c	/^PUBLIC int search_dir(ldir_ptr, string, numb, flag)$/;"	f
search_hist	editline.c	/^search_hist(search, move)$/;"	f
searchenv	boot.c	/^environment **searchenv(char *name)$/;"	f
searchenv	edparams.c	/^environment **searchenv(char *name)$/;"	f
second	test15.c	/^void second()$/;"	f
secondary	boot.c	/^	int device, primary, secondary;$/;"	m	struct:biosdev	file:
secpcyl	bootblock.s	/^	secpcyl	   =	     6	! Sectors per cylinder = heads * sectors$/;"	d
secspcyl	boothead.s	/^secspcyl:	.space 1*2$/;"	l
sector	at_wini.c	/^  u8_t	sector;$/;"	m	struct:command	file:
sectors	bios_wini.c	/^  unsigned sectors;		\/* number of sectors per track *\/$/;"	m	struct:wini	file:
sectors	boot.h	/^EXTERN u16_t heads, sectors;	\/* Its number of heads and sectors. *\/$/;"	v
seed	lrand.c	/^long seed(lseed)$/;"	f
seek	floppy.c	/^PRIVATE int seek(fp)$/;"	f
seekdir	_rewinddir.c	7;"	d	file:
seekdir	_seekdir.c	/^int seekdir(DIR *dp, off_t pos)$/;"	f
seekdir	_seekdir.c	8;"	d	file:
seg2abs	boothead.s	/^seg2abs:			! Translate dx:ax to the 32 bit address dx-ax$/;"	l
seg2phys	protect.c	/^PUBLIC phys_bytes seg2phys(seg)$/;"	f
segdesc_s	type.h	/^struct segdesc_s {		\/* segment descriptor for protected mode *\/$/;"	s
segm_t	type.h	/^typedef unsigned segm_t;$/;"	t
segment	boot.h	/^	u16_t	segment;$/;"	m	struct:vector
segnum	aha_scsi.c	/^    byte segnum;		\/* Segment Number *\/$/;"	m	struct:__anon8	file:
select_console	console.c	/^PUBLIC void select_console(int cons_line)$/;"	f
select_image	bootimage.c	/^char *select_image(char *image)$/;"	f
selected	bootimage.c	/^int selected(char *name)$/;"	f
selector	protect.c	/^  u16_t selector;$/;"	m	struct:gatedesc_s	file:
send_mess	floppy.c	/^PRIVATE void send_mess()$/;"	f
sendq	dp8390.h	/^	struct sendq$/;"	s	struct:dpeth
sense	aha_scsi.c	/^    byte sense[sizeof(sense_t)];\/* SCSI Request Sense Information *\/$/;"	m	struct:__anon10	file:
sense_eof	aha_scsi.c	216;"	d	file:
sense_eom	aha_scsi.c	215;"	d	file:
sense_ili	aha_scsi.c	214;"	d	file:
sense_key	aha_scsi.c	213;"	d	file:
sense_serious	aha_scsi.c	382;"	d	file:
sense_serious	aha_scsi.c	384;"	d	file:
sense_t	aha_scsi.c	/^} sense_t;$/;"	t	typeref:struct:__anon8	file:
senselen	aha_scsi.c	/^    byte senselen;		\/* Request\/Disable Sense, Allocation Length *\/$/;"	m	struct:__anon10	file:
sepID	boothead.s	/^sepID:$/;"	l
sequence	console.c	/^struct sequence {$/;"	s	file:
serv	getservent.c	/^static struct servent serv;$/;"	v	typeref:struct:servent	file:
serv_aliases	getservent.c	/^static char *serv_aliases[MAXALIASES];$/;"	v	file:
servf	getservent.c	/^static FILE *servf = NULL;$/;"	v	file:
set	test7.c	/^int set(how, first, last)$/;"	f
set_6845	console.c	/^PRIVATE void set_6845(reg, val)$/;"	f
set_alarm	signal.c	/^PUBLIC int set_alarm(proc_nr, sec)$/;"	f
set_ipaddr	arp.c	/^PUBLIC void set_ipaddr (eth_port, ipaddr)$/;"	f
set_leds	keyboard.c	/^PRIVATE void set_leds()$/;"	f
set_p1_restart	mpx88.s	/^set_p1_restart:$/;"	l
set_pointer	doprnt.c	33;"	d	file:
set_pointer	doprnt.c	35;"	d	file:
set_pointer	doprnt.c	38;"	d	file:
set_pointer	doscan.c	13;"	d	file:
set_pointer	doscan.c	15;"	d	file:
set_pointer	doscan.c	18;"	d	file:
set_porta	rs232.c	154;"	d	file:
set_restart1	mpx386.s	/^set_restart1:$/;"	l
set_vec	i8259.c	/^PRIVATE void set_vec(vec_nr, addr)$/;"	f
set_vec	i8259.c	31;"	d	file:
setattr	tty.c	/^PRIVATE void setattr(tp)$/;"	f
setbuf	setbuf.c	/^setbuf(register FILE *stream, char *buf)$/;"	f
setcur	boothead.s	/^setcur:	xor	dx, dx		! dl = column = 0, dh = row = 0$/;"	l
setgid	_setgid.c	/^PUBLIC int setgid(grp)$/;"	f
setgid	_setgid.c	2;"	d	file:
setgrent	getgrent.c	/^int setgrent(void)$/;"	f
setgrfile	getgrent.c	/^void setgrfile(const char *file)$/;"	f
sethostent	gethostent.c	/^sethostent(f)$/;"	f
sethostent	gethostent.c	27;"	d	file:
setlocale	setlocale.c	/^setlocale(int category, const char *locale)$/;"	f
setprotoent	getprotoent.c	/^setprotoent(f)$/;"	f
setpwent	getpwent.c	/^int setpwent(void)$/;"	f
setpwfile	getpwent.c	/^void setpwfile(const char *file)$/;"	f
setscrreg	scrreg.c	/^int setscrreg(top, bottom)$/;"	f
setservent	getservent.c	/^setservent(f)$/;"	f
setsid	_setsid.c	/^PUBLIC pid_t setsid()$/;"	f
setsid	_setsid.c	2;"	d	file:
setsignumber	test29.c	/^void setsignumber(signum)$/;"	f
setterm	cursesio.c	/^int setterm(type)$/;"	f
settimer	tty.c	/^PRIVATE void settimer(tp, on)$/;"	f
setttyent	getttyent.c	/^int setttyent(void)$/;"	f
setuid	_setuid.c	/^PUBLIC int setuid(usr)$/;"	f
setuid	_setuid.c	2;"	d	file:
setup_read	arp.c	/^PRIVATE void setup_read(port)$/;"	f
setup_read	mnx_eth.c	/^PRIVATE void setup_read(eth_port)$/;"	f
setup_write	arp.c	/^PRIVATE void setup_write(port)$/;"	f
setupterm	termmisc.c	/^int setupterm()$/;"	f
setvbuf	setvbuf.c	/^setvbuf(register FILE *stream, char *buf, int mode, size_t size)$/;"	f
sfree	boot.c	/^void sfree(char *s)$/;"	f
sfree	edparams.c	/^void sfree(char *s)$/;"	f
sft_ext	sft_ext.c	/^sft_ext(e1,e2)$/;"	f
sgspd	tty.c	/^  u8_t		sgspd;$/;"	m	struct:s2s	file:
sgspd2tspd	tty.c	/^PRIVATE speed_t sgspd2tspd(sgspd)$/;"	f
shift	keyboard.c	/^PRIVATE int shift;		\/* shift key state *\/$/;"	v
shorts	ether.h	/^    unsigned short shorts[3];		\/* force 2-byte alignment *\/$/;"	m	union:etheraddr
show_env	boot.c	/^void show_env(void)$/;"	f
show_env	edparams.c	/^void show_env(void)$/;"	f
show_req	aha_scsi.c	/^PRIVATE void show_req()$/;"	f
show_req	aha_scsi.c	462;"	d	file:
si	protect.c	/^  reg_t si;$/;"	m	struct:tss_s	file:
si	type.h	/^  reg_t si;			\/* order is to match pusha\/popa *\/$/;"	m	struct:stackframe_s
siaint	rs232.c	/^PRIVATE void siaint(type)$/;"	f
sig	param.h	36;"	d
sig1	test8.c	/^int iteration, cumsig, subtest, errct = 0, sig1, sig2;$/;"	v
sig2	test8.c	/^int iteration, cumsig, subtest, errct = 0, sig1, sig2;$/;"	v
sig_proc	signal.c	/^PUBLIC void sig_proc(rmp, signo)$/;"	f
sig_procs	glo.h	/^EXTERN int sig_procs;		\/* number of procs with p_pending != 0 *\/$/;"	v
sigaction	_sigaction.c	/^PUBLIC int sigaction(sig, act, oact)$/;"	f
sigaction	_sigaction.c	2;"	d	file:
sigaction	asynchio.c	12;"	d	file:
sigaction	getpass.c	5;"	d	file:
sigaddset	_sigset.c	/^PUBLIC int sigaddset(set, signo)$/;"	f
sigaddset	_sigset.c	11;"	d	file:
sigalrm_handler10	test8.c	/^void sigalrm_handler10(signo)$/;"	f
sigarray	test8.c	/^int sigarray[SIGS] = {SIGHUP, SIGILL, SIGTRAP, SIGABRT, SIGIOT, SIGUNUSED,$/;"	v
sigchar	tty.c	/^PUBLIC void sigchar(tp, sig)$/;"	f
sigct	test2.c	/^int is, array[4], parsigs, parcum, sigct, cumsig, errct, subtest;$/;"	v
sigdelset	_sigset.c	/^PUBLIC int sigdelset(set, signo)$/;"	f
sigdelset	_sigset.c	12;"	d	file:
sigemptyset	_sigset.c	/^PUBLIC int sigemptyset(set)$/;"	f
sigemptyset	_sigset.c	13;"	d	file:
sigemptyset	getpass.c	6;"	d	file:
sigfillset	_sigreturn.c	2;"	d	file:
sigfillset	_sigset.c	/^PUBLIC int sigfillset(set)$/;"	f
sigfillset	_sigset.c	14;"	d	file:
sigfillset	asynchio.c	13;"	d	file:
sigfunc	test7.c	/^void sigfunc(s)$/;"	f
sighup10	test8.c	/^void sighup10(signo)$/;"	f
sighup8	test8.c	/^void sighup8(signo)$/;"	f
sighup9	test8.c	/^void sighup9(signo)$/;"	f
sigint_handler	test8.c	/^void sigint_handler(signo)$/;"	f
sigismember	_sigset.c	/^PUBLIC int sigismember(set, signo)$/;"	f
sigismember	_sigset.c	15;"	d	file:
sigisvalid	_sigset.c	24;"	d	file:
sigjmp	_sigreturn.c	/^PUBLIC int sigjmp(jb, retval)$/;"	f
sigjmp	_sigreturn.c	3;"	d	file:
siglongjmp	_sigsetjmp.c	/^PUBLIC void siglongjmp(env, val)$/;"	f
sigmap	test5.c	/^int sigmap[5] = {9, 10, 11};$/;"	v
sign	FP_types.h	/^	short	sign;$/;"	m	struct:__anon19
sign	ext_fmt.h	/^	short	sign;$/;"	m	struct:EXTEND
signumber	test29.c	/^int signumber = 0;$/;"	v
sigpending	_sigpending.c	/^PUBLIC int sigpending(set)$/;"	f
sigpending	_sigpending.c	2;"	d	file:
sigpip	test2.c	/^void sigpip(s)$/;"	f
sigpip8	test8.c	/^void sigpip8(signo)$/;"	f
sigpipe_handler	test8.c	/^void sigpipe_handler(signo)$/;"	f
sigprocmask	_sigprocmask.c	/^PUBLIC int sigprocmask(how, set, oset)$/;"	f
sigprocmask	_sigprocmask.c	2;"	d	file:
sigprocmask	_sigreturn.c	4;"	d	file:
sigreturn	_sigreturn.c	/^PUBLIC int sigreturn(scp)$/;"	f
sigreturn	_sigreturn.c	5;"	d	file:
sigsuspend	_sigsuspend.c	/^PUBLIC int sigsuspend(set)$/;"	f
sigsuspend	_sigsuspend.c	2;"	d	file:
sigter8	test8.c	/^void sigter8(signo)$/;"	f
sigter9	test8.c	/^void sigter9(signo)$/;"	f
sin	sin.c	/^sin(double x)$/;"	f
sinh	sinh.c	/^sinh(double x)$/;"	f
sinh_cosh	sinh.c	/^sinh_cosh(double x, int cosh_flag)$/;"	f	file:
sinus	sin.c	/^sinus(double x, int cos_flag)$/;"	f	file:
size	type.h	/^  phys_clicks size;$/;"	m	struct:memory
size_ok	break.c	/^PUBLIC int size_ok(file_type, tc, dc, sc, dvir, s_vir)$/;"	f
sleep	_sleep.c	/^PUBLIC unsigned sleep(secs)$/;"	f
sleep	_sleep.c	9;"	d	file:
slock	keyboard.c	/^PRIVATE int slock;		\/* scroll lock key state *\/$/;"	v
slock_off	keyboard.c	/^PRIVATE int slock_off;		\/* 1 = normal position, 0 = depressed *\/$/;"	v
slot1	param.h	37;"	d
slotent	init.c	/^struct slotent {$/;"	s	file:
slots	init.c	/^struct slotent slots[PIDSLOTS];	\/* init table of ttys and pids *\/$/;"	v	typeref:struct:slotent
slword	memset.s	/^slword:	movb	ah, al$/;"	l
smallcopy	boothead.s	/^smallcopy:$/;"	l
so	cursesio.c	/^char *so;			\/* start standout capability *\/$/;"	v
softscroll	console.c	/^PRIVATE int softscroll;		\/* 1 = software scrolling, 0 = hardware *\/$/;"	v
sort	drvlib.c	/^PRIVATE void sort(table)$/;"	f
sort	extboot.s	/^sort:	mov	si, bp			! First table entry$/;"	l
sort	masterboot.s	/^sort:	mov	si, bp			! First table entry$/;"	l
sp	fsversion.c	/^static struct super_block super, *sp;$/;"	v	typeref:struct:	file:
sp	protect.c	/^  reg_t sp;$/;"	m	struct:tss_s	file:
sp	type.h	/^  reg_t sp;			\/* also known as a7 *\/$/;"	m	struct:stackframe_s
sp	type.h	/^  reg_t sp;                     \/*  | *\/$/;"	m	struct:stackframe_s
sp0	protect.c	/^  reg_t sp0;                    \/* stack pointer to use during interrupt *\/$/;"	m	struct:tss_s	file:
sp1	protect.c	/^  reg_t sp1;$/;"	m	struct:tss_s	file:
sp2	protect.c	/^  reg_t sp2;$/;"	m	struct:tss_s	file:
spawn	init.c	/^int spawn = 1;			\/* flag, spawn processes only when set *\/$/;"	v
spawn	test10.c	/^void spawn(n)$/;"	f
spec1	floppy.c	/^PRIVATE char spec1[NT] =$/;"	v
sprintf	sprintf.c	/^sprintf(char * s, const char *format, ...)$/;"	f
spurious_irq	i8259.c	/^PRIVATE int spurious_irq(irq)$/;"	f
sq_filled	dp8390.h	/^		int sq_filled;		\/* this buffer contains a packet *\/$/;"	m	struct:dpeth::sendq
sq_sendpage	dp8390.h	/^		int sq_sendpage;	\/* starting page of the buffer *\/$/;"	m	struct:dpeth::sendq
sq_size	dp8390.h	/^		int sq_size;		\/* with this size *\/$/;"	m	struct:dpeth::sendq
sqrt	sqrt.c	/^sqrt(double x)$/;"	f
sr_add_minor	sr.c	/^PUBLIC int sr_add_minor(minor, port, openf, closef, readf, writef,$/;"	f
sr_cancel	sr.c	/^PRIVATE int sr_cancel(m)$/;"	f
sr_cancel_t	sr.h	/^typedef int  (*sr_cancel_t) ARGS(( int fd, int which_operation ));$/;"	t
sr_close	sr.c	/^PRIVATE void sr_close(m)$/;"	f
sr_close_t	sr.h	/^typedef void (*sr_close_t) ARGS(( int fd ));$/;"	t
sr_fd	sr.c	/^typedef struct sr_fd$/;"	s	file:
sr_fd_t	sr.c	/^} sr_fd_t;$/;"	t	typeref:struct:sr_fd	file:
sr_fd_table	sr.c	/^PRIVATE sr_fd_t sr_fd_table[FD_NR];$/;"	v
sr_get_userdata	sr.c	/^PRIVATE acc_t *sr_get_userdata (fd, offset, count, for_ioctl)$/;"	f
sr_getchannel	sr.c	/^PRIVATE sr_fd_t *sr_getchannel(minor)$/;"	f
sr_init	sr.c	/^PUBLIC void sr_init()$/;"	f
sr_ioctl_t	sr.h	/^typedef int  (*sr_ioctl_t) ARGS(( int fd, int req ));$/;"	t
sr_open	sr.c	/^PRIVATE int sr_open(m)$/;"	f
sr_open_t	sr.h	/^typedef int  (*sr_open_t) ARGS(( int port, int srfd,$/;"	t
sr_put_userdata	sr.c	/^PRIVATE int sr_put_userdata (fd, offset, data, for_ioctl)$/;"	f
sr_read_t	sr.h	/^typedef int (*sr_read_t) ARGS(( int fd, size_t count ));$/;"	t
sr_rec	sr.c	/^PUBLIC void sr_rec(m)$/;"	f
sr_repl_queue	sr.c	/^PRIVATE int sr_repl_queue(proc)$/;"	f
sr_reply	sr.c	/^PRIVATE void sr_reply (mess_ptr, status)$/;"	f
sr_revive	sr.c	/^PRIVATE void sr_revive (m, status)$/;"	f
sr_rwio	sr.c	/^PRIVATE int sr_rwio(m)$/;"	f
sr_write_t	sr.h	/^typedef int (*sr_write_t) ARGS(( int fd, size_t count ));$/;"	t
srand	rand.c	/^void srand(unsigned int seed)$/;"	f
src	ether.h	/^    ether_addr src;$/;"	m	struct:etherpacket
src	ether.h	/^    ether_addr src;$/;"	m	struct:ethervec
srf_cancel	sr.c	/^	sr_cancel_t srf_cancel;$/;"	m	struct:sr_fd	file:
srf_close	sr.c	/^	sr_close_t srf_close;$/;"	m	struct:sr_fd	file:
srf_fd	sr.c	/^	int srf_fd;$/;"	m	struct:sr_fd	file:
srf_flags	sr.c	/^	int srf_flags;$/;"	m	struct:sr_fd	file:
srf_ioctl	sr.c	/^	sr_ioctl_t srf_ioctl;$/;"	m	struct:sr_fd	file:
srf_ioctl_q	sr.c	/^	mq_t *srf_ioctl_q, *srf_ioctl_q_tail;$/;"	m	struct:sr_fd	file:
srf_ioctl_q_tail	sr.c	/^	mq_t *srf_ioctl_q, *srf_ioctl_q_tail;$/;"	m	struct:sr_fd	file:
srf_open	sr.c	/^	sr_open_t srf_open;$/;"	m	struct:sr_fd	file:
srf_port	sr.c	/^	int srf_port;$/;"	m	struct:sr_fd	file:
srf_read	sr.c	/^	sr_read_t srf_read;$/;"	m	struct:sr_fd	file:
srf_read_q	sr.c	/^	mq_t *srf_read_q, *srf_read_q_tail;$/;"	m	struct:sr_fd	file:
srf_read_q_tail	sr.c	/^	mq_t *srf_read_q, *srf_read_q_tail;$/;"	m	struct:sr_fd	file:
srf_write	sr.c	/^	sr_write_t srf_write;$/;"	m	struct:sr_fd	file:
srf_write_q	sr.c	/^	mq_t *srf_write_q, *srf_write_q_tail;$/;"	m	struct:sr_fd	file:
srf_write_q_tail	sr.c	/^	mq_t *srf_write_q, *srf_write_q_tail;$/;"	m	struct:sr_fd	file:
ss	protect.c	/^  reg_t ss;$/;"	m	struct:tss_s	file:
ss	type.h	/^  reg_t ss;                     \/* these are pushed by CPU during interrupt *\/$/;"	m	struct:stackframe_s
ss0	protect.c	/^  reg_t ss0;                    \/*   "   segment  "  "    "        "     *\/$/;"	m	struct:tss_s	file:
ss1	protect.c	/^  reg_t ss1;$/;"	m	struct:tss_s	file:
ss2	protect.c	/^  reg_t ss2;$/;"	m	struct:tss_s	file:
sscanf	sscanf.c	/^int sscanf(const char *s, const char *format, ...)$/;"	f
st	type.h	/^  reg_t st;			\/* hole for another copy of sp *\/$/;"	m	struct:stackframe_s
stack_switched	mpx88.s	/^stack_switched:$/;"	l
stackframe_s	type.h	/^struct stackframe_s {           \/* proc_ptr points here *\/$/;"	s
stackframe_s	type.h	/^struct stackframe_s {$/;"	s
start	common.c	/^void start(test_nr)$/;"	f
start_motor	floppy.c	/^PRIVATE void start_motor()$/;"	f
startup	init.c	/^void startup(int linenr, struct ttyent *ttyp)$/;"	f
stat	_getcwd.c	12;"	d	file:
stat	_opendir.c	11;"	d	file:
stat	_stat.c	/^PUBLIC int stat(name, buffer)$/;"	f
stat	_stat.c	2;"	d	file:
stat_inode	stadir.c	/^PRIVATE int stat_inode(rip, fil_ptr, user_addr)$/;"	f
state	aha_scsi.c	/^    char state;			\/* online? *\/$/;"	m	struct:scsi	file:
state	at_wini.c	/^  unsigned state;		\/* drive state: deaf, initialized, dead *\/$/;"	m	struct:wini	file:
state	pty.c	/^  char		state;		\/* flags: busy, closed, ... *\/$/;"	m	struct:pty	file:
state_frame	type.h	/^  struct state_frame {$/;"	s	struct:fsave
state_frame	type.h	/^  } state_frame;$/;"	m	struct:fsave	typeref:struct:fsave::state_frame
stateq	test26.c	/^int stateq(stp1, stp2)$/;"	f
status	aha_scsi.c	/^  byte status;		\/* Command or Status byte *\/$/;"	m	struct:__anon2	file:
status_block	esdi_wini.c	/^PRIVATE unsigned int status_block[9];	\/* status block output from a command *\/$/;"	v
stayopen	gethostent.c	/^static int stayopen = 0;$/;"	v	file:
std_err	stderr.c	/^void std_err(s)$/;"	f
stdscr	cursesio.c	/^WINDOW *stdscr, *curscr;$/;"	v
stdver	aha_scsi.c	/^    byte stdver;		\/* Version of standard compliance *\/$/;"	m	struct:__anon9	file:
steps_per_cyl	floppy.c	/^PRIVATE char steps_per_cyl[NT] =$/;"	v
stime	_stime.c	/^PUBLIC int stime(top)$/;"	f
stime	_stime.c	2;"	d	file:
stksize	type.h	/^  int stksize;$/;"	m	struct:tasktab
stopRainbow	ÏÂÔØËµÃ÷.htm	/^function stopRainbow()$/;"	f
stopRainbowAnchor	ÏÂÔØËµÃ÷.htm	/^function stopRainbowAnchor()$/;"	f
stop_beep	console.c	/^PRIVATE void stop_beep()$/;"	f
stop_motor	floppy.c	/^PRIVATE void stop_motor()$/;"	f
stop_proc	trace.c	/^PUBLIC void stop_proc(rmp, signo)$/;"	f
str	test17.c	/^void str(s)$/;"	f
str	test18.c	/^void str(s)$/;"	f
str	test20.c	/^char str[] = {"The time has come the walrus said to talk of many things.\\n"};$/;"	v
str2	test20.c	/^char str2[] = {"Of ships and shoes and sealing wax, of cabbages and kings.\\n"};$/;"	v
str3	test20.c	/^char str3[] = {"Of why the sea is boiling hot and whether pigs have wings\\n"};$/;"	v
str_scsi_sense	aha_scsi.c	/^PRIVATE char *str_scsi_sense[] = {$/;"	v
strbuf	unctrl.c	/^static char strbuf[3] = {0, 0, 0};$/;"	v	file:
strcasecmp	strcasecmp.c	/^strcasecmp(s1, s2)$/;"	f
strcat	strcat.c	/^strcat(char *ret, register const char *s2)$/;"	f
strchr	strchr.c	/^strchr(register const char *s, register int c)$/;"	f
strcmp	strcmp.c	/^strcmp(register const char *s1, register const char *s2)$/;"	f
strcoll	strcoll.c	/^strcoll(register const char *s1, register const char *s2)$/;"	f
strcpy	strcpy.c	/^strcpy(char *ret, register const char *s2)$/;"	f
strcspn	strcspn.c	/^strcspn(const char *string, const char *notin)$/;"	f
strdup	complete.c	/^strdup(p)$/;"	f
strerror	strerror.c	/^strerror(register int errnum)$/;"	f
strftime	strftime.c	/^strftime(char *s, size_t maxsize,$/;"	f
string2long	strtol.c	/^string2long(register const char *nptr, char ** const endptr,$/;"	f	file:
strlen	strlen.c	/^strlen(const char *org)$/;"	f
strncat	strncat.c	/^strncat(char *ret, register const char *s2, size_t n)$/;"	f
strncmp	strncmp.c	/^strncmp(register const char *s1, register const char *s2, register size_t n)$/;"	f
strncpy	strncpy.c	/^strncpy(char *ret, register const char *s2, register size_t n)$/;"	f
strpbrk	strpbrk.c	/^strpbrk(register const char *string, register const char *brk)$/;"	f
strrchr	strrchr.c	/^strrchr(register const char *s, int c)$/;"	f
strspn	strspn.c	/^strspn(const char *string, const char *in)$/;"	f
strstr	strstr.c	/^strstr(register const char *s, register const char *wanted)$/;"	f
strtod	fphook.c	/^strtod(const char *p, char **pp)$/;"	f
strtod	strtod.c	/^strtod(const char *p, char **pp)$/;"	f
strtok	strtok.c	/^strtok(register char *string, const char *separators)$/;"	f
strtol	strtol.c	/^strtol(register const char *nptr, char **endptr, int base)$/;"	f
strtoul	strtol.c	/^strtoul(register const char *nptr, char **endptr, int base)$/;"	f
strxfrm	strxfrm.c	/^strxfrm(register char *s1, register const char *save, register size_t n)$/;"	f
sub_ext	sub_ext.c	/^sub_ext(e1,e2)$/;"	f
subpart	aha_scsi.c	/^	    struct device subpart[SUB_PER_DRIVE]; \/* subparts: sd[1-4][a-d] *\/$/;"	m	struct:scsi::__anon12::__anon14	typeref:struct:scsi::__anon12::__anon14::device	file:
subpart	aha_scsi.c	359;"	d	file:
subpart	at_wini.c	/^  struct device subpart[SUB_PER_DRIVE]; \/* subpartitions: hd[1-4][a-d] *\/$/;"	m	struct:wini	typeref:struct:wini::device	file:
subpart	bios_wini.c	/^  struct device subpart[SUB_PER_DRIVE]; \/* subpartitions: hd[1-4][a-d] *\/$/;"	m	struct:wini	typeref:struct:wini::device	file:
subpart	esdi_wini.c	/^  struct device subpart[SUB_PER_DRIVE];	\/* subpartitions: hd[1-4][a-d] *\/$/;"	m	struct:wini	typeref:struct:wini::device	file:
subr	test4.c	/^void subr()$/;"	f
substrcmp	editline.c	/^substrcmp(text, pat, len)$/;"	f
subtest	common.c	/^int common_test_nr = -1, errct = 0, subtest;$/;"	v
subtest	t11a.c	/^int errct, subtest=1;$/;"	v
subtest	t11b.c	/^int errct, subtest=1;$/;"	v
subtest	test1.c	/^int subtest;$/;"	v
subtest	test11.c	/^int errct, subtest;$/;"	v
subtest	test14.c	/^int subtest = 1;$/;"	v
subtest	test16.c	/^int errct, subtest, passes;$/;"	v
subtest	test19.c	/^int errct, subtest, passes, pipesigs;$/;"	v
subtest	test2.c	/^int is, array[4], parsigs, parcum, sigct, cumsig, errct, subtest;$/;"	v
subtest	test20.c	/^int subtest, errct;$/;"	v
subtest	test21.c	/^int subtest, errct;$/;"	v
subtest	test22.c	/^int subtest = 1;$/;"	v
subtest	test23.c	/^int subtest;$/;"	v
subtest	test24.c	/^int subtest = 1;$/;"	v
subtest	test25.c	/^int subtest = 1;$/;"	v
subtest	test26.c	/^int subtest = 1;$/;"	v
subtest	test27.c	/^int subtest = 1;$/;"	v
subtest	test28.c	/^int subtest = 1;$/;"	v
subtest	test29.c	/^int subtest = 1;$/;"	v
subtest	test3.c	/^int errct, subtest;$/;"	v
subtest	test30.c	/^int subtest = 1;$/;"	v
subtest	test31.c	/^int subtest = 1;$/;"	v
subtest	test32.c	/^int subtest = 1;$/;"	v
subtest	test33.c	/^int subtest = 1;$/;"	v
subtest	test34.c	/^int subtest = 1;$/;"	v
subtest	test35.c	/^int subtest = 1;$/;"	v
subtest	test36.c	/^int subtest = 1;$/;"	v
subtest	test37.c	/^int subtest = 1;$/;"	v
subtest	test38.c	/^int subtest = 1;$/;"	v
subtest	test39.c	/^int subtest = 1;$/;"	v
subtest	test40.c	/^int subtest = 1;$/;"	v
subtest	test5.c	/^int subtest;$/;"	v
subtest	test6.c	/^int subtest = 1;$/;"	v
subtest	test7.c	/^int subtest, errct, xfd;$/;"	v
subtest	test8.c	/^int iteration, cumsig, subtest, errct = 0, sig1, sig2;$/;"	v
subwin	newwin.c	/^WINDOW *subwin(orig, num_lines, num_columns, begy, begx)$/;"	f
sugar	boot.c	/^int sugar(char *tok)$/;"	f
sugar	edparams.c	/^int sugar(char *tok)$/;"	f
super	fsversion.c	/^static struct super_block super, *sp;$/;"	v	typeref:struct:super_block	file:
super	rawfs.c	/^static struct super_block super;	\/* Superblock of file system *\/$/;"	v	typeref:struct:super_block	file:
super_block	super.h	/^EXTERN struct super_block {$/;"	s
super_block	super.h	/^} super_block[NR_SUPERS];$/;"	v	typeref:struct:super_block
superuser	test23.c	/^int superuser;			\/* True if we are root. *\/$/;"	v
superuser	test24.c	/^int superuser;$/;"	v
superuser	test25.c	/^int superuser;$/;"	v
superuser	test26.c	/^int superuser;$/;"	v
superuser	test27.c	/^int superuser;$/;"	v
superuser	test28.c	/^int superuser;$/;"	v
superuser	test29.c	/^int superuser;$/;"	v
superuser	test30.c	/^int superuser;$/;"	v
superuser	test31.c	/^int superuser;$/;"	v
superuser	test32.c	/^int superuser;$/;"	v
superuser	test33.c	/^int superuser;			\/* nonzero if uid == euid (euid == 0 always) *\/$/;"	v
superuser	test34.c	/^int superuser;$/;"	v
superuser	test35.c	/^int superuser;$/;"	v
superuser	test36.c	/^int superuser;$/;"	v
superuser	test38.c	/^int superuser;$/;"	v
superuser	test39.c	/^int superuser;$/;"	v
suspend	pipe.c	/^PUBLIC void suspend(task)$/;"	f
swab	swab.c	/^void swab(from, to, count)$/;"	f
switch_read_fd	tcp_recv.c	/^PRIVATE void switch_read_fd (tcp_conn, new_fd, ref_urg_fd,$/;"	f
switch_write_fd	tcp_send.c	/^PRIVATE void switch_write_fd (tcp_conn, new_fd, ref_urg_fd,$/;"	f
switching	proc.c	/^PRIVATE unsigned char switching;	\/* nonzero to inhibit interrupt() *\/$/;"	v
sword	memset.s	/^sword:	movb	ah, al		! One byte to two bytes$/;"	l
syn_al_alive	clock.c	/^PRIVATE int syn_al_alive= TRUE; \/* don't wake syn_alrm_task before inited*\/$/;"	v
syn_alrm_task	clock.c	/^PUBLIC void syn_alrm_task()$/;"	f
syn_table	clock.c	/^PRIVATE int syn_table[NR_TASKS+NR_PROCS]; \/* which tasks get CLOCK_INT*\/$/;"	v
sync	_sync.c	/^PUBLIC int sync()$/;"	f
sync	_sync.c	2;"	d	file:
sys_abort	sys_abort.c	/^PUBLIC int sys_abort(int how, ...)$/;"	f
sys_call	proc.c	/^PUBLIC int sys_call(function, src_dest, m_ptr)$/;"	f
sys_copy	sys_copy.c	/^PUBLIC int sys_copy(src_proc, src_seg, src_vir,$/;"	f
sys_endsig	sys_endsig.c	/^PUBLIC int sys_endsig(proc)$/;"	f
sys_exec	sys_exec.c	/^PUBLIC int sys_exec(proc, ptr, traced, prog_name, initpc)$/;"	f
sys_fork	sys_fork.c	/^PUBLIC int sys_fork(parent, child, pid, child_base_or_shadow)$/;"	f
sys_fresh	sys_fresh.c	/^PUBLIC int sys_fresh(proc, ptr, dc, basep, sizep)$/;"	f
sys_getmap	sys_getmap.c	/^PUBLIC int sys_getmap(proc, ptr)$/;"	f
sys_getsp	sys_getsp.c	/^PUBLIC int sys_getsp(proc, newsp)$/;"	f
sys_kill	sys_kill.c	/^PUBLIC int sys_kill(proc, signr)$/;"	f
sys_newmap	sys_newmap.c	/^PUBLIC int sys_newmap(proc, ptr)$/;"	f
sys_oldsig	sys_oldsig.c	/^PUBLIC int sys_oldsig(proc, sig, sighandler)$/;"	f
sys_sendsig	sys_sendsig.c	/^PUBLIC int sys_sendsig(proc, smp)$/;"	f
sys_sigreturn	sys_sigret.c	/^PUBLIC int sys_sigreturn(proc, scp, flags)$/;"	f
sys_task	system.c	/^PUBLIC void sys_task()$/;"	f
sys_time	proc.h	/^  clock_t sys_time;		\/* sys time in ticks *\/$/;"	m	struct:proc
sys_times	sys_times.c	/^PUBLIC int sys_times(proc, ptr)$/;"	f
sys_trace	sys_trace.c	/^PUBLIC int sys_trace(req, procnr, addr, data_p)$/;"	f
sys_xit	sys_xit.c	/^PUBLIC int sys_xit(parent, proc, basep, sizep)$/;"	f
sysconf	sysconf.c	/^PUBLIC long int sysconf(name)$/;"	f
sysind	extboot.s	/^	sysind	   =	     4$/;"	d
sysind	masterboot.s	/^	sysind	   =	     4$/;"	d
t	aha_scsi.c	/^    } t;$/;"	m	union:__anon3	typeref:struct:__anon3::__anon5	file:
t1	test19.c	/^long t1;$/;"	v
t_class	floppy.c	/^	char	t_class;	\/* limit drive to this class of densities *\/$/;"	m	struct:test_order	file:
t_control	aha_scsi.c	/^	byte t_control;		\/* reserved and link bit fields, set to 0 *\/$/;"	m	struct:__anon3::__anon5	file:
t_density	floppy.c	/^	char	t_density;	\/* floppy\/drive type *\/$/;"	m	struct:test_order	file:
t_fixed	aha_scsi.c	/^	byte t_fixed;		\/* Fixed length? *\/$/;"	m	struct:__anon3::__anon5	file:
t_scsi_op	aha_scsi.c	/^	byte t_scsi_op;		\/* SCSI Operation Code *\/$/;"	m	struct:__anon3::__anon5	file:
t_trlength	aha_scsi.c	/^	big24 t_trlength;	\/* Transfer length *\/$/;"	m	struct:__anon3::__anon5	file:
table	misc.c	/^typedef struct table {$/;"	s	file:
tabsize	tabsize.c	/^int tabsize(ts)$/;"	f
tan	tan.c	/^tan(double x)$/;"	f
tanh	tanh.c	/^tanh(double x)$/;"	f
tape	aha_scsi.c	/^	} tape;$/;"	m	union:scsi::__anon12	typeref:struct:scsi::__anon12::__anon13	file:
targ	aha_scsi.c	/^    char targ;			\/* SCSI Target ID *\/$/;"	m	struct:scsi	file:
tarstat	aha_scsi.c	/^    byte tarstat;		\/* Target Device Status *\/$/;"	m	struct:__anon10	file:
task	device.c	/^PRIVATE major, minor, task;$/;"	v
task	wini.c	/^  task_t	*task;$/;"	m	struct:hdmap	file:
taskname	ps.c	/^char *taskname(p_nr)$/;"	f
tasktab	type.h	/^struct tasktab {$/;"	s
tc	cursesio.c	/^char tc[200];			\/* area to hold string capabilities *\/$/;"	v
tc_0wnd_to	tcp_int.h	/^	time_t tc_0wnd_to;$/;"	m	struct:tcp_conn
tc_IRS	tcp_int.h	/^	u32_t tc_IRS;$/;"	m	struct:tcp_conn
tc_ISS	tcp_int.h	/^	u32_t tc_ISS;		\/* initial sequence number *\/$/;"	m	struct:tcp_conn
tc_RCV_HI	tcp_int.h	/^	u32_t tc_RCV_HI;$/;"	m	struct:tcp_conn
tc_RCV_LO	tcp_int.h	/^	u32_t tc_RCV_LO;$/;"	m	struct:tcp_conn
tc_RCV_NXT	tcp_int.h	/^	u32_t tc_RCV_NXT;$/;"	m	struct:tcp_conn
tc_RCV_UP	tcp_int.h	/^	u32_t tc_RCV_UP;$/;"	m	struct:tcp_conn
tc_SND_NXT	tcp_int.h	/^	u32_t tc_SND_NXT;	\/* next sequence number for new data *\/$/;"	m	struct:tcp_conn
tc_SND_PSH	tcp_int.h	/^	u32_t tc_SND_PSH;	\/* push pointer, data should be pushed until the$/;"	m	struct:tcp_conn
tc_SND_TRM	tcp_int.h	/^	u32_t tc_SND_TRM;	\/* next sequence number to be transmitted *\/$/;"	m	struct:tcp_conn
tc_SND_UNA	tcp_int.h	/^	u32_t tc_SND_UNA;	\/* least unacknowledged sequence number *\/$/;"	m	struct:tcp_conn
tc_SND_UP	tcp_int.h	/^	u32_t tc_SND_UP;	\/* urgent pointer, first sequence number not $/;"	m	struct:tcp_conn
tc_SND_WL1	tcp_int.h	/^	u32_t tc_SND_WL1;$/;"	m	struct:tcp_conn
tc_SND_WL2	tcp_int.h	/^	u32_t tc_SND_WL2;$/;"	m	struct:tcp_conn
tc_ack_timer	tcp_int.h	/^	struct timer tc_ack_timer;$/;"	m	struct:tcp_conn	typeref:struct:tcp_conn::timer
tc_connuser	tcp_int.h	/^	tcp_fd_t *tc_connuser;$/;"	m	struct:tcp_conn
tc_error	tcp_int.h	/^	int tc_error;$/;"	m	struct:tcp_conn
tc_ett	tcp_int.h	/^	time_t tc_ett;$/;"	m	struct:tcp_conn
tc_flags	tcp_int.h	/^	int tc_flags;$/;"	m	struct:tcp_conn
tc_frag2send	tcp_int.h	/^	acc_t *tc_frag2send;$/;"	m	struct:tcp_conn
tc_locaddr	tcp_int.h	/^	ipaddr_t tc_locaddr;$/;"	m	struct:tcp_conn
tc_locport	tcp_int.h	/^	tcpport_t tc_locport;$/;"	m	struct:tcp_conn
tc_mainuser	tcp_int.h	/^	tcp_fd_t *tc_mainuser;$/;"	m	struct:tcp_conn
tc_major_timer	tcp_int.h	/^	struct timer tc_major_timer;$/;"	m	struct:tcp_conn	typeref:struct:tcp_conn::timer
tc_max_no_retrans	tcp_int.h	/^	int tc_max_no_retrans;$/;"	m	struct:tcp_conn
tc_minor_timer	tcp_int.h	/^	struct timer tc_minor_timer;$/;"	m	struct:tcp_conn	typeref:struct:tcp_conn::timer
tc_mss	tcp_int.h	/^	u16_t tc_mss;$/;"	m	struct:tcp_conn
tc_no_retrans	tcp_int.h	/^	int tc_no_retrans;$/;"	m	struct:tcp_conn
tc_orglisten	tcp_int.h	/^	int tc_orglisten;$/;"	m	struct:tcp_conn
tc_port	tcp_int.h	/^	tcp_port_t *tc_port;$/;"	m	struct:tcp_conn
tc_rcv_queue	tcp_int.h	/^	acc_t *tc_rcv_queue;$/;"	m	struct:tcp_conn
tc_rcv_wnd	tcp_int.h	/^	u16_t tc_rcv_wnd;$/;"	m	struct:tcp_conn
tc_rcvd_data	tcp_int.h	/^	acc_t *tc_rcvd_data;$/;"	m	struct:tcp_conn
tc_readuser	tcp_int.h	/^	tcp_fd_t *tc_readuser;$/;"	m	struct:tcp_conn
tc_remaddr	tcp_int.h	/^	ipaddr_t tc_remaddr;$/;"	m	struct:tcp_conn
tc_remipopt	tcp_int.h	/^	acc_t *tc_remipopt;$/;"	m	struct:tcp_conn
tc_remport	tcp_int.h	/^	tcpport_t tc_remport;$/;"	m	struct:tcp_conn
tc_remtcpopt	tcp_int.h	/^	acc_t *tc_remtcpopt;$/;"	m	struct:tcp_conn
tc_rtt	tcp_int.h	/^	time_t tc_rtt;$/;"	m	struct:tcp_conn
tc_send_data	tcp_int.h	/^	acc_t *tc_send_data;$/;"	m	struct:tcp_conn
tc_senddis	tcp_int.h	/^	time_t tc_senddis;$/;"	m	struct:tcp_conn
tc_snd_cinc	tcp_int.h	/^	u32_t tc_snd_cinc;	\/* increment for send window threshold *\/$/;"	m	struct:tcp_conn
tc_snd_cthresh	tcp_int.h	/^	u32_t tc_snd_cthresh;	\/* threshold for send window *\/$/;"	m	struct:tcp_conn
tc_snd_cwnd	tcp_int.h	/^	u32_t tc_snd_cwnd;	\/* highest sequence number to be sent *\/$/;"	m	struct:tcp_conn
tc_snd_wnd	tcp_int.h	/^	u16_t tc_snd_wnd;	\/* max send queue size *\/$/;"	m	struct:tcp_conn
tc_state	tcp_int.h	/^	int tc_state;$/;"	m	struct:tcp_conn
tc_time_wait_timer	tcp_int.h	/^	struct timer tc_time_wait_timer;$/;"	m	struct:tcp_conn	typeref:struct:tcp_conn::timer
tc_tos	tcp_int.h	/^	u8_t tc_tos;$/;"	m	struct:tcp_conn
tc_ttl	tcp_int.h	/^	u8_t tc_ttl;$/;"	m	struct:tcp_conn
tc_urg_wnd	tcp_int.h	/^	u16_t tc_urg_wnd;$/;"	m	struct:tcp_conn
tc_writeuser	tcp_int.h	/^	tcp_fd_t *tc_writeuser;$/;"	m	struct:tcp_conn
tcdrain	_tcdrain.c	/^int tcdrain(fd)$/;"	f
tcdrain	_tcdrain.c	7;"	d	file:
tcflow	_tcflow.c	/^int tcflow(fd, action)$/;"	f
tcflow	_tcflow.c	7;"	d	file:
tcflush	_tcflush.c	/^int tcflush(int fd, int queue_selector)$/;"	f
tcflush	_tcflush.c	4;"	d	file:
tcgetattr	_isatty.c	3;"	d	file:
tcgetattr	_tcgetattr.c	/^int tcgetattr(fd, termios_p)$/;"	f
tcgetattr	_tcgetattr.c	1;"	d	file:
tcgetattr	getpass.c	7;"	d	file:
tcp_GEmod4G	tcp_lib.c	/^PUBLIC int tcp_GEmod4G (n1, n2)$/;"	f
tcp_Gmod4G	tcp_lib.c	/^PUBLIC int tcp_Gmod4G (n1, n2)$/;"	f
tcp_LEmod4G	tcp_lib.c	/^PUBLIC int tcp_LEmod4G (n1, n2)$/;"	f
tcp_Lmod4G	tcp_lib.c	/^PUBLIC int tcp_Lmod4G (n1, n2)$/;"	f
tcp_attache	tcp.c	/^PRIVATE int tcp_attache(tcp_fd)$/;"	f
tcp_buffree	tcp.c	/^PRIVATE void tcp_buffree (priority, reqsize)$/;"	f
tcp_cancel	tcp.c	/^PUBLIC int tcp_cancel(fd, which_operation)$/;"	f
tcp_check_conn	tcp_lib.c	/^PUBLIC int tcp_check_conn(tcp_conn)$/;"	f
tcp_close	tcp.c	/^PUBLIC void tcp_close(fd)$/;"	f
tcp_close_connection	tcp_send.c	/^PUBLIC void tcp_close_connection(tcp_conn, error)$/;"	f
tcp_conn	tcp_int.h	/^typedef struct tcp_conn$/;"	s
tcp_conn_t	tcp_int.h	/^} tcp_conn_t;$/;"	t	typeref:struct:tcp_conn
tcp_conn_table	tcp.c	/^PUBLIC tcp_conn_t tcp_conn_table[TCP_CONN_NR];$/;"	v
tcp_conn_table	tcp_int.h	/^EXTERN tcp_conn_t tcp_conn_table[TCP_CONN_NR];$/;"	v
tcp_connect	res_send.c	/^static int tcp_connect(host, port, terrno)$/;"	f	file:
tcp_connect	tcp.c	/^PRIVATE int tcp_connect(tcp_fd)$/;"	f
tcp_delay	tcp_send.c	/^u32_t tcp_delay;$/;"	v
tcp_delay_on	tcp_send.c	/^int tcp_delay_on;$/;"	v
tcp_delay_to	tcp_send.c	/^PRIVATE void tcp_delay_to(ref, timer)$/;"	f
tcp_extract_ipopt	tcp_lib.c	/^PUBLIC void tcp_extract_ipopt(tcp_conn, ip_hdr)$/;"	f
tcp_extract_tcpopt	tcp_lib.c	/^PUBLIC void tcp_extract_tcpopt(tcp_conn, tcp_hdr)$/;"	f
tcp_fd	tcp_int.h	/^typedef struct tcp_fd$/;"	s
tcp_fd_t	tcp_int.h	/^} tcp_fd_t;$/;"	t	typeref:struct:tcp_fd
tcp_fd_table	tcp.c	/^PUBLIC tcp_fd_t tcp_fd_table[TCP_FD_NR];$/;"	v
tcp_fd_table	tcp_int.h	/^EXTERN tcp_fd_t tcp_fd_table[TCP_FD_NR];$/;"	v
tcp_frag2conn	tcp_recv.c	/^PUBLIC void tcp_frag2conn(tcp_conn, ip_pack, tcp_pack)$/;"	f
tcp_get_data	tcp.c	/^PRIVATE acc_t *tcp_get_data (port, offset, count, for_ioctl)$/;"	f
tcp_get_ipopt	tcp_lib.c	/^PUBLIC void tcp_get_ipopt(tcp_conn, ip_hdropt)$/;"	f
tcp_get_tcpopt	tcp_lib.c	/^PUBLIC void tcp_get_tcpopt(tcp_conn, tcp_hdropt)$/;"	f
tcp_init	tcp.c	/^PUBLIC void tcp_init()$/;"	f
tcp_ioctl	tcp.c	/^PUBLIC int tcp_ioctl (fd, req)$/;"	f
tcp_listen	tcp.c	/^PRIVATE int tcp_listen(tcp_fd)$/;"	f
tcp_main	tcp.c	/^PRIVATE void tcp_main(tcp_port)$/;"	f
tcp_make_header	tcp_lib.c	/^PUBLIC acc_t *tcp_make_header(tcp_conn, ref_ip_hdr, ref_tcp_hdr, data)$/;"	f
tcp_notreach	tcp.c	/^PRIVATE void tcp_notreach(pack)$/;"	f
tcp_open	tcp.c	/^PUBLIC int tcp_open (port, srfd, get_userdata, put_userdata)$/;"	f
tcp_pack_oneCsum	tcp_lib.c	/^PUBLIC u16_t tcp_pack_oneCsum(ip_pack, ip_pack_size)$/;"	f
tcp_port	tcp_int.h	/^typedef struct tcp_port$/;"	s
tcp_port_t	tcp_int.h	/^} tcp_port_t;$/;"	t	typeref:struct:tcp_port
tcp_port_table	tcp.c	/^PUBLIC tcp_port_t tcp_port_table[TCP_PORT_NR];$/;"	v
tcp_port_table	tcp_int.h	/^EXTERN tcp_port_t tcp_port_table[TCP_PORT_NR];$/;"	v
tcp_print_conn	tcp_lib.c	/^PUBLIC void tcp_print_conn(tcp_conn)$/;"	f
tcp_print_pack	tcp_lib.c	/^PUBLIC void tcp_print_pack(ip_hdr, tcp_hdr)$/;"	f
tcp_put_data	tcp.c	/^PRIVATE int tcp_put_data (fd, offset, data, for_ioctl)$/;"	f
tcp_read	tcp.c	/^PUBLIC int tcp_read(fd, count)$/;"	f
tcp_release_retrans	tcp_send.c	/^PUBLIC void tcp_release_retrans(tcp_conn, seg_ack, new_win)$/;"	f
tcp_reply_ioctl	tcp.c	/^PUBLIC void tcp_reply_ioctl(tcp_fd, reply)$/;"	f
tcp_reply_read	tcp.c	/^PUBLIC void tcp_reply_read(tcp_fd, reply)$/;"	f
tcp_reply_write	tcp.c	/^PUBLIC void tcp_reply_write(tcp_fd, reply)$/;"	f
tcp_restart_connect	tcp.c	/^PUBLIC void tcp_restart_connect(tcp_fd)$/;"	f
tcp_restart_fd_read	tcp_recv.c	/^PUBLIC void tcp_restart_fd_read (tcp_conn)$/;"	f
tcp_restart_fd_write	tcp_send.c	/^PUBLIC void tcp_restart_fd_write(tcp_conn)$/;"	f
tcp_restart_write	tcp_send.c	/^PUBLIC void tcp_restart_write (tcp_conn)$/;"	f
tcp_restart_write_conn	tcp_send.c	/^PRIVATE void tcp_restart_write_conn (tcp_conn)$/;"	f
tcp_restart_write_port	tcp_send.c	/^PUBLIC void tcp_restart_write_port (tcp_port)$/;"	f
tcp_set_ack_timer	tcp_send.c	/^PUBLIC void tcp_set_ack_timer (tcp_conn)$/;"	f
tcp_set_time_wait_timer	tcp_send.c	/^PUBLIC void tcp_set_time_wait_timer(tcp_conn)$/;"	f
tcp_setconf	tcp.c	/^PRIVATE int tcp_setconf(tcp_fd)$/;"	f
tcp_setup_conn	tcp.c	/^PRIVATE void tcp_setup_conn(tcp_conn)$/;"	f
tcp_shutdown	tcp_send.c	/^PUBLIC void tcp_shutdown(tcp_conn)$/;"	f
tcp_su4connect	tcp.c	/^PRIVATE int tcp_su4connect(tcp_fd)$/;"	f
tcp_su4listen	tcp.c	/^PUBLIC int tcp_su4listen(tcp_fd)$/;"	f
tcp_write	tcp.c	/^PUBLIC int tcp_write(fd, count)$/;"	f
tcp_write_state	tcp_lib.c	/^PUBLIC void tcp_write_state (tcp_conn)$/;"	f
tcp_zero_wnd_to	tcp_send.c	/^PUBLIC void tcp_zero_wnd_to(conn, timer)$/;"	f
tcpip_writeall	res_send.c	/^static int tcpip_writeall(fd, buf, siz)$/;"	f	file:
tcsendbreak	_tcsendbreak.c	/^int tcsendbreak(int fd, int duration)$/;"	f
tcsendbreak	_tcsendbreak.c	4;"	d	file:
tcsetattr	_tcsetattr.c	/^int tcsetattr(fd, opt_actions, termios_p)$/;"	f
tcsetattr	_tcsetattr.c	7;"	d	file:
tcsetattr	getpass.c	8;"	d	file:
tell	genmap.c	/^void tell(const char *s)$/;"	f
tell	init.c	/^void tell(fd, s)$/;"	f
telldir	telldir.c	/^off_t telldir(DIR *dp)$/;"	f
tempfile	test4.c	/^char *tempfile = "test4.temp";$/;"	v
ten_mult	ext_comp.c	/^ten_mult(struct EXTEND *e)$/;"	f	file:
ten_powers	ext_comp.c	/^static struct EXTEND ten_powers[] = {	\/* representation of 10 ** i *\/$/;"	v	typeref:struct:EXTEND	file:
termbuf	edparams.c	/^struct termios termbuf;$/;"	v	typeref:struct:termios
termcap	cursesio.c	/^char termcap[1024];		\/* termcap buffer *\/$/;"	v
termios_defaults	tty.c	/^PRIVATE struct termios termios_defaults = {$/;"	v	typeref:struct:termios
test	test17.c	/^void test(mask)$/;"	f
test	test18.c	/^void test()$/;"	f
test	trp.s	/^test    bx,bx$/;"	l
test	trp.s	/^test bx,bx$/;"	l
test01	test17.c	/^void test01()$/;"	f
test01	test18.c	/^void test01()$/;"	f
test02	test17.c	/^void test02()$/;"	f
test02	test18.c	/^void test02()$/;"	f
test03	test18.c	/^void test03()$/;"	f
test04	test18.c	/^void test04()$/;"	f
test05	test18.c	/^void test05()$/;"	f
test06	test18.c	/^void test06()$/;"	f
test07	test18.c	/^void test07()$/;"	f
test08	test17.c	/^void test08()$/;"	f
test09	test17.c	/^void test09()$/;"	f
test10	test17.c	/^void test10()$/;"	f
test11	test17.c	/^void test11()$/;"	f
test11a	test11.c	/^void test11a()$/;"	f
test11b	test11.c	/^void test11b()$/;"	f
test11c	test11.c	/^void test11c()$/;"	f
test11d	test11.c	/^void test11d()$/;"	f
test16a	test16.c	/^void test16a()$/;"	f
test19a	test19.c	/^void test19a()$/;"	f
test19b	test19.c	/^void test19b()$/;"	f
test19c	test19.c	/^void test19c()$/;"	f
test19d	test19.c	/^void test19d()$/;"	f
test19e	test19.c	/^void test19e()$/;"	f
test19f	test19.c	/^void test19f()$/;"	f
test19g	test19.c	/^void test19g()$/;"	f
test1a	test1.c	/^void test1a()$/;"	f
test1b	test1.c	/^void test1b()$/;"	f
test20a	test20.c	/^void test20a()$/;"	f
test20b	test20.c	/^void test20b()$/;"	f
test20c	test20.c	/^void test20c()$/;"	f
test20d	test20.c	/^void test20d()$/;"	f
test20e	test20.c	/^void test20e()$/;"	f
test20f	test20.c	/^void test20f()$/;"	f
test20g	test20.c	/^void test20g()$/;"	f
test20h	test20.c	/^void test20h()$/;"	f
test20i	test20.c	/^void test20i()$/;"	f
test20j	test20.c	/^void test20j()$/;"	f
test21a	test21.c	/^void test21a()$/;"	f
test21b	test21.c	/^void test21b()$/;"	f
test21c	test21.c	/^void test21c()$/;"	f
test21d	test21.c	/^void test21d()$/;"	f
test21e	test21.c	/^void test21e()$/;"	f
test21f	test21.c	/^void test21f()$/;"	f
test21g	test21.c	/^void test21g()$/;"	f
test21h	test21.c	/^void test21h()$/;"	f
test21i	test21.c	/^void test21i()$/;"	f
test21k	test21.c	/^void test21k()$/;"	f
test21l	test21.c	/^void test21l()$/;"	f
test21m	test21.c	/^void test21m()$/;"	f
test21n	test21.c	/^void test21n()$/;"	f
test21o	test21.c	/^void test21o()$/;"	f
test22a	test22.c	/^void test22a()$/;"	f
test23a	test23.c	/^void test23a()$/;"	f
test23b	test23.c	/^void test23b()$/;"	f
test23c	test23.c	/^void test23c()$/;"	f
test24a	test24.c	/^void test24a()$/;"	f
test24b	test24.c	/^void test24b()$/;"	f
test24c	test24.c	/^void test24c()$/;"	f
test25a	test25.c	/^void test25a()$/;"	f
test25b	test25.c	/^void test25b()$/;"	f
test25c	test25.c	/^void test25c()$/;"	f
test25d	test25.c	/^void test25d()$/;"	f
test25e	test25.c	/^void test25e()$/;"	f
test26a	test26.c	/^void test26a()$/;"	f
test26b	test26.c	/^void test26b()$/;"	f
test26c	test26.c	/^void test26c()$/;"	f
test27a	test27.c	/^void test27a()$/;"	f
test27b	test27.c	/^void test27b()$/;"	f
test27c	test27.c	/^void test27c()$/;"	f
test28a	test28.c	/^void test28a()$/;"	f
test28b	test28.c	/^void test28b()$/;"	f
test28c	test28.c	/^void test28c()$/;"	f
test29a	test29.c	/^void test29a()$/;"	f
test29b	test29.c	/^void test29b()$/;"	f
test29c	test29.c	/^void test29c()$/;"	f
test2a	test2.c	/^void test2a()$/;"	f
test2b	test2.c	/^void test2b()$/;"	f
test2c	test2.c	/^void test2c()$/;"	f
test2d	test2.c	/^void test2d()$/;"	f
test2e	test2.c	/^void test2e()$/;"	f
test2f	test2.c	/^void test2f()$/;"	f
test2g	test2.c	/^void test2g()$/;"	f
test2h	test2.c	/^void test2h()$/;"	f
test30a	test30.c	/^void test30a()$/;"	f
test30b	test30.c	/^void test30b()$/;"	f
test30c	test30.c	/^void test30c()$/;"	f
test31a	test31.c	/^void test31a()$/;"	f
test31b	test31.c	/^void test31b()$/;"	f
test31c	test31.c	/^void test31c()$/;"	f
test32a	test32.c	/^void test32a()$/;"	f
test32b	test32.c	/^void test32b()$/;"	f
test32c	test32.c	/^void test32c()$/;"	f
test33a	test33.c	/^void test33a()$/;"	f
test33b	test33.c	/^void test33b()$/;"	f
test33c	test33.c	/^void test33c()$/;"	f
test33d	test33.c	/^void test33d()$/;"	f
test34a	test34.c	/^void test34a()$/;"	f
test34b	test34.c	/^void test34b()$/;"	f
test34c	test34.c	/^void test34c()$/;"	f
test35a	test35.c	/^void test35a()$/;"	f
test35b	test35.c	/^void test35b()$/;"	f
test35c	test35.c	/^void test35c()$/;"	f
test36a	test36.c	/^void test36a()$/;"	f
test36b	test36.c	/^void test36b()$/;"	f
test36c	test36.c	/^void test36c()$/;"	f
test36d	test36.c	/^void test36d()$/;"	f
test37a	test37.c	/^void test37a()$/;"	f
test37b	test37.c	/^void test37b()$/;"	f
test38a	test38.c	/^void test38a()$/;"	f
test38b	test38.c	/^void test38b()$/;"	f
test38c	test38.c	/^void test38c()$/;"	f
test39a	test39.c	/^void test39a()$/;"	f
test39b	test39.c	/^void test39b()$/;"	f
test39c	test39.c	/^void test39c()$/;"	f
test39d	test39.c	/^void test39d()$/;"	f
test3a	test3.c	/^void test3a()$/;"	f
test3b	test3.c	/^void test3b()$/;"	f
test3c	test3.c	/^void test3c()$/;"	f
test3d	test3.c	/^void test3d()$/;"	f
test3e	test3.c	/^void test3e()$/;"	f
test40a	test40.c	/^void test40a()$/;"	f
test40b	test40.c	/^void test40b()$/;"	f
test40c	test40.c	/^void test40c()$/;"	f
test5a	test5.c	/^void test5a()$/;"	f
test5b	test5.c	/^void test5b()$/;"	f
test5c	test5.c	/^void test5c()$/;"	f
test5d	test5.c	/^void test5d()$/;"	f
test5e	test5.c	/^void test5e()$/;"	f
test5f	test5.c	/^void test5f()$/;"	f
test5g	test5.c	/^void test5g()$/;"	f
test5h	test5.c	/^void test5h()$/;"	f
test5i	test5.c	/^void test5i()$/;"	f
test6a	test6.c	/^void test6a()$/;"	f
test6b	test6.c	/^void test6b()$/;"	f
test6c	test6.c	/^void test6c()$/;"	f
test7a	test7.c	/^void test7a()$/;"	f
test7b	test7.c	/^void test7b()$/;"	f
test7c	test7.c	/^void test7c()$/;"	f
test7d	test7.c	/^void test7d()$/;"	f
test7e	test7.c	/^void test7e()$/;"	f
test7f	test7.c	/^void test7f()$/;"	f
test7g	test7.c	/^void test7g()$/;"	f
test7h	test7.c	/^void test7h()$/;"	f
test7i	test7.c	/^void test7i()$/;"	f
test7j	test7.c	/^void test7j()$/;"	f
test8a	test8.c	/^void test8a()$/;"	f
test8b	test8.c	/^void test8b()$/;"	f
test8c	test8.c	/^void test8c()$/;"	f
test8d	test8.c	/^void test8d()$/;"	f
test8e	test8.c	/^void test8e()$/;"	f
test8f	test8.c	/^void test8f()$/;"	f
test8g	test8.c	/^void test8g()$/;"	f
test8h	test8.c	/^void test8h()$/;"	f
test8i	test8.c	/^void test8i()$/;"	f
test8j	test8.c	/^void test8j()$/;"	f
test8k	test8.c	/^void test8k()$/;"	f
test8l	test8.c	/^void test8l()$/;"	f
test8m	test8.c	/^void test8m()$/;"	f
test8n	test8.c	/^void test8n()$/;"	f
test8o	test8.c	/^void test8o()$/;"	f
test9a	test9.c	/^void test9a()$/;"	f
test9b	test9.c	/^void test9b()$/;"	f
test9c	test9.c	/^void test9c()$/;"	f
test9d	test9.c	/^void test9d()$/;"	f
test9e	test9.c	/^void test9e()$/;"	f
test9f	test9.c	/^void test9f()$/;"	f
test_16	ne2000.c	/^static int test_16(dep, pos, pat)$/;"	f	file:
test_8	ne2000.c	/^static int test_8(dep, pos, pat)$/;"	f	file:
test_access	test33.c	/^void test_access()$/;"	f
test_order	floppy.c	/^PRIVATE struct test_order {$/;"	s	file:
test_order	floppy.c	/^} test_order[NT-1] = {$/;"	v	typeref:struct:test_order
test_read	floppy.c	/^PRIVATE int test_read(density)$/;"	f
test_sector	floppy.c	/^PRIVATE char test_sector[NT] =$/;"	v
testdirs	test36.c	/^char *testdirs[] = {$/;"	v
testfiles	test36.c	/^char *testfiles[] = {$/;"	v
tf_conn	tcp_int.h	/^	struct tcp_conn *tf_conn;$/;"	m	struct:tcp_fd	typeref:struct:tcp_fd::tcp_conn
tf_flags	tcp_int.h	/^	int tf_flags;$/;"	m	struct:tcp_fd
tf_get_userdata	tcp_int.h	/^	get_userdata_t tf_get_userdata;$/;"	m	struct:tcp_fd
tf_ioreq	tcp_int.h	/^	int tf_ioreq;$/;"	m	struct:tcp_fd
tf_port	tcp_int.h	/^	tcp_port_t *tf_port;$/;"	m	struct:tcp_fd
tf_put_userdata	tcp_int.h	/^	put_userdata_t tf_put_userdata;$/;"	m	struct:tcp_fd
tf_read_count	tcp_int.h	/^	size_t tf_read_count;$/;"	m	struct:tcp_fd
tf_read_offset	tcp_int.h	/^	size_t tf_read_offset;$/;"	m	struct:tcp_fd
tf_srfd	tcp_int.h	/^	int tf_srfd;$/;"	m	struct:tcp_fd
tf_tcpconf	tcp_int.h	/^	nwio_tcpconf_t tf_tcpconf;$/;"	m	struct:tcp_fd
tf_write_count	tcp_int.h	/^	size_t tf_write_count;$/;"	m	struct:tcp_fd
tf_write_offset	tcp_int.h	/^	size_t tf_write_offset;$/;"	m	struct:tcp_fd
tfixed	aha_scsi.c	/^	    char tfixed;	\/* tape in fixed mode *\/$/;"	m	struct:scsi::__anon12::__anon13	file:
tfixed	aha_scsi.c	355;"	d	file:
tgetent	termcap.c	/^int tgetent(bp, name)$/;"	f
tgetflag	termcap.c	/^int tgetflag(id)$/;"	f
tgetnum	termcap.c	/^int tgetnum(id)$/;"	f
tgetstr	termcap.c	/^char *tgetstr(id, area)$/;"	f
tgoto	termcap.c	/^char *tgoto(cm, destcol, destline)$/;"	f
tim_func	clock.h	/^	timer_func_t tim_func;$/;"	m	struct:timer
tim_next	clock.h	/^	struct timer *tim_next;$/;"	m	struct:timer	typeref:struct:timer::timer
tim_ref	clock.h	/^	int tim_ref;$/;"	m	struct:timer
tim_time	clock.h	/^	time_t tim_time;$/;"	m	struct:timer
time	_time.c	/^PUBLIC time_t time(tp)$/;"	f
time	_time.c	2;"	d	file:
time	asynchio.c	14;"	d	file:
time	misc.c	/^	long	time;$/;"	m	struct:timeb	file:
time_out	asynchio.c	/^static void time_out(int sig)$/;"	f	file:
time_wait_to	tcp_send.c	/^PRIVATE void time_wait_to(conn, timer)$/;"	f
timeb	misc.c	/^struct timeb {$/;"	s	file:
timer	clock.h	/^typedef struct timer$/;"	s
timer_func_t	clock.h	/^typedef void (*timer_func_t) ARGS(( int fd, struct timer *timer ));$/;"	t
timer_t	clock.h	/^} timer_t;$/;"	t	typeref:struct:timer
times	_times.c	/^PUBLIC clock_t times(buf)$/;"	f
times	_times.c	2;"	d	file:
timeval	misc.c	/^struct timeval {$/;"	s	file:
timezone	misc.c	/^	short	timezone;$/;"	m	struct:timeb	file:
timezone	misc.c	/^long	timezone = 0;$/;"	v
timezone	misc.c	/^struct timezone {$/;"	s	file:
tmp	div.c	/^static int tmp = -1;$/;"	v	file:
tmp	ldiv.c	/^static long tmp = -1;$/;"	v	file:
tmp_buf	driver.c	/^u8_t *tmp_buf;			\/* the DMA buffer eventually *\/$/;"	v
tmp_buf	driver.c	/^u8_t tmp_buf[DMA_BUF_SIZE];	\/* the DMA buffer *\/$/;"	v
tmp_phys	driver.c	/^phys_bytes tmp_phys;		\/* phys address of DMA buffer *\/$/;"	v
tmpa	test9.c	/^char *tmpa;$/;"	v
tmpdev	boot.c	/^} bootdev, tmpdev;$/;"	v	typeref:struct:biosdev
tmpfile	tmpfile.c	/^tmpfile(void) {$/;"	f
tmpnam	tmpnam.c	/^tmpnam(char *s) {$/;"	f
tmpwin	curspriv.h	/^  WINDOW  *tmpwin;			\/* window used for updates *\/$/;"	m	struct:__anon20
tname	ps.c	/^char *tname(dev_nr)$/;"	f
toggle_meta_mode	editline.c	/^toggle_meta_mode()$/;"	f
toggle_scroll	console.c	/^PUBLIC void toggle_scroll()$/;"	f
token	boot.c	/^	char		*token;$/;"	m	struct:token	file:
token	boot.c	/^typedef struct token {$/;"	s	file:
token	boot.c	/^} token;$/;"	t	typeref:struct:token	file:
token	edparams.c	/^	char		*token;$/;"	m	struct:token	file:
token	edparams.c	/^typedef struct token {$/;"	s	file:
token	edparams.c	/^} token;$/;"	t	typeref:struct:token	file:
tokenize	boot.c	/^token **tokenize(token **acmds, char *line, int *fundef)$/;"	f
tokenize	edparams.c	/^token **tokenize(token **acmds, char *line, int *fundef)$/;"	f
tolower	tolower.c	/^int tolower(int c) {$/;"	f
tot_mem_size	glo.h	/^EXTERN phys_clicks tot_mem_size;	\/* total system memory size *\/$/;"	v
total_bss	installboot.c	/^long total_text= 0, total_data= 0, total_bss= 0;$/;"	v
total_data	installboot.c	/^long total_text= 0, total_data= 0, total_bss= 0;$/;"	v
total_text	installboot.c	/^long total_text= 0, total_data= 0, total_bss= 0;$/;"	v
touchwin	wintouch.c	/^void touchwin(win)$/;"	f
toupper	toupper.c	/^int toupper(int c) {$/;"	f
tp	param.h	38;"	d
tp_delay_tim	tcp_int.h	/^	timer_t tp_delay_tim;$/;"	m	struct:tcp_port
tp_flags	tcp_int.h	/^	int tp_flags;$/;"	m	struct:tcp_port
tp_ipaddr	tcp_int.h	/^	ipaddr_t tp_ipaddr;$/;"	m	struct:tcp_port
tp_ipdev	tcp_int.h	/^	int tp_ipdev;$/;"	m	struct:tcp_port
tp_ipfd	tcp_int.h	/^	int tp_ipfd;$/;"	m	struct:tcp_port
tp_minor	tcp_int.h	/^	int tp_minor;$/;"	m	struct:tcp_port
tp_pack	tcp_int.h	/^	acc_t *tp_pack;$/;"	m	struct:tcp_port
tp_state	tcp_int.h	/^	int tp_state;$/;"	m	struct:tcp_port
tputs	termcap.c	/^int tputs(cp, affcnt, outc)$/;"	f
tr_block	xt_wini.c	/^  unsigned long tr_block;	\/* first sector to transfer *\/$/;"	m	struct:trans	file:
tr_count	floppy.c	/^  unsigned tr_count;		\/* byte count *\/$/;"	m	struct:trans	file:
tr_count	mcd.c	/^  int tr_count;			\/* Byte count *\/$/;"	m	struct:trans	file:
tr_count	xt_wini.c	/^  unsigned tr_count;		\/* byte count *\/$/;"	m	struct:trans	file:
tr_dma	floppy.c	/^  phys_bytes tr_dma;		\/* DMA physical address *\/$/;"	m	struct:trans	file:
tr_dma	xt_wini.c	/^  phys_bytes tr_dma;		\/* DMA physical address *\/$/;"	m	struct:trans	file:
tr_iop	floppy.c	/^  struct iorequest_s *tr_iop;	\/* belongs to this I\/O request *\/$/;"	m	struct:trans	typeref:struct:trans::iorequest_s	file:
tr_iop	mcd.c	/^  struct iorequest_s *tr_iop;	\/* Belongs to this I\/O request *\/$/;"	m	struct:trans	typeref:struct:trans::iorequest_s	file:
tr_iop	xt_wini.c	/^  struct iorequest_s *tr_iop;	\/* belongs to this I\/O request *\/$/;"	m	struct:trans	typeref:struct:trans::iorequest_s	file:
tr_phys	floppy.c	/^  phys_bytes tr_phys;		\/* user physical address *\/$/;"	m	struct:trans	file:
tr_phys	mcd.c	/^  phys_bytes tr_phys;		\/* User physical address *\/$/;"	m	struct:trans	file:
tr_phys	xt_wini.c	/^  phys_bytes tr_phys;		\/* user physical address *\/$/;"	m	struct:trans	file:
tr_pos	mcd.c	/^  unsigned long tr_pos;		\/* Byte position to transfer from *\/$/;"	m	struct:trans	file:
trans	at_wini.c	/^PRIVATE struct trans {$/;"	s	file:
trans	bios_wini.c	/^PRIVATE struct trans {$/;"	s	file:
trans	esdi_wini.c	/^PRIVATE struct trans {$/;"	s	file:
trans	floppy.c	/^PRIVATE struct trans {		\/* precomputed transfer params *\/$/;"	s	file:
trans	mcd.c	/^PRIVATE struct trans $/;"	s	file:
trans	xt_wini.c	/^PRIVATE struct trans {$/;"	s	file:
transformline	update.c	/^static void transformline(lineno)$/;"	f	file:
transpose	editline.c	/^transpose()$/;"	f
trap	FP_trap.h	22;"	d
trap	edparams.c	/^void trap(int sig)$/;"	f
trap	protect.c	/^  u16_t trap;$/;"	m	struct:tss_s	file:
trap_errno	mpx88.s	/^trap_errno:$/;"	l
trapsig	edparams.c	/^int trapsig;$/;"	v
trlength	aha_scsi.c	189;"	d	file:
truncate	link.c	/^PUBLIC void truncate(rip)$/;"	f
try_access	test18.c	/^void try_access(fname, mode, test)$/;"	f
try_close	test17.c	/^void try_close(filedes, name)$/;"	f
try_close	test18.c	/^void try_close(filedes, name)$/;"	f
try_open	test18.c	/^void try_open(fname, mode, test)$/;"	f
try_unlink	test17.c	/^void try_unlink(fname)$/;"	f
try_unlink	test18.c	/^void try_unlink(fname)$/;"	f
ts2sgs	tty.c	/^} ts2sgs[] = {$/;"	v	typeref:struct:s2s
tspd	tty.c	/^  speed_t	tspd;$/;"	m	struct:s2s	file:
tspd2sgspd	tty.c	/^PRIVATE int tspd2sgspd(tspd)$/;"	f
tss	protect.c	/^PUBLIC struct tss_s tss;	\/* zero init *\/$/;"	v	typeref:struct:tss_s
tss_s	protect.c	/^struct tss_s {$/;"	s	file:
tstat	aha_scsi.c	/^	    struct mtget tstat;	\/* tape status info *\/$/;"	m	struct:scsi::__anon12::__anon13	typeref:struct:scsi::__anon12::__anon13::mtget	file:
tstat	aha_scsi.c	356;"	d	file:
ttargv	getttyent.c	/^static char *ttargv[32];		\/* Compound arguments. *\/$/;"	v	file:
ttfd	getttyent.c	/^static int ttfd= -1;			\/* Filedescriptor to the file. *\/$/;"	v	file:
ttline	getttyent.c	/^static char ttline[256];		\/* One line from the ttytab file. *\/$/;"	v	file:
tty	pty.c	/^  tty_t		*tty;		\/* associated TTY structure *\/$/;"	m	struct:pty	file:
tty	rs232.c	/^  tty_t *tty;			\/* associated TTY structure *\/$/;"	m	struct:rs232	file:
tty	tty.h	/^typedef struct tty {$/;"	s
tty_active	tty.c	80;"	d	file:
tty_addr	tty.c	63;"	d	file:
tty_break	tty.h	/^  devfun_t tty_break;		\/* let the device send a break *\/$/;"	m	struct:tty
tty_close	tty.h	/^  devfun_t tty_close;		\/* tell the device that the tty is closed *\/$/;"	m	struct:tty
tty_dev	ps.c	/^  dev_t tty_dev;		\/* major\/minor pair *\/$/;"	m	struct:__anon1	file:
tty_devnop	tty.c	/^PUBLIC void tty_devnop(tp)$/;"	f
tty_devread	tty.h	/^  devfun_t tty_devread;		\/* routine to read from low level buffers *\/$/;"	m	struct:tty
tty_devwrite	tty.h	/^  devfun_t tty_devwrite;	\/* routine to start actual device output *\/$/;"	m	struct:tty
tty_echo	tty.h	/^  devfunarg_t tty_echo;		\/* routine to echo characters input *\/$/;"	m	struct:tty
tty_eotct	tty.h	/^  int tty_eotct;		\/* number of "line breaks" in input queue *\/$/;"	m	struct:tty
tty_escaped	tty.h	/^  char tty_escaped;		\/* 1 when LNEXT (^V) just seen, else 0 *\/$/;"	m	struct:tty
tty_events	tty.h	/^  int tty_events;		\/* set when TTY should inspect this line *\/$/;"	m	struct:tty
tty_icancel	tty.c	/^PRIVATE void tty_icancel(tp)$/;"	f
tty_icancel	tty.h	/^  devfun_t tty_icancel;		\/* cancel any device input *\/$/;"	m	struct:tty
tty_in_vir	tty.h	/^  vir_bytes tty_in_vir;		\/* virtual address where data is to go *\/$/;"	m	struct:tty
tty_inbuf	tty.h	/^  u16_t tty_inbuf[TTY_IN_BYTES];\/* tty input buffer *\/$/;"	m	struct:tty
tty_incaller	tty.h	/^  char tty_incaller;		\/* process that made the call (usually FS) *\/$/;"	m	struct:tty
tty_incount	tty.h	/^  int tty_incount;		\/* # chars in the input queue *\/$/;"	m	struct:tty
tty_incum	tty.h	/^  int tty_incum;		\/* # chars input so far *\/$/;"	m	struct:tty
tty_inhead	tty.h	/^  u16_t *tty_inhead;		\/* pointer to place where next char goes *\/$/;"	m	struct:tty
tty_inhibited	tty.h	/^  char tty_inhibited;		\/* 1 when STOP (^S) just seen (stops output) *\/$/;"	m	struct:tty
tty_init	tty.c	/^PRIVATE void tty_init(tp)$/;"	f
tty_inleft	tty.h	/^  int tty_inleft;		\/* how many chars are still needed *\/$/;"	m	struct:tty
tty_inproc	tty.h	/^  char tty_inproc;		\/* process that wants to read from tty *\/$/;"	m	struct:tty
tty_inrepcode	tty.h	/^  char tty_inrepcode;		\/* reply code, TASK_REPLY or REVIVE *\/$/;"	m	struct:tty
tty_intail	tty.h	/^  u16_t *tty_intail;		\/* pointer to next char to be given to prog *\/$/;"	m	struct:tty
tty_iocaller	tty.h	/^  char tty_iocaller;		\/* process that made the call (usually FS) *\/$/;"	m	struct:tty
tty_ioctl	tty.h	/^  devfun_t tty_ioctl;		\/* set line speed, etc. at the device level *\/$/;"	m	struct:tty
tty_ioproc	tty.h	/^  char tty_ioproc;		\/* process that wants to do an ioctl *\/$/;"	m	struct:tty
tty_ioreq	tty.h	/^  int tty_ioreq;		\/* ioctl request code *\/$/;"	m	struct:tty
tty_iovir	tty.h	/^  vir_bytes tty_iovir;		\/* virtual address of ioctl buffer *\/$/;"	m	struct:tty
tty_min	tty.h	/^  int tty_min;			\/* minimum requested #chars in input queue *\/$/;"	m	struct:tty
tty_name	ps.c	/^  char tty_name[NAME_MAX + 1];	\/* file name in \/dev *\/$/;"	m	struct:__anon1	file:
tty_ocancel	tty.h	/^  devfun_t tty_ocancel;		\/* cancel any ongoing device output *\/$/;"	m	struct:tty
tty_open	device.c	/^PUBLIC void tty_open(task_nr, mess_ptr)$/;"	f
tty_openct	tty.h	/^  char tty_openct;		\/* count of number of opens of this tty *\/$/;"	m	struct:tty
tty_out_vir	tty.h	/^  vir_bytes tty_out_vir;	\/* virtual address where data comes from *\/$/;"	m	struct:tty
tty_outcaller	tty.h	/^  char tty_outcaller;		\/* process that made the call (usually FS) *\/$/;"	m	struct:tty
tty_outcum	tty.h	/^  int tty_outcum;		\/* # chars output so far *\/$/;"	m	struct:tty
tty_outleft	tty.h	/^  int tty_outleft;		\/* # chars yet to be output *\/$/;"	m	struct:tty
tty_outproc	tty.h	/^  char tty_outproc;		\/* process that wants to write to tty *\/$/;"	m	struct:tty
tty_outrepcode	tty.h	/^  char tty_outrepcode;		\/* reply code, TASK_REPLY or REVIVE *\/$/;"	m	struct:tty
tty_pgrp	tty.h	/^  char tty_pgrp;		\/* slot number of controlling process *\/$/;"	m	struct:tty
tty_position	tty.h	/^  int tty_position;		\/* current position on the screen for echoing *\/$/;"	m	struct:tty
tty_priv	tty.h	/^  void *tty_priv;		\/* pointer to per device private data *\/$/;"	m	struct:tty
tty_reply	tty.c	/^PUBLIC void tty_reply(code, replyee, proc_nr, status)$/;"	f
tty_reprint	tty.h	/^  char tty_reprint;		\/* 1 when echoed input messed up, else 0 *\/$/;"	m	struct:tty
tty_t	tty.h	/^} tty_t;$/;"	t	typeref:struct:tty
tty_table	tty.h	/^EXTERN tty_t tty_table[NR_CONS+NR_RS_LINES+NR_PTYS];$/;"	v
tty_task	tty.c	/^PUBLIC void tty_task()$/;"	f
tty_termios	tty.h	/^  struct termios tty_termios;	\/* terminal attributes *\/$/;"	m	struct:tty	typeref:struct:tty::termios
tty_time	tty.h	/^  clock_t tty_time;		\/* time when the input is available *\/$/;"	m	struct:tty
tty_timelist	tty.h	/^EXTERN tty_t *tty_timelist;	\/* list of ttys with active timers *\/$/;"	v
tty_timenext	tty.h	/^  struct tty *tty_timenext;	\/* for a list of ttys with active timers *\/$/;"	m	struct:tty	typeref:struct:tty::tty
tty_timeout	glo.h	/^EXTERN clock_t tty_timeout;	\/* time to wake up the TTY task *\/$/;"	v
tty_wakeup	tty.c	/^PUBLIC void tty_wakeup(now)$/;"	f
tty_winsize	tty.h	/^  struct winsize tty_winsize;	\/* window size (#lines and #columns) *\/$/;"	m	struct:tty	typeref:struct:tty::winsize
ttyinfo	ps.c	/^ttyinfo_t *ttyinfo;		\/* ttyinfo holds actual tty info *\/$/;"	v
ttyinfo_t	ps.c	/^} ttyinfo_t;$/;"	t	typeref:struct:__anon1	file:
ttyname	ttyname.c	/^PUBLIC char *ttyname(fildes)$/;"	f
ttysetflags	setterm.c	/^static void ttysetflags()$/;"	f	file:
ttyslot	ttyslot.c	/^int ttyslot()$/;"	f
ttytype	cursesio.c	/^char *ttytype;			\/* terminal type from env *\/$/;"	v
tv_sec	misc.c	/^	long	tv_sec;		\/* seconds *\/$/;"	m	struct:timeval	file:
tv_usec	misc.c	/^	long	tv_usec;	\/* and microseconds *\/$/;"	m	struct:timeval	file:
twin	update.c	/^static WINDOW *twin;		\/* used by many routines *\/$/;"	v	file:
two	em_fp8087.s	/^two:$/;"	l
two	fp8087.s	/^two:$/;"	l
two	test15.c	/^char two[50];$/;"	v
two_digits	asctime.c	/^two_digits(register char *pb, int i, int nospace)$/;"	f	file:
txready	rs232.c	132;"	d	file:
txready	rs232.c	170;"	d	file:
type	ether.h	/^    unsigned char type[2];		\/* in network byte order! *\/$/;"	m	struct:etherpacket
type	ether.h	/^    unsigned char type[2];		\/* in network byte order! *\/$/;"	m	struct:ethervec
tz_dsttime	misc.c	/^	int	tz_dsttime;	\/* type of dst correction *\/$/;"	m	struct:timezone	file:
tz_minuteswest	misc.c	/^	int	tz_minuteswest;	\/* minutes west of Greenwich *\/$/;"	m	struct:timezone	file:
tz_name	misc.c	/^	const char *tz_name;$/;"	m	struct:table	file:
tzname	misc.c	/^char	*tzname[2] = {ntstr, dststr};$/;"	v
tzset	tzset.c	/^tzset(void)$/;"	f
u	aha_scsi.c	/^    } u;$/;"	m	struct:scsi	typeref:union:scsi::__anon12	file:
u2a	boot.c	/^char *u2a(U16_t n)$/;"	f
u2a	edparams.c	/^char *u2a(U16_t n)$/;"	f
u_char	gethnmadr.c	/^typedef u8_t u_char;$/;"	t	file:
u_char	gethostent.c	/^typedef u8_t u_char;$/;"	t	file:
u_char	res_comp.c	/^typedef u8_t u_char;$/;"	t	file:
u_char	res_query.c	/^typedef u8_t u_char;$/;"	t	file:
u_int	res_mkquery.c	/^typedef unsigned u_int;$/;"	t	file:
u_long	gethnmadr.c	/^typedef u32_t u_long;$/;"	t	file:
u_long	gethostent.c	/^typedef u32_t u_long;$/;"	t	file:
u_long	res_comp.c	/^typedef u32_t u_long;$/;"	t	file:
u_long	res_mkquery.c	/^typedef u32_t u_long;$/;"	t	file:
u_prnt	strftime.c	/^u_prnt(char *s, size_t maxsize, unsigned val, int width)$/;"	f	file:
u_short	gethnmadr.c	/^typedef u16_t u_short;$/;"	t	file:
u_short	gethostent.c	/^typedef u16_t u_short;$/;"	t	file:
u_short	res_comp.c	/^typedef u16_t u_short;$/;"	t	file:
u_short	res_mkquery.c	/^typedef u16_t u_short;$/;"	t	file:
u_short	res_send.c	/^typedef u16_t u_short;$/;"	t	file:
uctest	test15.c	/^char uctest[] = "\\004\\203";	\/* For testing signedness of chars. *\/$/;"	v
udp_buffree	udp.c	/^PRIVATE void udp_buffree (priority, reqsize)$/;"	f
udp_cancel	udp.c	/^PUBLIC int udp_cancel(fd, which_operation)$/;"	f
udp_close	udp.c	/^PUBLIC void udp_close(fd)$/;"	f
udp_connect	res_send.c	/^static int udp_connect()$/;"	f	file:
udp_fd	udp.c	/^typedef struct udp_fd$/;"	s	file:
udp_fd_t	udp.c	/^} udp_fd_t;$/;"	t	typeref:struct:udp_fd	file:
udp_fd_table	udp.c	/^PRIVATE udp_fd_t udp_fd_table[UDP_FD_NR];$/;"	v
udp_get_data	udp.c	/^PRIVATE acc_t *udp_get_data (port, offset, count, for_ioctl)$/;"	f
udp_init	udp.c	/^PUBLIC void udp_init()$/;"	f
udp_ioctl	udp.c	/^int udp_ioctl (fd, req)$/;"	f
udp_main	udp.c	/^PRIVATE void udp_main(udp_port)$/;"	f
udp_open	udp.c	/^int udp_open (port, srfd, get_userdata, put_userdata)$/;"	f
udp_packet2user	udp.c	/^PRIVATE int udp_packet2user (udp_fd)$/;"	f
udp_port	udp.c	/^typedef struct udp_port$/;"	s	file:
udp_port_t	udp.c	/^} udp_port_t;$/;"	t	typeref:struct:udp_port	file:
udp_port_table	udp.c	/^PRIVATE udp_port_t udp_port_table[UDP_PORT_NR];$/;"	v
udp_put_data	udp.c	/^PRIVATE int udp_put_data (fd, offset, data, for_ioctl)$/;"	f
udp_read	udp.c	/^PUBLIC int udp_read (fd, count)$/;"	f
udp_receive	res_send.c	/^static int udp_receive(fd, buf, buflen, timeout)$/;"	f	file:
udp_restart_write_port	udp.c	/^PRIVATE void udp_restart_write_port(udp_port )$/;"	f
udp_sendto	res_send.c	/^static int udp_sendto(fd, buf, buflen, addr, port)$/;"	f	file:
udp_setopt	udp.c	/^PRIVATE int udp_setopt(udp_fd)$/;"	f
udp_write	udp.c	/^PUBLIC int udp_write(fd, count)$/;"	f
ue	cursesio.c	/^char *ue;			\/* end of underscore *\/$/;"	v
uf_exp_tim	udp.c	/^	time_t uf_exp_tim;$/;"	m	struct:udp_fd	file:
uf_flags	udp.c	/^	int uf_flags;$/;"	m	struct:udp_fd	file:
uf_get_userdata	udp.c	/^	get_userdata_t uf_get_userdata;$/;"	m	struct:udp_fd	file:
uf_ioreq	udp.c	/^	int uf_ioreq;$/;"	m	struct:udp_fd	file:
uf_pack	udp.c	/^	acc_t *uf_pack;$/;"	m	struct:udp_fd	file:
uf_port	udp.c	/^	udp_port_t *uf_port;$/;"	m	struct:udp_fd	file:
uf_put_userdata	udp.c	/^	put_userdata_t uf_put_userdata;$/;"	m	struct:udp_fd	file:
uf_rd_buf	udp.c	/^	acc_t *uf_rd_buf;$/;"	m	struct:udp_fd	file:
uf_rd_count	udp.c	/^	size_t uf_rd_count;$/;"	m	struct:udp_fd	file:
uf_srfd	udp.c	/^	int uf_srfd;$/;"	m	struct:udp_fd	file:
uf_udpopt	udp.c	/^	nwio_udpopt_t uf_udpopt;$/;"	m	struct:udp_fd	file:
uf_wr_count	udp.c	/^	size_t uf_wr_count;$/;"	m	struct:udp_fd	file:
uget2	get_put.h	21;"	d
uget2	get_put.h	25;"	d
ul2a	boot.c	/^char *ul2a(u32_t n)$/;"	f
ul2a	edparams.c	/^char *ul2a(u32_t n)$/;"	f
umap	system.c	/^PUBLIC phys_bytes umap(rp, seg, vir_addr, bytes)$/;"	f
umask	_umask.c	/^PUBLIC mode_t umask(complmode)$/;"	f
umask	_umask.c	2;"	d	file:
umess	read.c	/^PRIVATE message umess;		\/* message for asking SYSTASK for user copy *\/$/;"	v
umode	test22.c	/^int umode(arg)$/;"	f
umount	_umount.c	/^PUBLIC int umount(name)$/;"	f
umount	_umount.c	2;"	d	file:
uname	_uname.c	/^int uname(name) struct utsname *name;$/;"	f
uname	_uname.c	8;"	d	file:
unctrl	unctrl.c	/^char *unctrl(c)$/;"	f
ungetc	ungetc.c	/^ungetc(int ch, FILE *stream)$/;"	f
unhold	proc.c	/^PUBLIC void unhold()$/;"	f
unix_err	boot.c	/^char *unix_err(int err)$/;"	f
unknown	errlist.c	/^static const char unknown[] = "Unknown error";$/;"	v	file:
unlink	_unlink.c	/^PUBLIC int unlink(name)$/;"	f
unlink	_unlink.c	2;"	d	file:
unlink_alot	test17.c	/^int unlink_alot(number)$/;"	f
unlink_file	link.c	/^PRIVATE int unlink_file(dirp, rip, file_name)$/;"	f
unpause	signal.c	/^PRIVATE void unpause(pro)$/;"	f
unready	proc.c	/^PRIVATE void unready(rp)$/;"	f
unschedule	boot.c	/^void unschedule(void)$/;"	f
unschedule	edparams.c	/^void unschedule(void)$/;"	f
up_flags	udp.c	/^	int up_flags;$/;"	m	struct:udp_port	file:
up_ipaddr	udp.c	/^	ipaddr_t up_ipaddr;$/;"	m	struct:udp_port	file:
up_ipdev	udp.c	/^	int up_ipdev;$/;"	m	struct:udp_port	file:
up_ipfd	udp.c	/^	int up_ipfd;$/;"	m	struct:udp_port	file:
up_minor	udp.c	/^	int up_minor;$/;"	m	struct:udp_port	file:
up_next_fd	udp.c	/^	struct udp_fd *up_next_fd;$/;"	m	struct:udp_port	typeref:struct:udp_port::udp_fd	file:
up_state	udp.c	/^	int up_state;$/;"	m	struct:udp_port	file:
up_wr_pack	udp.c	/^	acc_t *up_wr_pack;$/;"	m	struct:udp_port	file:
up_write_fd	udp.c	/^	struct udp_fd *up_write_fd;$/;"	m	struct:udp_port	typeref:struct:udp_port::udp_fd	file:
upbyte	_memmove.s	/^upbyte:	rep$/;"	l
update_conf	dp8390.c	/^static void update_conf(dep, dcp)$/;"	f	file:
update_times	inode.c	/^PUBLIC void update_times(rip)$/;"	f
upword	_memmove.s	/^upword:	shr	ecx, 1$/;"	l
us	cursesio.c	/^char *us;			\/* start of underscore *\/$/;"	v
usage	installboot.c	/^void usage(void)$/;"	f
usage	ps.c	/^void usage(pname)$/;"	f
user_left	printer.c	/^PRIVATE int user_left;		\/* bytes of output left in user buf *\/$/;"	v
user_time	proc.h	/^  clock_t user_time;		\/* user time in ticks *\/$/;"	m	struct:proc
user_vir	printer.c	/^PRIVATE vir_bytes user_vir;	\/* address of remainder of user buf *\/$/;"	v
usetable	misc.c	/^static int usetable = 1;$/;"	v	file:
utime	_utime.c	/^PUBLIC int utime(name, timp)$/;"	f
utime	_utime.c	4;"	d	file:
utime_actime	param.h	39;"	d
utime_file	param.h	41;"	d
utime_length	param.h	42;"	d
utime_modtime	param.h	40;"	d
v7ent	_readdir.c	18;"	d	file:
value	boot.h	/^	char	*value;$/;"	m	struct:environment
value	console.c	/^	unsigned char value;$/;"	m	struct:sequence	file:
value	edparams.c	/^	char	*value;$/;"	m	struct:environment	file:
vargv	dmp.c	/^char *vargv;$/;"	v
variating_option	test36.c	/^int variating_option(option, minimum)$/;"	f
vb	cursesio.c	/^char *vb;			\/* visual bell *\/$/;"	v
ve	cursesio.c	/^char *ve;			\/* cursor normal *\/$/;"	v
vector	boot.h	/^typedef struct vector {$/;"	s
vector	boot.h	/^} vector;$/;"	t	typeref:struct:vector
vendor	aha_scsi.c	/^    char vendor[8];		\/* Vendor name *\/$/;"	m	struct:__anon9	file:
version	boot.c	/^char version[]=		"2.5";$/;"	v
vfprintf	vfprintf.c	/^vfprintf(FILE *stream, const char *format, va_list arg)$/;"	f
vga	glo.h	/^EXTERN int vga;			\/* nonzero if console is VGA *\/$/;"	v
vi	cursesio.c	/^char *vi;			\/* cursor invisible *\/$/;"	v
vid_base	console.c	/^PRIVATE unsigned vid_base;	\/* base of video ram (0xB000 or 0xB800) *\/$/;"	v
vid_mask	console.c	/^PUBLIC unsigned vid_mask;	\/* 0x1FFF for color or 0x07FF for mono *\/$/;"	v
vid_port	console.c	/^PRIVATE int vid_port;		\/* I\/O port for accessing 6845 *\/$/;"	v
vid_seg	console.c	/^PUBLIC unsigned vid_seg;	\/* video ram selector (0xB0000 or 0xB8000) *\/$/;"	v
vid_size	console.c	/^PUBLIC unsigned vid_size;	\/* 0x2000 for color or 0x0800 for mono *\/$/;"	v
vidok	boothead.s	/^vidok:	ret$/;"	l
vir2phys	const.h	142;"	d
vir2sec	bootimage.c	/^u32_t (*vir2sec)(u32_t vsec);		\/* Where is a sector on disk? *\/$/;"	v
voidtoken	boot.c	/^void voidtoken(void)$/;"	f
voidtoken	edparams.c	/^void voidtoken(void)$/;"	f
vprintf	vprintf.c	/^vprintf(const char *format, va_list arg)$/;"	f
vs	cursesio.c	/^char *vs;			\/* cursor good visible *\/$/;"	v
vscanf	vscanf.c	/^vscanf(const char *format, va_list ap)$/;"	f
vsprintf	vsprintf.c	/^vsprintf(char *s, const char *format, va_list arg)$/;"	f
vsscanf	vsscanf.c	/^int vsscanf(const char *s, const char *format, va_list ap)$/;"	f
vvc_done	klib386.s	/^vvc_done:$/;"	l
vvc_done	klib88.s	/^vvc_done:$/;"	l
vvc_down	klib386.s	/^vvc_down:$/;"	l
vvc_down	klib88.s	/^vvc_down:$/;"	l
vvc_downloop	klib386.s	/^vvc_downloop:$/;"	l
vvc_downloop	klib88.s	/^vvc_downloop:$/;"	l
vvc_up	klib386.s	/^vvc_up:$/;"	l
vvc_up	klib88.s	/^vvc_up:$/;"	l
vvc_uploop	klib386.s	/^vvc_uploop:$/;"	l
vvc_uploop	klib88.s	/^vvc_uploop:$/;"	l
w_att_write	esdi_wini.c	/^PRIVATE int w_att_write(value)$/;"	f
w_command	at_wini.c	/^PRIVATE int w_command;			\/* current command in execution *\/$/;"	v
w_command	esdi_wini.c	/^PRIVATE int w_command(device, cmd, num_words)$/;"	f
w_count	at_wini.c	/^PRIVATE unsigned w_count;		\/* number of bytes to transfer *\/$/;"	v
w_count	bios_wini.c	/^PRIVATE unsigned w_count;		\/* number of bytes to transfer *\/$/;"	v
w_count	esdi_wini.c	/^PRIVATE unsigned w_count;	\/* number of bytes to transfer           *\/$/;"	v
w_count	xt_wini.c	/^PRIVATE unsigned w_count;		\/* number of bytes to transfer *\/$/;"	v
w_dma_setup	esdi_wini.c	/^PRIVATE void w_dma_setup(tp, count)$/;"	f
w_dma_setup	xt_wini.c	/^PRIVATE void w_dma_setup(tp, count)$/;"	f
w_do_close	at_wini.c	/^PRIVATE int w_do_close(dp, m_ptr)$/;"	f
w_do_close	bios_wini.c	/^PRIVATE int w_do_close(dp, m_ptr)$/;"	f
w_do_close	esdi_wini.c	/^PRIVATE int w_do_close(dp, m_ptr)$/;"	f
w_do_close	xt_wini.c	/^PRIVATE int w_do_close(dp, m_ptr)$/;"	f
w_do_open	at_wini.c	/^PRIVATE int w_do_open(dp, m_ptr)$/;"	f
w_do_open	bios_wini.c	/^PRIVATE int w_do_open(dp, m_ptr)$/;"	f
w_do_open	esdi_wini.c	/^PRIVATE int w_do_open(dp, m_ptr)$/;"	f
w_do_open	xt_wini.c	/^PRIVATE int w_do_open(dp, m_ptr)$/;"	f
w_drive	at_wini.c	/^PRIVATE int w_drive;			\/* selected drive *\/$/;"	v
w_drive	bios_wini.c	/^PRIVATE int w_drive;			\/* selected drive *\/$/;"	v
w_drive	esdi_wini.c	/^PRIVATE int w_drive;		\/* selected drive                        *\/$/;"	v
w_drive	xt_wini.c	/^PRIVATE int w_drive;			\/* selected drive *\/$/;"	v
w_dtab	at_wini.c	/^PRIVATE struct driver w_dtab = {$/;"	v	typeref:struct:driver
w_dtab	bios_wini.c	/^PRIVATE struct driver w_dtab = {$/;"	v	typeref:struct:driver
w_dtab	esdi_wini.c	/^PRIVATE struct driver w_dtab = {$/;"	v	typeref:struct:driver
w_dtab	xt_wini.c	/^PRIVATE struct driver w_dtab = {$/;"	v	typeref:struct:driver
w_dv	at_wini.c	/^PRIVATE struct device *w_dv;		\/* device's base and size *\/$/;"	v	typeref:struct:device
w_dv	bios_wini.c	/^PRIVATE struct device *w_dv;		\/* device's base and size *\/$/;"	v	typeref:struct:device
w_dv	esdi_wini.c	/^PRIVATE struct device *w_dv;	\/* device's base and size                *\/$/;"	v	typeref:struct:device
w_dv	xt_wini.c	/^PRIVATE struct device *w_dv;		\/* device's base and size *\/$/;"	v	typeref:struct:device
w_finish	at_wini.c	/^PRIVATE int w_finish()$/;"	f
w_finish	bios_wini.c	/^PRIVATE int w_finish()$/;"	f
w_finish	esdi_wini.c	/^PRIVATE int w_finish()$/;"	f
w_finish	xt_wini.c	/^PRIVATE int w_finish()$/;"	f
w_geometry	at_wini.c	/^PRIVATE void w_geometry(entry)$/;"	f
w_geometry	bios_wini.c	/^PRIVATE void w_geometry(entry)$/;"	f
w_geometry	esdi_wini.c	/^PRIVATE void w_geometry(entry)$/;"	f
w_geometry	xt_wini.c	/^PRIVATE void w_geometry(entry)$/;"	f
w_handler	at_wini.c	/^PRIVATE int w_handler(irq)$/;"	f
w_handler	esdi_wini.c	/^PRIVATE int w_handler(irq)$/;"	f
w_handler	xt_wini.c	/^PRIVATE int w_handler(irq)$/;"	f
w_identify	at_wini.c	/^PRIVATE int w_identify()$/;"	f
w_init	bios_wini.c	/^PRIVATE void w_init()$/;"	f
w_init	esdi_wini.c	/^PRIVATE void w_init()$/;"	f
w_init	xt_wini.c	/^PRIVATE void w_init()$/;"	f
w_interrupt	esdi_wini.c	/^PRIVATE void w_interrupt(dma)$/;"	f
w_intr_wait	at_wini.c	/^PRIVATE int w_intr_wait()$/;"	f
w_istat	esdi_wini.c	/^PRIVATE int w_istat;		\/* interrupt status of last command      *\/$/;"	v
w_name	at_wini.c	/^PRIVATE char *w_name()$/;"	f
w_name	bios_wini.c	/^PRIVATE char *w_name()$/;"	f
w_name	esdi_wini.c	/^PRIVATE char *w_name()$/;"	f
w_name	xt_wini.c	/^PRIVATE char *w_name()$/;"	f
w_need_reset	at_wini.c	/^PRIVATE void w_need_reset()$/;"	f
w_need_reset	xt_wini.c	/^PRIVATE int w_need_reset = FALSE;	\/* set when controller must be reset *\/$/;"	v
w_nextblock	at_wini.c	/^PRIVATE unsigned long w_nextblock;	\/* next block on disk to transfer *\/$/;"	v
w_nextblock	bios_wini.c	/^PRIVATE unsigned long w_nextblock;	\/* next block on disk to transfer *\/$/;"	v
w_nextblock	esdi_wini.c	/^PRIVATE unsigned long w_nextblock;	\/* next block on disk to transfer *\/$/;"	v
w_nextblock	xt_wini.c	/^PRIVATE unsigned long w_nextblock;	\/* next block on disk to transfer *\/$/;"	v
w_opcode	at_wini.c	/^PRIVATE int w_opcode;			\/* DEV_READ or DEV_WRITE *\/$/;"	v
w_opcode	bios_wini.c	/^PRIVATE int w_opcode;			\/* DEV_READ or DEV_WRITE *\/$/;"	v
w_opcode	esdi_wini.c	/^PRIVATE int w_opcode;		\/* DEV_READ or DEV_WRITE                 *\/$/;"	v
w_opcode	xt_wini.c	/^PRIVATE int w_opcode;			\/* DEV_READ or DEV_WRITE *\/$/;"	v
w_prepare	at_wini.c	/^PRIVATE struct device *w_prepare(device)$/;"	f
w_prepare	bios_wini.c	/^PRIVATE struct device *w_prepare(device)$/;"	f
w_prepare	esdi_wini.c	/^PRIVATE struct device *w_prepare(device)$/;"	f
w_prepare	xt_wini.c	/^PRIVATE struct device *w_prepare(device)$/;"	f
w_reset	at_wini.c	/^PRIVATE int w_reset()$/;"	f
w_reset	xt_wini.c	/^PRIVATE int w_reset()$/;"	f
w_results	xt_wini.c	/^PRIVATE char w_results[MAX_RESULTS];\/* the controller can give lots of output *\/$/;"	v
w_schedule	at_wini.c	/^PRIVATE int w_schedule(proc_nr, iop)$/;"	f
w_schedule	bios_wini.c	/^PRIVATE int w_schedule(proc_nr, iop)$/;"	f
w_schedule	esdi_wini.c	/^PRIVATE int w_schedule(proc_nr, iop)$/;"	f
w_schedule	xt_wini.c	/^PRIVATE int w_schedule(proc_nr, iop)$/;"	f
w_specify	at_wini.c	/^PRIVATE int w_specify()$/;"	f
w_status	at_wini.c	/^PRIVATE int w_status;			\/* status after interrupt *\/$/;"	v
w_status	popen.c	/^	int	w_status;$/;"	m	union:wait	file:
w_switches	xt_wini.c	/^PRIVATE int w_switches;			\/* Drive type switches *\/$/;"	v
w_timeout	at_wini.c	/^PRIVATE void w_timeout()$/;"	f
w_tp	at_wini.c	/^PRIVATE struct trans *w_tp;		\/* to add transfer requests *\/$/;"	v	typeref:struct:trans
w_tp	bios_wini.c	/^PRIVATE struct trans *w_tp;		\/* to add transfer requests *\/$/;"	v	typeref:struct:trans
w_tp	esdi_wini.c	/^PRIVATE struct trans *w_tp;	\/* to add transfer requests              *\/$/;"	v	typeref:struct:trans
w_tp	xt_wini.c	/^PRIVATE struct trans *w_tp;		\/* to add transfer requests *\/$/;"	v	typeref:struct:trans
w_transfer	esdi_wini.c	/^PRIVATE int w_transfer(tp, count)$/;"	f
w_transfer	xt_wini.c	/^PRIVATE int w_transfer(tp, count)$/;"	f
w_waitfor	at_wini.c	/^PRIVATE int w_waitfor(mask, value)$/;"	f
w_wn	at_wini.c	/^} wini[MAX_DRIVES], *w_wn;$/;"	v	typeref:struct:wini
w_wn	bios_wini.c	/^} wini[MAX_DRIVES], *w_wn;$/;"	v	typeref:struct:wini
w_wn	esdi_wini.c	/^} wini[MAX_DRIVES], *w_wn;$/;"	v	typeref:struct:wini
w_wn	xt_wini.c	/^} wini[MAX_DRIVES], *w_wn;$/;"	v	typeref:struct:wini
waddch	waddch.c	/^int waddch(win, c)$/;"	f
waddstr	waddstr.c	/^int waddstr(win, str)$/;"	f
wait	_wait.c	/^PUBLIC pid_t wait(status)$/;"	f
wait	_wait.c	2;"	d	file:
wait	popen.c	/^union wait {$/;"	u	file:
wait_arg	popen.c	/^typedef int wait_arg;$/;"	t	file:
wait_arg	popen.c	/^typedef union wait wait_arg;$/;"	t	typeref:union:wait	file:
wait_for	test8.c	/^void wait_for(pid)$/;"	f
waitfor	at_wini.c	169;"	d	file:
waitpid	_waitpid.c	/^PUBLIC pid_t waitpid(pid, status, options)$/;"	f
waitpid	_waitpid.c	2;"	d	file:
waitpid	crypt.c	15;"	d	file:
walk_queue	sr.c	/^PRIVATE int walk_queue(sr_fd, q_head, q_tail_ptr, type, proc_nr)$/;"	f
waserror	test15.c	/^int waserror = 0;		\/* For exit status. *\/$/;"	v
watch_dog	clock.c	/^PRIVATE watchdog_t watch_dog[NR_TASKS+NR_PROCS];$/;"	v
watchdog_proc	clock.c	/^PRIVATE int watchdog_proc;	\/* contains proc_nr at call of *watch_dog[]*\/$/;"	v
wbox	wbox.c	/^int wbox(win, ymin, xmin, ymax, xmax, v, h)$/;"	f
wclear	wclear.c	/^void wclear(win)$/;"	f
wclrtobot	wclrtobot.c	/^int wclrtobot(win)$/;"	f
wclrtoeol	wclrtoeol.c	/^int wclrtoeol(win)$/;"	f
wcstombs	wcstombs.c	/^wcstombs(register char *s, register const wchar_t *pwcs, size_t n)$/;"	f
wctomb	wctomb.c	/^wctomb(char *s, wchar_t wchar)$/;"	f
wdelch	wdelch.c	/^int wdelch(win)$/;"	f
wdeleteln	wdeleteln.c	/^int wdeleteln(win)$/;"	f
wdeth_probe	wdeth.c	/^int wdeth_probe(dep)$/;"	f
we_16bitboard	wdeth.c	/^static int we_16bitboard(dep)$/;"	f	file:
we_16bitslot	wdeth.c	/^static int we_16bitslot(dep)$/;"	f	file:
we_790int_table	wdeth.c	/^static int we_790int_table[8]= { 0, 9, 3, 5, 7, 10, 11, 15 };$/;"	v	file:
we_aliasing	wdeth.c	/^static int we_aliasing(dep)$/;"	f	file:
we_init	wdeth.c	/^static void we_init(dep)$/;"	f	file:
we_int_table	wdeth.c	/^static int we_int_table[8]= { 9, 3, 5, 7, 10, 11, 15, 4 };$/;"	v	file:
we_interface_chip	wdeth.c	/^static int we_interface_chip(dep)$/;"	f	file:
we_stop	wdeth.c	/^static void we_stop(dep)$/;"	f	file:
we_ultra	wdeth.c	/^static int we_ultra(dep)$/;"	f	file:
werase	werase.c	/^void werase(win)$/;"	f
wgetch	wgetch.c	/^int wgetch(win)$/;"	f
wgetstr	wgetstr.c	/^int wgetstr(win, str)$/;"	f
whatfun	boot.c	/^enum whatfun { NOFUN, SELECT, DEFFUN, USERFUN } menufun(environment *e)$/;"	g	file:
whatfun	edparams.c	/^enum whatfun { NOFUN, SELECT, DEFFUN, USERFUN } menufun(environment *e)$/;"	g	file:
whence	param.h	43;"	d
whence	test7.c	/^int whence = SEEK_SET, func_code = F_SETLK;$/;"	v
white	getttyent.c	/^static int white(int c)$/;"	f	file:
win_out	xt_wini.c	/^PRIVATE void win_out(val)$/;"	f
win_results	xt_wini.c	/^PRIVATE int win_results()$/;"	f
win_specify	xt_wini.c	/^PRIVATE int win_specify(drive)$/;"	f
winch	charpick.c	/^int winch(win)$/;"	f
winchester	bootblock.s	/^winchester:$/;"	l
winchester	boothead.s	/^winchester:$/;"	l
winchester_task	wini.c	/^PUBLIC void winchester_task()$/;"	f
wini	at_wini.c	/^PRIVATE struct wini {		\/* main drive struct, one entry per drive *\/$/;"	s	file:
wini	at_wini.c	/^} wini[MAX_DRIVES], *w_wn;$/;"	v	typeref:struct:wini
wini	bios_wini.c	/^PRIVATE struct wini {		\/* main drive struct, one entry per drive *\/$/;"	s	file:
wini	bios_wini.c	/^} wini[MAX_DRIVES], *w_wn;$/;"	v	typeref:struct:wini
wini	esdi_wini.c	/^PRIVATE struct wini {		\/* disk\/partition information            *\/$/;"	s	file:
wini	esdi_wini.c	/^} wini[MAX_DRIVES], *w_wn;$/;"	v	typeref:struct:wini
wini	xt_wini.c	/^PRIVATE struct wini {		\/* main drive struct, one entry per drive *\/$/;"	s	file:
wini	xt_wini.c	/^} wini[MAX_DRIVES], *w_wn;$/;"	v	typeref:struct:wini
winsch	winsch.c	/^int winsch(win, c)$/;"	f
winsertln	winsertln.c	/^int winsertln(win)$/;"	f
winsize_defaults	tty.c	/^PRIVATE struct winsize winsize_defaults;	\/* = all zeroes *\/$/;"	v	typeref:struct:winsize
wipe	editline.c	/^wipe()$/;"	f
wipe_inode	inode.c	/^PUBLIC void wipe_inode(rip)$/;"	f
wmove	move.c	/^int wmove(win, y, x)$/;"	f
wn_ctlbyte	xt_wini.c	/^  unsigned wn_ctlbyte;		\/* control byte for COMMANDS (10-Apr-87 GO) *\/$/;"	m	struct:wini	file:
wn_cylinders	xt_wini.c	/^  unsigned wn_cylinders;	\/* number of cylinders *\/$/;"	m	struct:wini	file:
wn_heads	xt_wini.c	/^  unsigned wn_heads;		\/* number of heads *\/$/;"	m	struct:wini	file:
wn_max_ecc	xt_wini.c	/^  unsigned wn_max_ecc;		\/* maximum ECC burst length *\/$/;"	m	struct:wini	file:
wn_open_ct	xt_wini.c	/^  unsigned wn_open_ct;		\/* in-use count *\/$/;"	m	struct:wini	file:
wn_part	xt_wini.c	/^  struct device wn_part[DEV_PER_DRIVE];    \/* primary partitions: hd[0-4] *\/$/;"	m	struct:wini	typeref:struct:wini::device	file:
wn_precomp	xt_wini.c	/^  unsigned wn_precomp;		\/* first cylinder with write precompensation *\/$/;"	m	struct:wini	file:
wn_reduced_wr	xt_wini.c	/^  unsigned wn_reduced_wr;	\/* first cylinder with reduced write current *\/$/;"	m	struct:wini	file:
wn_subpart	xt_wini.c	/^  struct device wn_subpart[SUB_PER_DRIVE]; \/* subpartitions: hd[1-4][a-d] *\/$/;"	m	struct:wini	typeref:struct:wini::device	file:
wnoutrefresh	refresh.c	/^void wnoutrefresh(win)$/;"	f
wprintw	prntscan.c	/^int wprintw(WINDOW *win, const char *fmt, ...)$/;"	f
wr_indir	write.c	/^PRIVATE void wr_indir(bp, index, zone)$/;"	f
wrap	console.c	/^PRIVATE int wrap;		\/* hardware can wrap? *\/$/;"	v
wrcaller	pty.c	/^  char		wrcaller;	\/* process making the call (usually FS) *\/$/;"	m	struct:pty	file:
wrcum	pty.c	/^  int		wrcum;		\/* # bytes written so far *\/$/;"	m	struct:pty	file:
wreboot	keyboard.c	/^PUBLIC void wreboot(how)$/;"	f
wrefresh	refresh.c	/^void wrefresh(win)$/;"	f
write	_longjerr.c	3;"	d	file:
write	_write.c	/^PUBLIC ssize_t write(fd, buffer, nbytes)$/;"	f
write	_write.c	2;"	d	file:
write	asynchio.c	15;"	d	file:
write	crypt.c	14;"	d	file:
write	getpass.c	9;"	d	file:
write2port	tcp_send.c	/^PRIVATE void write2port(tcp_port, data)$/;"	f
writeEtherAddr	io.c	/^PUBLIC void writeEtherAddr(addr)$/;"	f
writeIpAddr	io.c	/^PUBLIC void writeIpAddr(addr)$/;"	f
write_int	mnx_eth.c	/^PRIVATE void write_int(eth_port)$/;"	f
write_map	write.c	/^PRIVATE int write_map(rip, position, new_zone)$/;"	f
write_standards	test18.c	/^void write_standards(filedes, a)$/;"	f
writeblock	installboot.c	/^void writeblock(off_t blk, char *buf)$/;"	f
writerr	boot.c	/^void writerr(off_t sec, int err)	{ rwerr("Write", sec, err); }$/;"	f
writing	printer.c	/^PRIVATE int writing;		\/* nonzero while write is in progress *\/$/;"	v
wrleft	pty.c	/^  int		wrleft;		\/* # bytes yet to be written *\/$/;"	m	struct:pty	file:
wrproc	pty.c	/^  char		wrproc;		\/* process that wants to write to the pty *\/$/;"	m	struct:pty	file:
wrrepcode	pty.c	/^  char		wrrepcode;	\/* reply code, TASK_REPLY or REVIVE *\/$/;"	m	struct:pty	file:
wrvir	pty.c	/^  vir_bytes	wrvir;		\/* virtual address in writers address space *\/$/;"	m	struct:pty	file:
wscanw	prntscan.c	/^int wscanw(WINDOW *win, const char *fmt, ...)$/;"	f
wsetscrreg	scrreg.c	/^int wsetscrreg(win, top, bottom)$/;"	f
wtabsize	tabsize.c	/^int wtabsize(win, ts)$/;"	f
wtmp	init.c	/^void wtmp(type, linenr, line, pid)$/;"	f
wtrans	at_wini.c	/^} wtrans[NR_IOREQS];$/;"	v	typeref:struct:trans
wtrans	bios_wini.c	/^} wtrans[NR_IOREQS];$/;"	v	typeref:struct:trans
wtrans	esdi_wini.c	/^} wtrans[NR_IOREQS];$/;"	v	typeref:struct:trans
wtrans	xt_wini.c	/^} wtrans[NR_IOREQS];$/;"	v	typeref:struct:trans
x	test8.c	/^int x;$/;"	v
x_bios_desc	boothead.s	/^x_bios_desc:$/;"	l
x_dst_desc	boothead.s	/^x_dst_desc:$/;"	l
x_gdt	boothead.s	/^x_gdt:$/;"	l
x_gdt_desc	boothead.s	/^x_gdt_desc:$/;"	l
x_null_desc	boothead.s	/^x_null_desc:$/;"	l
x_src_desc	boothead.s	/^x_src_desc:$/;"	l
x_ss_desc	boothead.s	/^x_ss_desc:$/;"	l
xchg	trp.s	/^xchg    bx,.trppc$/;"	l
xfd	test7.c	/^int subtest, errct, xfd;$/;"	v
xmit_port	rs232.c	/^  port_t xmit_port;		\/* i\/o ports *\/$/;"	m	struct:rs232	file:
xor	trp.s	/^xor     bx,bx$/;"	l
xt_winchester_task	xt_wini.c	/^PUBLIC void xt_winchester_task()$/;"	f
xvesa	boothead.s	/^xvesa:	mov	bx, ax		! bx = extended mode$/;"	l
y	test8.c	/^static int y;$/;"	v	file:
yank	editline.c	/^yank()$/;"	f
yyerror	yyerror.c	/^yyerror(msg)$/;"	f
z	test8.c	/^static int z;$/;"	v	file:
zero	test5.c	/^int zero[1024];$/;"	v
zero_block	write.c	/^PUBLIC void zero_block(bp)$/;"	f
zilch	test6.c	/^int zilch[5000];$/;"	v
zone_shift	rawfs.c	58;"	d	file:
zoneoffset	misc.c	/^	const long zoneoffset;$/;"	m	struct:table	file:
zrf4	zrf4.c	/^zrf4(l)$/;"	f
zrf8	zrf8.c	/^zrf8(z)$/;"	f
zrf_ext	zrf_ext.c	/^zrf_ext(e)$/;"	f
